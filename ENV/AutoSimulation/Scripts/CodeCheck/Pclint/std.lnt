

/*======================================*/
/* 告警信息格式控制                     */
/*======================================*/
-"format=LN_ER: %(%F %l: %)%t %n %m"
-width(0)                             // 不断行
-hFmn1      // always supply a File but no macro
/*============================================================================*/
/* 统一控制编码告警输出级别为3【含错误、告警、提示】，库文件告警全部屏蔽      */
/*============================================================================*/
-w0
-wlib(0)
+libclass(all)  // 设定所有.h文件的检测规则为库文件的检测规则，即受-wlib(0)  -elib(0)的控制

/*===============================================*/
/* 自定义宏区，可将MakeFile中定义的宏转移到这里  */
/*===============================================*/
/*===============================================*/
/* -dDOS                                         */
/* -dalpha=0                                     */
/* -dX=                                          */
/* 等同于如下定义：                              */
/* #define       DOS     1                       */
/* #define       alpha     0                     */
/* #define       X                               */
/*===============================================*/
-dfw_ver=
-dVT3514_C0=
-dBOOTLOADER=
/*-dSIM=*/

/*======================================*/
/* 自行裁减规则区【不得和A类告警冲突】  */
/*======================================*/

-e46    // 屏蔽 Field type should be int, 基本目前使用的编译器都支持非int类型的位域成员

//-e402     // 静态函数"Symbol"没有被定义
//-e429	    // 申请了内存的指针没有被释放也没有被传出。有的情况是此处申请内存，另外一个地方释放，如果没有释放掉，使用Purify检查时候会提示内存泄露的
//-e506		// 在if()或者while()， or !等语句总出现常量bool类型常量，导致每次进行判断都是同一条件
-e528       // 屏蔽 符号没有被引用，如定义了10个故障ID,即使当前没有全部用到，也应保留完整定义
-e534  /*提示没有对返回值处理*/
-e539		// 屏蔽 控制语句代码对齐问题，pclint认为上一个if判断语句块结束之后的下一个语句应该缩进，对于IF语句，无此必要
//-e548		// 有if没有else
-e716         //屏蔽while(1)
//-e747		// 屏蔽 不允许类型强制转换
-e749		// 屏蔽 枚举中的部分成员定义了但是并没有使用。很多时候是为以后预留也没什么隐患
-e754		// 屏蔽 结构中的部分成员定义了但是并没有使用。很多时候是为以后预留也没什么隐患
-e755		// 屏蔽 全局宏没有使用。备用或者实际需要
-e759		// 屏蔽 未被外部引用的声明应该从头文件移动到模块中。备用或者实际需要
-e768		// 屏蔽 结构体成员没有被引用。备用或者实际需要

//-e818		// 指针类型的参数应该声明为const，ason软件里的送消处理函数不能将指针定为const的+e603    /* 定义的变量未初始化，便直接在函数调用中使用其地址，但该函数的该参数是const声明的，不会对内容进行修改 */
//-e826		// 有争议的(可疑的)指针转化，必要的转换，无法修改
-e834		// 多运算符加括号无必要，人为增加阅读复杂化。代码应简洁清晰。小学生都知道乘除优先加减。
-e970		// 使用的修改符或类型不是自己定义的类型,如果定义typedef unsigned char UCHR，则只能用UCHR，而不能用unsigned char

/*======================================*/
/* A类告警+牛人的建议，必查项，不得修改 */
/*======================================*/
-fwc        /* 不将wchar_t作为标准类型，缺省值 */
-fnc        /* 不允许使用嵌套注释，缺省值 */
-ident(31)  /* 标识符最大长度为31字符，超过此长度将被lint认为是同一个标识符 */

+e413       /* [MISRA Rule 107]在操作符的左边或者右边，确定使用了NULL指针 */
+e414       /* 可能被0除：在语句的上下文中，“/”或者“%”操作符的第二个参数可能是0 */
+e415       /* 数组使用过程中存在数组下标越界的情况，并指明越界的下标数(写越界) */
+e416       /* 创建一个指向数组的指针，但是这个指针超出了数组的范围(读越界) */
+e418       /* 将空指针作为参数传递给函数 */
+e419       /* 传递给函数的整形值参数超出了范围：主要指memcpy, strcpy, fgets等数据移动或转换函数中的参数之间有隐含语义关系的函数 */
+e420       /* 函数对数据访问存在越界操作，传递给函数的整形参数超出了范围。对一些库函数（如fwrite, memcmp,等）的调用会出现此信息，出现此信息时，存在明显写越界行为。如：在调用fwrite时写的长度大于数据区的大小，会出现此信息 */
+e422       /* 申请了长度为负值的缓冲区 */
+e424       /* 对于malloc, new, new[], static, auto, member, modified 或者constant指定的内存区域，执行了不适当的释放方法 */
+e428       /* 数组或者指针下标可能是负数' */
+e437       /* 将结构类型作为参数传递给函数的变参 */
+e449       /* 动态申请的指针变量在释放以后仍然使用 */

+e512       /* [Misra Rule 24] 函数或变量在其他模块中有同名的静态类型定义 */
+e515       /* 函数调用参数个数与定义不符，主要对于printf等变长参数，可用+fva选项抑制，活在该函数声明处用//lint +fva 以消除本告警 */
+e516       /* [MISRA Rule 72] 函数调用参数类型与函数定义的参数类型不同，导致冲突，对于printf等变长参数将出现本告警, 消除方法同515 */
+e524       /* [MISRA Rule 43] 从浮点型到整型的量的转换可能出现出现丢失部分内容 */
+e527       /* [MISRA Rule 52] 不可执行到的代码 */
+e530       /* [MISRA Rule 30] 使用未初始化的变量；如果为指针变量则属于野指针，重大隐患 */
+e532       /* [MISRA Rule 72] 外部声明的函数缺少返回类型或全局变量缺少定义类型；或者类型与实际定义不匹配 */
+e547       /* 宏重复定义*/
+e553       /* [MISRA Rule 97] 使用了未定义的预处理变量，如#if DEBUG ，但是没有定义DEBUG */
+e559       /* 参数类型与对应格式字符串不匹配（to printf, fprintf, sprintf, scanf, fscanf, or sscanf） */
+e564       /* [MISRA Rule 46] 变量的值依赖于表达式计算顺序（不同的CPU的计算顺序不同，会导致移植错误） */
+e567       /* printf/scanf系列函数中的某些格式中对于数据域超出 */
+e568       /* 对于无符号数，不可能小于0，但在比较语句中，使用了无符号数小于0的判断 */
+e569       /* 信息丢失，如常量赋给一个不能容纳该常量大小的整型变量等 */
+e572       /* [MISRA Rule 38] 移位操作bit数超过了操作数的bit位，比如对char进行右移10bit的操作 */
+e578       /* [Misra Rule 12] 全局变量与局部变量重名，导致局部变量被屏蔽 */
+e580       /* [Misra Rule 12] 函数重复声明，导致本地声明被全局声明屏蔽 */

+e602       /* [Misra Rule 9] 注释里面套注释 */
+e603       /* 定义的变量未初始化，便直接在函数调用中使用其地址，但该函数的该参数是const声明的，不会对内容进行修改 */
+e605       /* 普通指针与常量指针间赋值操作造成指针使用的权限变大 */
+e606       /* [Misra Rule 5] 存在非ANSI标准的转义序列 如\x \y 等 */
+e611       /* 可疑的强制类型转换: 当函数指针强制转换到一个对象指针,或者相反 */
+e613       /* [MISRA Rule 107] 某些运算中可能使用空指针 */
+e616       /* [MISRA Rule 61 ] switch-case 语句中缺少break，可在注释中添加“fall through”以抑制本告警 */
+e621       /* [Misra Rule 11 ] 标识符重复定义，其判定长度由ident确定 */
+e623       /* [Misra Rule 17 ] 标识符存储类型重复定义，如定义了UINT32后,在别的模块中又重新定义了不同类型的UINT32 */
+e626       /* printf (or fprintf or sprintf)的参数类型与格式不一致，尽管两者的尺寸大小是一样的 */
+e644       /* [MISRA Rule 30] 在某些语句分支中，变量未初始化即使用 */
+e650       /* 字符串操作（比较）时常量超出范围导致比较运算值恒为真或假 */
+e652       /* 宏定义和之前定义的变量重名（在宏定义检查之前会检查局部、全局变量；函数、typedef符号，结构、联合、枚举的tag；但不检查结构、联合的成员。） */
+e653       /* [MISRA Rules 43 and 48]运算精度丢失 */
+e661       /* 数组下标使用存在可能的写越界，并提示越界的范围 */
+e662       /* 数组下标使用存在可能的读越界,并提示越界的范围 */
+e665       /* 宏定义中未使用括号括起参数，而使用该宏时对该参数进行运算，可能引起优先级混乱 */
+e666       /* 有副作用的参数传递给有重复参数的宏，在使用的宏中,对参数进行重复操作，导致＋＋等操作被重复运算，值可能出错 */
+e668       /* 在函数调用中，存在传递了一个NULL指针给参数不能为NULL的库函数的情况（选项-function可对用户定义函数显示此信息） */
+e669       /* 数据超出范围；主要是几个数据转移（transfer）函数memcpy, strcpy, fgets等，指示的尺寸超出了目的参数buffer的尺寸（选项-function可对用户定义函数显示此信息） */
+e671       /* 在memcpy、memset、memmove等对内存操作的函数中，第三个参数的值可能变为负数，导致内存覆盖的严重后果。（选项-function or -sem 可对用户定义函数显示该信息） */
+e676       /* 数组下标变量运算可能为负值，这样导致数组下标越界，但对某些不确定地址的指针的负数下标不会告警 */
+e681       /* [MISRA Rule 52 ] 无法进入的循环语句，如for语句的条件不当是的循环体不能被执行 */
+e683       /* [Misra Rule 114] 使用宏定义了系统库函数 */
+e684       /* 函数中auto 变量的地址传递到调用者的空间。在函数返回后，所保存的地址已经无效，如果对之操作将引起故障 */
+e685       /* 存在关系表达式恒为FALSE或恒为TRUE的情况 */

+e701       /* [MISRA Rule 37 ] 有符号数据类型执行左移运算，导致符号丢失 */
+e702       /* [MISRA Rule 37 ] 有符号数据类型执行右移运算，导致符号丢失 */
+e718       /* [Misra Rule 20 ] 调用的函数没有声明，或者是调用处没有包含其头文件 */
+e720       /* [MISRA Rule 35 ] 对if、while等语句执行布尔测试，即除0和1以外的结果都认为不合法，主要防止将==误作= */
+e733       /* [MISRA Rule 106] 外部引用了自动变量的地址，存在超越其生命周期使用的危险 */
+e744       /* [MISRA Rule 62 ] switch语句没有default语句 */
+e745       /* [MISRA Rule 75 ] 函数没有显式的类型声明，默认将用int作为返回类型 */
+e746       /* [Misra Rule 20 ] 在函数声明前对其进行调用 */
+e747       /* [MISRA Rule 77 ] 参数类型定义与实际传入类型不符，需显式强制类型转换以消除本告警 */
+e760       /* 宏定义重复 */
+e762       /* 重复定义或重复外部声明函数或全局变量 */
+e764       /* [MISRA Rule 64] switch语句没有除default外的分支 */
//+e765       /* [Misra Rule 23] 未被外部引用的变量没有加static限定 */
+e771       /* [MISRA Rule 30] 局部变量不能肯定被初始化而使用，例如在程序的控制循环（while, for, or do）中赋值但是在控制循环之外又会使用。只有控制循环被执行了，才可能被初始化 */
+e772       /* 局部变量没有被确认一定会初始化。传递给函数的地址指针被期望为一个const类型 */
+e773       /* [MISRA Rule 96] 宏定义中表达式未使用括号，可能会引起优先级故障 */
+e775       /* 非负数类型的变量（比如指针类型）不可能小于0，而代码中做了小于0的判断 */
+e777       /* [MISRA Rule 50]对浮点类型数据类型用了不正确的比较操作，如==操作 */
+e789       /* [MISRA Rule 106] 静态变量引用了自动变量的地址，危险同733 */
+e794       /* [MISRA Rule 107] 指针有为NULL的可能性，但对它进行了操作 */

+e801       /* [MISRA Rule 56] 出现了goto语句 */
+e802       /* 向函数传入了为NULL的指针参数 */
+e806       /* [Misra Rule 112] 使用无符号数据类型进行bit域定义时，如struct { UINT32 ulSamp:2 } T_Samp;*/
+e820       /* [MISRA Rule 35] 对布尔表达式中括号内运算结果执行布尔测试，作用同e720 */
+e825       /* [MISRA Rule 61] case语句中缺少break，且没有使用严格的lint选项抑制，如//lint -fallthrough */
+e827       /* [MISRA Rule 52]不可执行到的循环 */

/*======================================*/
/* A类C++告警，必查项，不得修改         */
/*======================================*/
+e1511      /* [Effective C++ #37] 子类覆盖父类非虚函数 */
+e1534      /* [Effective C++ #26] 内联函数中有静态成员 */
+e1536      /* [Effective C++ #30] 返回私有成员的引用 */
+e1537      /* [Effective C++ #29] 函数返回数据成员的指针 */
+e1540      /* [Effective C++ #06] 析构函数释放指针成员内存后，没有把该成员置空 */
+e1544      /* [Effective C++ #47] 由初始化顺序不同引起的值的不确定性 */
+e1546      /* [Effective C++ #11] 在析构函数中抛出异常 */
+e1547      /* [Effective C++ #03] 把子类对象数组名赋值给基类指针 */
+e1551      /* [Effective C++ #11] 析构函数调用了能抛出异常的函数 */

+e1722      /* [Effective C++ #15] “=”操作符返回值不是类的引用 */
+e1729      /* [Effective C++ #13] 初始化列表顺序和成员变量声明顺序不一致 */
+e1732      /* [Effective C++ #11] 构造函数中用new分配了内存的类，没有重载=操作符 */
+e1733      /* [Effective C++ #11] 构造函数中用new分配了内存的类，没有重写拷贝构造函数 */
+e1735      /* [Effective C++ #38] 虚函数有默认参数 */
+e1737      /* [Effective C++ #09] 重载new操作符，但是没有把它作为类的成员函数 */
+e1739      /* [Effective C++ #19] 二元操作符作为成员函数重载 */
+e1740      /* [Effective C++ #06] 指针数据成员没有直接被析构函数释放和置空，而是通过析构调用其它函数完成的 */
+e1747      /* [Effective C++ #23] 二元操作符返回值为引用类型 */
+e1749      /* [Effective C++ #24] 菱形继承时基类没有被声明为虚 */
+e1753      /* [Effective C++ #07] 操作符“|| 、&& 和 ,”重载 */
+e1757      /* [Effective C++ #06] 使用后置“++、--操作符 */
+e1758      /* [Effective C++ #06] 前置--操作符返回非引用 */
+e1759      /* [Effective C++ #06] 后置--操作符返回引用 */

+e1930      /* [Effective C++ #05] 数据类型作为操作符重载 */
+e1934      /* [Effective C++ #19] 移位操作符被重载为类的成员函数 */

-elib(*)