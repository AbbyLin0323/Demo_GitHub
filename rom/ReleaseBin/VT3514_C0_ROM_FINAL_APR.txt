
ROM_C0_COSIM.elf:     file format elf32-xtensa-le


Disassembly of section .bss:

1ffa4800 <.bss_symbol_1429880325>:
1ffa4800:	00000000                                ....

1ffa4804 <l_pBootEntry>:
1ffa4804:	00000000                                ....

1ffa4808 <l_pMpRegSet_108>:
1ffa4808:	00000000                                ....

1ffa480c <l_ulRevMpInt>:
1ffa480c:	00000000                                ....

1ffa4810 <pNFCQDptr>:
1ffa4810:	00000000                                ....

1ffa4814 <gPageReadCmdIndex>:
1ffa4814:	00000000                                ....

1ffa4818 <pNFCQArray>:
1ffa4818:	00000000                                ....

1ffa481c <pPrcqArray>:
1ffa481c:	00000000                                ....

1ffa4820 <pNfcTrigger>:
1ffa4820:	00000000                                ....

1ffa4824 <pNfcQEEntry>:
1ffa4824:	00000000                                ....

1ffa4828 <l_ulMcuID_190>:
1ffa4828:	00000000                                ....

1ffa482c <l_pDsgReport_191>:
1ffa482c:	00000000                                ....

1ffa4830 <l_pEfuseFile>:
1ffa4830:	00000000                                ....

1ffa4834 <l_bSetHwFrEfuse>:
1ffa4834:	00000000                                ....

1ffa4838 <l_tStrapPin>:
1ffa4838:	00000000                                ....

1ffa483c <l_tSpiRomHead_207>:
	...

1ffa485c <l_ulCurrSpiMode_213>:
1ffa485c:	00000000                                ....

1ffa4860 <l_tTxPack_242>:
	...

1ffa4870 <l_tRxPack_243>:
	...

1ffa4880 <l_tMgr_244>:
	...

1ffa4890 <l_ucSig_263>:
	...

1ffa4891 <l_ucSig0_265>:
1ffa4891:	000000                                        ...

1ffa4894 <g_dbg_enable>:
1ffa4894:	00000000                                ....

1ffa4898 <ModuelEventParameter>:
1ffa4898:	00000000                                ....

1ffa489c <l_pSataDsgReport1_466>:
1ffa489c:	00000000                                ....

1ffa48a0 <l_pSataDsgReport2_467>:
1ffa48a0:	00000000                                ....

1ffa48a4 <g_pSataIdentifyData>:
1ffa48a4:	00000000                                ....

1ffa48a8 <g_ulEncounterError>:
1ffa48a8:	00000000                                ....

1ffa48ac <g_pCacheStatus>:
1ffa48ac:	00000000                                ....

1ffa48b0 <g_bFlagPIODataRec>:
1ffa48b0:	00000000                                ....

1ffa48b4 <g_ulBufferStartPhyId>:
1ffa48b4:	00000000                                ....

1ffa48b8 <g_CurrUsedReadDSGID>:
	...

1ffa48ba <g_CurrUsedWriteDSGID>:
	...

1ffa48bc <LocalHCMDFIFOHead>:
1ffa48bc:	00000000                                ....

1ffa48c0 <LocalHCMDFIFOTail>:
1ffa48c0:	00000000                                ....

1ffa48c4 <gCurHCMD>:
1ffa48c4:	00000000                                ....

1ffa48c8 <gpCurSubCmd>:
1ffa48c8:	00000000                                ....

1ffa48cc <gCurSubCmd>:
	...

1ffa48cd <ucSUBCMDId_605>:
1ffa48cd:	000000                                        ...

1ffa48d0 <gPIOInfoBlock>:
	...

1ffa48d8 <g_ucL1returnflag>:
1ffa48d8:	00000000                                ....

1ffa48dc <g_bSataFlagDipmEnabled>:
1ffa48dc:	00000000                                ....

1ffa48e0 <g_bMultipleDataOpen>:
1ffa48e0:	00000000                                ....

1ffa48e4 <sata_status>:
	...

1ffa48ec <pCurrHostCmd$3114..0_721>:
1ffa48ec:	00000000                                ....

1ffa48f0 <ulRemainSectorCount$3115..1_722>:
1ffa48f0:	00000000                                ....

1ffa48f4 <ucDRQBlkLen$3116..2_723>:
	...

1ffa48f5 <ucCurrDataFISLen$3117..3_724>:
	...

1ffa4900 <l_aRCMD_TABLE>:
	...

1ffa4920 <ModuleEvent>:
	...

1ffa4930 <HostCmdSlot>:
	...

1ffa4bb0 <LocalHCMDFIFO>:
	...

1ffa4c40 <gSubCmdEntry>:
	...

1ffa4f00 <HighPrioEntry>:
	...

1ffa5580 <LowPrioEntry>:
	...

Disassembly of section .ResetVector.text:

ffe00000 <_ResetVector>:
ffe00000:	000406        	j	ffe00014 <_ResetHandler>

ffe00003 <_ResetVector+0x3>:
	...

ffe00004 <_ResetVector+0x4>:
ffe00004:	00000000 ffe00800 00051044 ffe00800     ........D.......

ffe00014 <_ResetHandler>:
ffe00014:	000c      	movi.n	a0, 0
ffe00016:	13e400        	wsr.intenable	a0
ffe00019:	fffa21        	l32r	a2, ffe00004 <_ResetVector+0x4>
ffe0001c:	03eb30        	rsr.prid	a3
ffe0001f:	743030        	extui	a3, a3, 0, 8
ffe00022:	228c      	beqz.n	a2, ffe00028 <_ResetHandler+0x14>
ffe00024:	03cc      	bnez.n	a3, ffe00028 <_ResetHandler+0x14>
ffe00026:	0209      	s32i.n	a0, a2, 0

ffe00028 <_ResetHandler+0x14>:
ffe00028:	fff821        	l32r	a2, ffe00008 <_ResetVector+0x8>
ffe0002b:	13e720        	wsr.vecbase	a2
ffe0002e:	531c      	movi.n	a3, 21
ffe00030:	136330        	wsr.atomctl	a3
ffe00033:	006120        	rsil	a2, 1
ffe00036:	fff521        	l32r	a2, ffe0000c <_ResetVector+0xc>
ffe00039:	132820        	wsr.prefctl	a2

ffe0003c <unpackdone>:
ffe0003c:	fff531        	l32r	a3, ffe00010 <_ResetVector+0x10>
ffe0003f:	f03d      	nop.n
ffe00041:	0003c0        	callx0	a3

Disassembly of section .WindowVectors.text:

ffe00800 <_pre_start>:
ffe00800:	0568c5        	call0	ffe05e90 <_start>

Disassembly of section .Level2InterruptVector.literal:

ffe00978 <_memmap_seg_rom_level2_vec_lit_end-0x8>:
ffe00978:	ffe03c18                                .<..

Disassembly of section .Level2InterruptVector.text:

ffe00980 <_Level2Vector>:
ffe00980:	13d210        	wsr.excsave2	a1
ffe00983:	408040        	rotw	4
ffe00986:	61d210        	xsr.excsave2	a1
ffe00989:	0303f0        	rsr.sar	a15
ffe0098c:	fffb31        	l32r	a3, ffe00978 <_Level2InterruptVector_literal_start>
ffe0098f:	f03d      	nop.n
ffe00991:	0003c0        	callx0	a3
ffe00994:	1303f0        	wsr.sar	a15
ffe00997:	4080c0        	rotw	-4
ffe0099a:	003210        	rfi	2

Disassembly of section .Level3InterruptVector.literal:

ffe009b8 <_memmap_seg_rom_level3_vec_lit_end-0x8>:
ffe009b8:	ffe03e54                                T>..

Disassembly of section .Level3InterruptVector.text:

ffe009c0 <_Level3Vector>:
ffe009c0:	13d310        	wsr.excsave3	a1
ffe009c3:	408040        	rotw	4
ffe009c6:	61d310        	xsr.excsave3	a1
ffe009c9:	0303f0        	rsr.sar	a15
ffe009cc:	fffb31        	l32r	a3, ffe009b8 <_Level3InterruptVector_literal_start>
ffe009cf:	f03d      	nop.n
ffe009d1:	0003c0        	callx0	a3
ffe009d4:	1303f0        	wsr.sar	a15
ffe009d7:	4080c0        	rotw	-4
ffe009da:	003310        	rfi	3

Disassembly of section .Level4InterruptVector.literal:

ffe009f8 <_memmap_seg_rom_level4_vec_lit_end-0x8>:
ffe009f8:	ffe04100                                .A..

Disassembly of section .Level4InterruptVector.text:

ffe00a00 <_Level4Vector>:
ffe00a00:	13d410        	wsr.excsave4	a1
ffe00a03:	408040        	rotw	4
ffe00a06:	61d410        	xsr.excsave4	a1
ffe00a09:	0303f0        	rsr.sar	a15
ffe00a0c:	fffb31        	l32r	a3, ffe009f8 <_Level4InterruptVector_literal_start>
ffe00a0f:	f03d      	nop.n
ffe00a11:	0003c0        	callx0	a3
ffe00a14:	1303f0        	wsr.sar	a15
ffe00a17:	4080c0        	rotw	-4
ffe00a1a:	003410        	rfi	4

Disassembly of section .Level5InterruptVector.text:

ffe00a40 <_Level5Vector>:
ffe00a40:	004120        	break	1, 2

ffe00a43 <_Level5Vector+0x3>:
ffe00a43:	ffff06        	j	ffe00a43 <_Level5Vector+0x3>

Disassembly of section .DebugExceptionVector.text:

ffe00a80 <_DebugExceptionVector>:
ffe00a80:	13d620        	wsr.excsave6	a2
ffe00a83:	827c      	movi.n	a2, -8
ffe00a85:	005100        	simcall

ffe00a88 <_DebugExceptionVector+0x8>:
ffe00a88:	ffff06        	j	ffe00a88 <_DebugExceptionVector+0x8>

Disassembly of section .NMIExceptionVector.text:

ffe00ac0 <_NMIExceptionVector>:
ffe00ac0:	003710        	rfi	7

Disassembly of section .KernelExceptionVector.text:

ffe00b00 <_KernelExceptionVector>:
ffe00b00:	004100        	break	1, 0
ffe00b03:	fffe46        	j	ffe00b00 <_KernelExceptionVector>

Disassembly of section .UserExceptionVector.literal:

ffe00b38 <_memmap_seg_rom_user_vec_lit_end-0x8>:
ffe00b38:	ffe04104                                .A..

Disassembly of section .UserExceptionVector.text:

ffe00b40 <_UserExceptionVector>:
ffe00b40:	13d410        	wsr.excsave4	a1
ffe00b43:	408040        	rotw	4
ffe00b46:	61d410        	xsr.excsave4	a1
ffe00b49:	0303f0        	rsr.sar	a15
ffe00b4c:	fffb31        	l32r	a3, ffe00b38 <_UserExceptionVector_literal_start>
ffe00b4f:	f03d      	nop.n
ffe00b51:	0003c0        	callx0	a3
ffe00b54:	1303f0        	wsr.sar	a15
ffe00b57:	4080c0        	rotw	-4
ffe00b5a:	003000        	rfe

Disassembly of section .DoubleExceptionVector.literal:

ffe00b78 <_memmap_seg_rom_double_vec_lit_end-0x8>:
ffe00b78:	ffe80000                                ....

Disassembly of section .DoubleExceptionVector.text:

ffe00bc0 <_DoubleExceptionVector-0x10>:
ffe00bc0:	03e630        	rsr.ps	a3
ffe00bc3:	ffed61        	l32r	a6, ffe00b78 <_DoubleExceptionVector_literal_start>
ffe00bc6:	0639      	s32i.n	a3, a6, 0
ffe00bc8:	03e830        	rsr.exccause	a3
ffe00bcb:	1639      	s32i.n	a3, a6, 4

ffe00bcd <_DoubleExceptionVector-0x3>:
ffe00bcd:	000000                                        ...

ffe00bd0 <_DoubleExceptionVector>:
ffe00bd0:	004140        	break	1, 4
ffe00bd3:	fffe46        	j	ffe00bd0 <_DoubleExceptionVector>

Disassembly of section .rodata:

ffe00c00 <.rodata_symbol_1429880325-0x10>:
	...

ffe00c10 <.rodata_symbol_1429880325>:
ffe00c10:	1ff83a14                                .:..

ffe00c14 <l_aFlashId_179>:
ffe00c14:	fff00000                                ....

ffe00c18 <l_pEfuseRegSet>:
ffe00c18:	1ff83e80                                .>..

ffe00c1c <l_pSpiRegSet_211>:
ffe00c1c:	1ff800e0                                ....

ffe00c20 <l_pUartLcrReg_238>:
ffe00c20:	ffe0700c                                .p..

ffe00c24 <l_pUartLcrReg_238+0x4>:
	...

ffe00c30 <l_pNFBoot>:
ffe00c30:	ffe04abc ffe04314 ffe03828              .J...C..(8..

ffe00c3c <l_pNFBoot+0xc>:
ffe00c3c:	00000000                                ....

ffe00c40 <BootString>:
ffe00c40:	45534552 55502054 00000000                       RESET PU.

ffe00c49 <BootString+0x9>:
ffe00c49:	00000000 52000000                                .......

ffe00c50 <BootString+0x10>:
ffe00c50:	44414552 00444920                       READ ID.

ffe00c58 <BootString+0x18>:
	...

ffe00c60 <BootString+0x20>:
ffe00c60:	44414552 414c4620 00004853                       READ FLASH.

ffe00c6b <BootString+0x2b>:
ffe00c6b:	00000000 f8c92e00                                .....

ffe00c70 <l_aNfcInitTable>:
ffe00c70:	60f8c92e 41490bbc 44d16484 ffffffff     ...`..IA.d.D....
ffe00c80:	38000000 2b2b2b2b 0a50af00 00000090     ...8++++..P.....
ffe00c90:	00000002 60f8c92e 014c810d 0110e49c     .......`..L.....
ffe00ca0:	00000000 23000055 00000000 d0d08900     ....U..#........
ffe00cb0:	00000050 00000002 60f8c94e 41490bbc     P.......N..`..IA
ffe00cc0:	44d16484 ffffffff 38000000 2b2b2b2b     .d.D.......8++++
ffe00cd0:	0a50af00 00000090 00000003 60f8c94e     ..P.........N..`
ffe00ce0:	014c8125 0110e49c 00000000 23000055     %.L.........U..#
ffe00cf0:	00000000 d0d08900 00000050 00000003     ........P.......
ffe00d00:	61f8c92e 014c8124 01d0e49c 00000000     ...a$.L.........
ffe00d10:	23000055 ffffffff d0d08900 00000050     U..#........P...
ffe00d20:	00000002 6198cb2e 014c810d 0110e49c     .......a..L.....
ffe00d30:	00000000 23000055 00000000 d0d08900     ....U..#........
ffe00d40:	00000050 00000002 61f8c94e 014c8124     P.......N..a$.L.
ffe00d50:	01d0e49c 00000000 23000055 ffffffff     ........U..#....
ffe00d60:	d0508900 00000050 00000003 61f8c94e     ..P.P.......N..a
ffe00d70:	014c8125 0110e49c 00000000 23000055     %.L.........U..#
ffe00d80:	00000000 d0d08900 00000050 00000003     ........P.......

ffe00d90 <aRCMD_TABLE>:
ffe00d90:	00060300 ffffffff 00060401 ffffffff     ................
ffe00da0:	00020602 ffffffff 00020703 ffffffff     ................

ffe00db0 <l_aQETable>:
ffe00db0:	04ffc002 20ff8040 a005c070 70200fff     ....@.. p..... p
ffe00dc0:	ffa005c0                                ....

ffe00dc4 <l_aQETable+0x14>:
	...

ffe00dd0 <g_aCQE1E>:
ffe00dd0:	faffeeef 60300090 853f31d0 a2d5d4fc     ......0`.1?.....

ffe00de0 <g_aCQE2E>:
ffe00de0:	10803000 d0601181 10811180 e006e005     .0....`.........
ffe00df0:	15803060 31003200 3060ffff ffffffff     `0...2.1..`0....

ffe00e00 <g_aSQEE>:
ffe00e00:	2e703e70 0e701e70 7e70be70 3e783e70     p>p.p.p.p.p~p>x>

ffe00e10 <ReadDataOut>:
ffe00e10:	ffa005c0                                ....

ffe00e14 <ReadDataOut+0x4>:
ffe00e14:	00000000                                ....

ffe00e18 <l_aSetSpiMode_224>:
ffe00e18:	ffe03664 ffe036ac                       d6...6..

ffe00e20 <l_aRCmdTable_225>:
ffe00e20:	000003                                        ...

ffe00e23 <l_aRCmdTable_225+0x3>:
	...

ffe00e24 <l_aRCmdTable_225+0x4>:
ffe00e24:	02123b                                        ;..

ffe00e27 <l_aRCmdTable_225+0x7>:
	...

ffe00e28 <l_aRCmdTable_225+0x8>:
ffe00e28:	01350b                                        .5.

ffe00e2b <l_aRCmdTable_225+0xb>:
	...

ffe00e40 <l_aSetAddrMode_226>:
ffe00e40:	ffe035e4 ffe03620                       .5.. 6..

ffe00e48 <l_aSetAddrMode_226+0x8>:
	...

ffe00e50 <l_aWCmdTable_228>:
ffe00e50:	0002                                        ..

ffe00e52 <l_aWCmdTable_228+0x2>:
	...

ffe00e54 <l_aWCmdTable_228+0x4>:
ffe00e54:	3502                                        .5

ffe00e56 <l_aWCmdTable_228+0x6>:
	...

ffe00e60 <mc_250>:
ffe00e60:	33323130 37363534 62613938 66656463     0123456789abcdef
	...

ffe00e71 <mc_250+0x11>:
	...

ffe00e80 <l_aUartPreProcCmdState_269>:
ffe00e80:	00000004 00000005 00000006 00000001     ................
ffe00e90:	00000002 0000000b 0000000c              ............

ffe00e9c <l_aUartPreProcCmdState_269+0x1c>:
ffe00e9c:	00000000                                ....

ffe00ea0 <l_aUartFunc_281>:
ffe00ea0:	ffe03504 ffe034b8 ffe035b0 ffe03360     .5...4...5..`3..
ffe00eb0:	ffe032f0 ffe032a4 ffe03330 ffe03278     .2...2..03..x2..
ffe00ec0:	ffe0326c ffe035d4 ffe03398 ffe03250     l2...5...3..P2..
ffe00ed0:	ffe03220                                 2..

ffe00ed4 <l_aUartFunc_281+0x34>:
	...

ffe00ee0 <aReadableReg>:
ffe00ee0:	00100000 00100004 00100008 00100010     ................
ffe00ef0:	00100014 00100018 0010001c 00100020     ............ ...
ffe00f00:	00100024 00100040 00100044 00100048     $...@...D...H...
ffe00f10:	0010004c 00100050 00100054 00100060     L...P...T...`...
ffe00f20:	00100064 00100068                       d...h...

ffe00f28 <aReadableReg+0x48>:
	...

ffe00f30 <Default_Idfy_Data>:
ffe00f30:	00080000 0002c837 00000000 00000010     ....7...........
ffe00f40:	00000000 30373030 30303434 20203031     ....0070440010  
ffe00f50:	20202020 20202020 00000000 56650000             ......eV
ffe00f60:	3030722e 56543031 31303637 4d504130     .r0010TV76010APM
ffe00f70:	414d5452 534b4449 20202020 20202020     RTMAIDKS        
ffe00f80:	20202020 20202020 20202020 80102020                   ..
ffe00f90:	2f000000 00004000 00060000 00020008     .../.@..........
ffe00fa0:	01000010 01100000 00000200 00070000     ................
ffe00fb0:	00780003 00780078 00000078 00000000     ..x.x.x.x.......
	...
ffe00fc8:	00000006 00000000 011003fe 50000028     ............(..P
ffe00fd8:	00284100 41001000 0000007f 00000000     .A(....A........
	...
ffe01008:	cca35000 150a05cf 00000000 00000000     .P..............
	...
ffe01080:	00000003 00000000 00000000 00000000     ................
	...
ffe010e0:	00010000 00000000 00000000 0051103f     ............?.Q.
	...
ffe0112c:	00a50000 545f314c 536b7361 49617461     ....L1_TaskSataI
ffe0113c:	4870204f 2d444d43 4363753e 5752646d     O pHCMD->ucCmdRW
ffe0114c:	20642520 4f525245 0a212152 00000000      %d ERROR!!.....
ffe0115c:	545f314c 536b7361 49617461 5250204f     L1_TaskSataIO PR
ffe0116c:	52452044 21524f52 00000a21 535f314c     D ERROR!!...L1_S
ffe0117c:	48617461 6c646e61 4f495065 61746144     ataHandlePIOData
ffe0118c:	746f7250 6c6f636f 61745320 45206574     Protocol State E
ffe0119c:	524f5252 000a2121 53705f67 49617461     RROR!!..g_pSataI
ffe011ac:	746e6564 44796669 5b617461 5d353532     dentifyData[255]
ffe011bc:	30203d20 0a782578 00000000 6e656449      = 0x%x.....Iden
ffe011cc:	79666974 61746144 63656843 6d75536b     tifyDataCheckSum
ffe011dc:	214b4f20 00000a21 6e656449 79666974      OK!!...Identify
ffe011ec:	61746144 63656843 6d75536b 6c752820     DataCheckSum (ul
ffe011fc:	206d7553 78302026 20294646 6425203d     Sum & 0xFF) = %d
ffe0120c:	52524520 2121524f 0000000a 53705f67      ERROR!!....g_pS
ffe0121c:	49617461 746e6564 44796669 3a617461     ataIdentifyData:
ffe0122c:	25783020 00000a78 7465735b 61656620      0x%x...[set fea
ffe0123c:	65727574 203a5d73 62616e65 7720656c     tures]: enable w
ffe0124c:	65746972 63616320 0a2e6568 00000000     rite cache......
ffe0125c:	7465735b 61656620 65727574 203a5d73     [set features]: 
ffe0126c:	61736964 20656c62 74697277 61632065     disable write ca
ffe0127c:	2e656863 0000000a 7465735b 61656620     che.....[set fea
ffe0128c:	65727574 203a5d73 20746573 6e617274     tures]: set tran
ffe0129c:	72656673 646f6d20 6f742065 25783020     sfer mode to 0x%
ffe012ac:	000a2e78 7465735b 61656620 65727574     x...[set feature
ffe012bc:	203a5d73 67726174 6d207465 2065646f     s]: target mode 
ffe012cc:	78257830 20736920 20746f6e 70707573     0x%x is not supp
ffe012dc:	2e74726f 0000000a 7465735b 61656620     ort.....[set fea
ffe012ec:	65727574 203a5d73 62616e65 7320656c     tures]: enable s
ffe012fc:	20617461 74616566 73657275 25783020     ata features 0x%
ffe0130c:	000a2e78 7465735b 61656620 65727574     x...[set feature
ffe0131c:	203a5d73 61736964 20656c62 61746173     s]: disable sata
ffe0132c:	61656620 65727574 78302073 0a2e7825      features 0x%x..
ffe0133c:	00000000 7465735b 61656620 65727574     ....[set feature
ffe0134c:	203a5d73 61766e69 2064696c 74616566     s]: invalid feat
ffe0135c:	20657275 65646f63 25783020 000a2e78     ure code 0x%x...
ffe0136c:	535f314c 43617461 7845646d 74756365     L1_SataCmdExecut
ffe0137c:	76654465 44656369 6e676169 6974736f     eDeviceDiagnosti
ffe0138c:	6e652063 00000a64 535f314c 48617461     c end...L1_SataH
ffe0139c:	6c646e61 65705365 6c616963 444f4950     andleSpecialPIOD
ffe013ac:	49617461 6e49206e 20747570 4f525245     ataIn Input ERRO
ffe013bc:	000a2152 535f314c 48617461 6c646e61     R!..L1_SataHandl
ffe013cc:	65705365 6c616963 444f4950 49617461     eSpecialPIODataI
ffe013dc:	6f4e206e 65726620 65522065 52506461     n No free ReadPR
ffe013ec:	52452044 21524f52 0000000a 6e6e7572     D ERROR!....runn
ffe013fc:	5f676e69 72646461 30203d20 0a782578     ing_addr = 0x%x.
ffe0140c:	00000000 7461735b 765f7061 65725f64     ....[satap_vd_re
ffe0141c:	735f6461 75746174 000a5d73 6e65765b     ad_status]..[ven
ffe0142c:	5d646d63 6576203a 646d636e 646f6320     cmd]: vencmd cod
ffe0143c:	203d2065 78257830 000a202e 6e65765b     e = 0x%x. ..[ven
ffe0144c:	5d646d63 6e69203a 696c6176 65662064     cmd]: invalid fe
ffe0145c:	72757461 78302065 0a2e7825 00000000     ature 0x%x......
ffe0146c:	646d4348 65707954 4e4f4e20 41544144     HCmdType NONDATA
ffe0147c:	43706720 75537275 646d4362 203d2120      gpCurSubCmd != 
ffe0148c:	4c4c554e 52524520 2121524f 0000000a     NULL ERROR!!....
ffe0149c:	746f6f62 20707520 21206b6f 0000000a     boot up ok !....
ffe014ac:	65746e45 61732072 6d206174 2e2e2e70     Enter sata mp...
ffe014bc:	0000000a 65746e45 45522072 4c435943     ....Enter RECYCL
ffe014cc:	00000a45 65746e45 52572072 0a455449     E...Enter WRITE.
ffe014dc:	00000000 65746e45 45522072 000a4441     ....Enter READ..
ffe014ec:	65746e45 554a2072 000a504d 65746e45     Enter JUMP..Ente
ffe014fc:	72502072 72502065 000a636f 20657250     r Pre Proc..Pre 
ffe0150c:	636f7250 55203a20 4f4e4b4e 00000a57     Proc : UNKNOW...
ffe0151c:	00007825 65746e45 58542072 0000000a     %x..Enter TX....
ffe0152c:	503a5852 50204552 0a434f52 00000000     RX:PRE PROC.....
ffe0153c:	453a5852 524f5252 0000000a 523a5852     RX:ERROR....RX:R
ffe0154c:	00000a58 53414c46 4f422048 0a3a544f     X...FLASH BOOT:.
ffe0155c:	00000000 20474953 524f5744 3a302044     ....SIG DWORD 0:
ffe0156c:	78257830 58452c20 303a2050 0a782578     0x%x ,EXP :0x%x.
ffe0157c:	00000000 20474953 524f5744 3a312044     ....SIG DWORD 1:
ffe0158c:	78257830 58452c20 303a2050 0a782578     0x%x ,EXP :0x%x.
ffe0159c:	00000000 45494350 20504d20 42414e45     ....PCIE MP ENAB
ffe015ac:	2e44454c 0000000a 54534554 4e554620     LED.....TEST FUN
ffe015bc:	4f495443 4552204e 45525554 00000a20     CTION RETURE ...
ffe015cc:	23205550 52206425 20646165 203a4449     PU #%d Read ID: 
ffe015dc:	25207825 000a2078 414c4544 554f4359     %x %x ..DELAYCOU
ffe015ec:	7320544e 69747465 6520676e 726f7272     NT setting error
ffe015fc:	00000a21 73277449 61727420 676e6963     !...It's tracing
ffe0160c:	776f6e20 0000000a 616c6544 756f4379      now....DelayCou
ffe0161c:	6220746e 6f772079 69206472 6f742073     nt by word is to
ffe0162c:	616c206f 00656772 616c6544 756f4379     o large.DelayCou
ffe0163c:	6220746e 6e692079 75727473 6f697463     nt by instructio
ffe0164c:	7369206e 6f6f7420 72616c20 00006567     n is too large..
ffe0165c:	616c6544 756f4379 7020746e 65637265     DelayCount perce
ffe0166c:	6920746e 6f742073 616c206f 00656772     nt is too large.
ffe0167c:	78617274 64646120 73692072 74756f20     trax addr is out
ffe0168c:	20666f20 676e6172 00000a65 78617274      of range...trax
ffe0169c:	7a697320 65732065 6e697474 72652067      size setting er
ffe016ac:	0a726f72 00000000 78617254 20736920     ror.....Trax is 
ffe016bc:	79737562 6163202c 2074276e 20746573     busy, can't set 
ffe016cc:	206d6172 6e756f62 79726164 00000a21     ram boundary!...
ffe016dc:	63617274 6f622065 61646e75 73207972     trace boundary s
ffe016ec:	69747465 6620676e 216c6961 0000000a     etting fail!....
ffe016fc:	78617254 6d615220 7a695320 72652065     Trax Ram Size er
ffe0170c:	0a726f72 00000000 2043464e 65707974     ror.....NFC type
ffe0171c:	20736920 002c6425 20732520 00000000      is %d,. %s ....
ffe0172c:	4e595341 00000043 434e5953 00000000     ASYNC...SYNC....
ffe0173c:	49464e4f 00000000 47474f54 0000454c     ONFI....TOGGLE..
ffe0174c:	20732520 0000000a 00434c54 00434c4d      %s ....TLC.MLC.
ffe0175c:	2043464e 3a203030 25783020 2d2d2078     NFC 00 : 0x%x --
ffe0176c:	25783020 00000a78 2043464e 3a203430      0x%x...NFC 04 :
ffe0177c:	25783020 2d2d2078 25783020 00000a78      0x%x -- 0x%x...
ffe0178c:	2043464e 3a203830 25783020 2d2d2078     NFC 08 : 0x%x --
ffe0179c:	25783020 00000a78 2043464e 3a206332      0x%x...NFC 2c :
ffe017ac:	25783020 2d2d2078 25783020 00000a78      0x%x -- 0x%x...
ffe017bc:	2043464e 3a203033 25783020 2d2d2078     NFC 30 : 0x%x --
ffe017cc:	25783020 00000a78 2043464e 3a203038      0x%x...NFC 80 :
ffe017dc:	25783020 2d2d2078 25783020 00000a78      0x%x -- 0x%x...
ffe017ec:	2043464e 3a203838 25783020 2d2d2078     NFC 88 : 0x%x --
ffe017fc:	25783020 00000a78 20554d50 3a203032      0x%x...PMU 20 :
ffe0180c:	25783020 2d2d2078 25783020 00000a78      0x%x -- 0x%x...
ffe0181c:	5f4c4148 45414d44 4d6c6553 203a5543     HAL_DMAESelMCU: 
ffe0182c:	20746567 2055434d 25204449 72652064     get MCU ID %d er
ffe0183c:	00726f72 5f4c4148 45414d44 43746547     ror.HAL_DMAEGetC
ffe0184c:	654c646d 4c203a6e 74676e65 73692068     mdLen: Length is
ffe0185c:	746f6e20 76696420 62697369 6220656c      not divisible b
ffe0186c:	36312079 7479622d 65202c65 726f7272     y 16-byte, error
ffe0187c:	00000a21 25205550 73252064 69616620     !...PU %d %s fai
ffe0188c:	0a64656c 00000000 73616c46 6f422068     led.....Flash Bo
ffe0189c:	7320746f 65636375 75667373 20796c6c     ot successfully 
ffe018ac:	6f62202c 6520746f 7972746e 20736920     , boot entry is 
ffe018bc:	78257830 0000000a 35335456 43203431     0x%x....VT3514 C
ffe018cc:	4f522030 4f42204d 5020544f 45434f52     0 ROM BOOT PROCE
ffe018dc:	4e495353 2e2e2047 00000a2e 54524155     SSING ......UART
ffe018ec:	616e6520 64656c62 0000000a 20544547      enabled....GET 
ffe018fc:	746f6f62 64616f6c 73207265 2e636375     bootloader succ.
ffe0190c:	0000000a 20455845 52544e45 73692059     ....EXE ENTRY is
ffe0191c:	25783020 000a2e78 206d6152 6e756f42      0x%x...Ram Boun
ffe0192c:	79726164 61745320 30207472 3b782578     dary Start 0x%x;
ffe0193c:	646e4520 25783020 00000a78 74736f50      End 0x%x...Post
ffe0194c:	657a6953 6c654420 6f437961 20746e75     Size DelayCount 
ffe0195c:	78257830 6375203b 74696e55 65707954     0x%x; ucUnitType
ffe0196c:	25783020 00000a78 1ffa4800 1ffa5c00      0x%x....H...\..

Disassembly of section .literal:

ffe0197c <.literal>:
ffe0197c:	1ff80880 1ff80780 1ffa4800 00100000     .........H......
ffe0198c:	ffefffff 0000ffff 7fffffff fffff7ff     ................
ffe0199c:	00000800 1ff84000 ffe01178 ffbfffff     .....@..x.......
ffe019ac:	bfffffff fffdffff 20000000 ff7fffff     ........... ....
ffe019bc:	fffeffff 00008000 f0ffffff dfffffff     ................
ffe019cc:	ffc3ffff efffffff 00800000 0000ff00     ................
ffe019dc:	1ff81a00 1ff81980 ffe01130 ffe0115c     ........0...\...
ffe019ec:	ffe01340 ffe01428 ffe01448 ffe0136c     @...(...H...l...
ffe019fc:	ffe01218 ffe011a4 ffe011c8 ffe011e4     ................
ffe01a0c:	3fffffff ffe01394 ffe013c0 40000000     ...?...........@
ffe01a1c:	80000000 e0ffffff 007fffff 1ff80600     ................
ffe01a2c:	ffe01234 ffe01310 ffe013f8 ffe01284     4...............
ffe01a3c:	0000f8ff ffe012b0 ffe012e4 ffe0125c     ............\...
ffe01a4c:	0000ffdf ffe01410 000080ff 0000fff7     ................
ffe01a5c:	0000fffb 0000fffd 0000ffef 1ffa48c4     .............H..
ffe01a6c:	fff04000 ffe00f30 1ff83b3c 1ff83a00     .@..0...<;...:..
ffe01a7c:	1ff81e00 1ff83b40 02e30000 1ff80200     ....@;..........
ffe01a8c:	ffe0146c fff04604 fff04800 44218000     l....F...H....!D
ffe01a9c:	fff04c00 40218000 05000000 1ff7fe00     .L....!@........
ffe01aac:	ffe014ac ffe0149c ffe014c0 ffe014d0     ................
ffe01abc:	ffe014e0 ffe014ec ffe014f8 ffe01508     ................
ffe01acc:	ffe00c10 ffe0151c ffe06e00 34313533     .........n..3514
ffe01adc:	ffe01520 ffe0153c ffe01548 ffe06f80      ...<...H....o..
ffe01aec:	ffe0152c 08000000 1ffa4860 0fffffff     ,.......`H......
ffe01afc:	f7ffffff ff3fffff ffcfffff 00c00000     ......?.........
ffe01b0c:	00200000 ffeffe00 35335456 30433431     .. .....VT3514C0
ffe01b1c:	ffe01550 ffe01560 ffe01580 00006000     P...`........`..
ffe01b2c:	1ff88000 1ff81000 1ff7ff00 04000000     ................
ffe01b3c:	1ff833a0 1ff82200 00010000 00004000     .3...".......@..
ffe01b4c:	1ff83600 10000000 ffe015a0 1ff83200     .6...........2..
ffe01b5c:	ffffbfff 1ff80700 1ff80a00 800000c0     ................
ffe01b6c:	00008880 18000000 fffff0ff 00020000     ................
ffe01b7c:	1ffa4930 00001000 00002000 fff00000     0I....... ......
ffe01b8c:	ffe015b4 ffe00c00 1ffa4884 ffe00d90     .........H......
ffe01b9c:	ffe015cc 1ff80e00 00ffffff ffe015e4     ................
ffe01bac:	0010001c 00100020 00100024 ffffe000     .... ...$.......
ffe01bbc:	00100008 00100004 ffe01600 03ffffff     ................
ffe01bcc:	ffe01614 ffe0165c ffe01634 ffff8fff     ....\...4.......
ffe01bdc:	00005000 00003000 ffe0167c ffe01698     .P...0..|.......
ffe01bec:	ffe016b4 ffe016dc ffe016fc ffe01714     ................
ffe01bfc:	ffe01734 ffe0172c ffe01724 ffe0173c     4...,...$...<...
ffe01c0c:	ffe01758 ffe0174c 03000000 ffe0175c     X...L.......\...
ffe01c1c:	ffe01774 ffe0178c ffe017a4 ffe017bc     t...............
ffe01c2c:	ffe017d4 ffe017ec ffe01804 ffe01744     ............D...
ffe01c3c:	ffe01754 1ff83b8c 1ff83b38 1ff83b34     T....;..8;..4;..
ffe01c4c:	ffe00d50 1ff81d28 1ff7ffff 1ff81b2c     P...(.......,...
ffe01c5c:	ffe01840 ffe0181c ffff0fff fff0ffff     @...............
ffe01c6c:	ffe00de0 00002710 07000000 0a000000     .....'..........
ffe01c7c:	01000000 ffe01880 fff00008 ffe01894     ................
ffe01c8c:	1ff83e80 1ff83e00 1ff81100 1ff8a000     .>...>..........
ffe01c9c:	1ff8c000 1ff83f00 1ff81300 00061a80     .....?..........
ffe01cac:	1ff81088 003fffff 1ff81004 1ff81008     ......?.........
ffe01cbc:	0001ffff 0007ffff 01ffffff 1ff81080     ................
ffe01ccc:	1ff83e10 1ff83b80 1ff83880 1ff80000     .>...;...8......
ffe01cdc:	1ffa4870 1ffa4880 01200000 ffe018c4     pH...H.... .....
ffe01cec:	ffe018e8 ffe01924 ffe01948 00030000     ....$...H.......
ffe01cfc:	0c6c0000 00e60023 0157003f 44000055     ..l.#...?.W.U..D
ffe01d0c:	0f80e808 f550c5fa a550faaa a050ffff     ......P...P...P.
ffe01d1c:	44335544 44334444 44333344 02000000     DU3DDD3DD33D....
ffe01d2c:	3ffffe00 1ff80068 06000000 ffff3fff     ...?h........?..
ffe01d3c:	00001f40 ffe00dd0 ffe00da0 c0000000     @...............
ffe01d4c:	1ffa483c 00003514 ffe018f8 ffe01910     <H...5..........
ffe01d5c:	ffe03a50 ffe031e0                       P:...1..

ffe01d64 <.literal+0x3e8>:
ffe01d64:	1ffa4800                                .H..

Disassembly of section .text:

ffe01d68 <HAL_SataConstructAndSendPIOSetupFIS>:
    const BOOL bLastDRQ,
    const U8 ucDRQLen,
    const U8 ucProtocol )
{
    /* 1. Enable firmware programming for shadow register block. */
    Lock_ShadowRegister();
ffe01d68:	860c      	movi.n	a6, 8
void HAL_SataConstructAndSendPIOSetupFIS (
    const BOOL bFirstDRQ,
    const BOOL bLastDRQ,
    const U8 ucDRQLen,
    const U8 ucProtocol )
{
ffe01d6a:	d0afa2        	movi	a10, -48
ffe01d6d:	f0c112        	addi	a1, a1, -16
ffe01d70:	0109      	s32i.n	a0, a1, 0
ffe01d72:	0b0c      	movi.n	a11, 0
ffe01d74:	ff0391        	l32r	a9, ffe01980 <_bss_table_end+0x4>
ffe01d77:	ff0101        	l32r	a0, ffe0197c <_bss_table_end>
    /* 1. Enable firmware programming for shadow register block. */
    Lock_ShadowRegister();
ffe01d7a:	0020c0        	memw
ffe01d7d:	8f0982        	l8ui	a8, a9, 143
ffe01d80:	208860        	or	a8, a8, a6
ffe01d83:	0020c0        	memw
ffe01d86:	8f4982        	s8i	a8, a9, 143

    /* 2. Status when data is ready shall has BUSY = 0, DRDY = 1, DRQ = 1 and ERR = 0.
    Error shall never be reported by a PIO Setup FIS. */
    rSDC_COMMAND_STATUS = 0x58;
ffe01d89:	875c      	movi.n	a7, 88
ffe01d8b:	0020c0        	memw
ffe01d8e:	0b4072        	s8i	a7, a0, 11
    rSDC_FEATURE_ERROR = 0;
ffe01d91:	0020c0        	memw
ffe01d94:	0540b2        	s8i	a11, a0, 5

    /* 3. Program transfer length field in the PIO Setup FIS. */
    rSDC_PIOXferCountLow =  (U8)(ucDRQLen << SEC_SZ_BITS);
ffe01d97:	0020c0        	memw
ffe01d9a:	1940b2        	s8i	a11, a0, 25
    rSDC_PIOXferCountHigh = (U8)(ucDRQLen << (SEC_SZ_BITS - 8));
ffe01d9d:	1164f0        	slli	a6, a4, 1
ffe01da0:	0020c0        	memw
ffe01da3:	1a4062        	s8i	a6, a0, 26

    /* 4. Decide the ending status and interrupt request/data direction according to IN/OUT protocol and first/last flag. */
    if ( HCMD_READ == ucProtocol ) {
ffe01da6:	151566        	bnei	a5, 1, ffe01dbf <HAL_SataConstructAndSendPIOSetupFIS+0x57>
        /* Interrupt bit and direction bit are always required for a read command. */
        rSDC_FISDirInt = BIT_SDC_FIS_DIRFLAG | BIT_SDC_FIS_INTFLAG;
ffe01da9:	370c      	movi.n	a7, 3
ffe01dab:	0020c0        	memw
ffe01dae:	2b4072        	s8i	a7, a0, 43

        if ( TRUE == bLastDRQ )
ffe01db1:	4e1366        	bnei	a3, 1, ffe01e03 <HAL_SataConstructAndSendPIOSetupFIS+0x9b>
            /* If last data block is ready, busy shall be cleared after data transfer according to PIO data in protocol. */
            rSDC_END_STATUS = 0x50;
ffe01db4:	085c      	movi.n	a8, 80
ffe01db6:	0020c0        	memw
ffe01db9:	174082        	s8i	a8, a0, 23
ffe01dbc:	000646        	j	ffe01dd9 <HAL_SataConstructAndSendPIOSetupFIS+0x71>

ffe01dbf <HAL_SataConstructAndSendPIOSetupFIS+0x57>:
    }

    else {
        /* Busy shall always be set after one data block transfer in a write command
        because device needs to flush data into its media. */
        rSDC_END_STATUS = 0xD0;
ffe01dbf:	0020c0        	memw
ffe01dc2:	1740a2        	s8i	a10, a0, 23

        if ( TRUE == bFirstDRQ )
ffe01dc5:	081266        	bnei	a2, 1, ffe01dd1 <HAL_SataConstructAndSendPIOSetupFIS+0x69>
            /* There is no need for device to interrupt host when it gets ready for receiving the first data block. */
            rSDC_FISDirInt = 0;
ffe01dc8:	0020c0        	memw
ffe01dcb:	2b40b2        	s8i	a11, a0, 43
ffe01dce:	0001c6        	j	ffe01dd9 <HAL_SataConstructAndSendPIOSetupFIS+0x71>

ffe01dd1 <HAL_SataConstructAndSendPIOSetupFIS+0x69>:

        else
            /* In subsequent data transfer, getting ready for receiving a data block
            also means the previous data block has been written into media. So host needs to be notified. */
            rSDC_FISDirInt = BIT_SDC_FIS_INTFLAG;
ffe01dd1:	290c      	movi.n	a9, 2
ffe01dd3:	0020c0        	memw
ffe01dd6:	2b4092        	s8i	a9, a0, 43
Modify History:
20090528    Yao Chen    001: first created
===================================================================*/
void HAL_SataSendPIOSetupFIS(void)
{
    rSDC_IOControl = BIT_SDC_IOCTRL_SENDPIOSETUP_FIS;
ffe01dd9:	0a4c      	movi.n	a10, 64
ffe01ddb:	0020c0        	memw
ffe01dde:	2c40a2        	s8i	a10, a0, 44

    /* 5. Trigger TP layer to send out the PIO Setup FIS. */
    HAL_SataSendPIOSetupFIS();

    /* 6. Check the transfer status and disable firmware programming for shadow register block. */
    while ( FALSE == HAL_SataIsFISXferAvailable() );
ffe01de1:	01e385        	call0	ffe03c1c <HAL_SataIsFISXferAvailable>
ffe01de4:	ff9216        	beqz	a2, ffe01de1 <HAL_SataConstructAndSendPIOSetupFIS+0x79>
    UnLock_ShadowRegister();
ffe01de7:	f7a022        	movi	a2, 247
ffe01dea:	0020c0        	memw
ffe01ded:	fee401        	l32r	a0, ffe01980 <_bss_table_end+0x4>
ffe01df0:	8f00b2        	l8ui	a11, a0, 143
ffe01df3:	10bb20        	and	a11, a11, a2
ffe01df6:	0020c0        	memw
ffe01df9:	8f40b2        	s8i	a11, a0, 143

    return;
ffe01dfc:	0108      	l32i.n	a0, a1, 0
ffe01dfe:	10c112        	addi	a1, a1, 16
ffe01e01:	f00d      	ret.n

ffe01e03 <HAL_SataConstructAndSendPIOSetupFIS+0x9b>:
            /* If last data block is ready, busy shall be cleared after data transfer according to PIO data in protocol. */
            rSDC_END_STATUS = 0x50;

        else
            /* Busy shall be set after data transfer if all data blocks are not finished according to PIO data in protocol. */
            rSDC_END_STATUS = 0xD0;
ffe01e03:	0020c0        	memw
ffe01e06:	1740a2        	s8i	a10, a0, 23
ffe01e09:	fff306        	j	ffe01dd9 <HAL_SataConstructAndSendPIOSetupFIS+0x71>

ffe01e0c <L1_GetDRQBlkLen>:
U8 L1_GetDRQBlkLen(U8 ucHCmdCode)
{
    U8 ucDRQBlkLen;
    
    /* Decide the DRQ block length according to command code. */
    switch (ucHCmdCode)
ffe01e0c:	19c226        	beqi	a2, 32, ffe01e29 <L1_GetDRQBlkLen+0x1d>
ffe01e0f:	432c      	movi.n	a3, 36
ffe01e11:	141237        	beq	a2, a3, ffe01e29 <L1_GetDRQBlkLen+0x1d>
ffe01e14:	043c      	movi.n	a4, 48
ffe01e16:	0f1247        	beq	a2, a4, ffe01e29 <L1_GetDRQBlkLen+0x1d>
ffe01e19:	453c      	movi.n	a5, 52
ffe01e1b:	0a1257        	beq	a2, a5, ffe01e29 <L1_GetDRQBlkLen+0x1d>
            ucDRQBlkLen = 1;
            break;

        /* Multiple based command. */
        default:
            ucDRQBlkLen = (U8)g_pSataIdentifyData[59];
ffe01e1e:	fed921        	l32r	a2, ffe01984 <_bss_table_end+0x8>
ffe01e21:	292222        	l32i	a2, a2, 164
ffe01e24:	760222        	l8ui	a2, a2, 118
            break;
    }

    return ucDRQBlkLen;
ffe01e27:	f00d      	ret.n

ffe01e29 <L1_GetDRQBlkLen+0x1d>:
        /* Sector based command. */
        case ATA_CMD_READ_SECTOR:
        case ATA_CMD_WRITE_SECTOR:
        case ATA_CMD_READ_SECTOR_EXT:
        case ATA_CMD_WRITE_SECTOR_EXT:
            ucDRQBlkLen = 1;
ffe01e29:	120c      	movi.n	a2, 1
        default:
            ucDRQBlkLen = (U8)g_pSataIdentifyData[59];
            break;
    }

    return ucDRQBlkLen;
ffe01e2b:	f00d      	ret.n

ffe01e2d <L1_GetDRQBlkLen+0x21>:
ffe01e2d:	000000                                        ...

ffe01e30 <HAL_SataSendSuccessStatus>:
Description :
Others      :
Modify      :
****************************************************************************/
void HAL_SataSendSuccessStatus(void)
{
ffe01e30:	f0c112        	addi	a1, a1, -16
ffe01e33:	0109      	s32i.n	a0, a1, 0
    Lock_ShadowRegister();
ffe01e35:	890c      	movi.n	a9, 8
Description :
Others      :
Modify      :
****************************************************************************/
void HAL_SataSendSuccessStatus(void)
{
ffe01e37:	fed121        	l32r	a2, ffe0197c <_bss_table_end>
ffe01e3a:	fed181        	l32r	a8, ffe01980 <_bss_table_end+0x4>
    Lock_ShadowRegister();
ffe01e3d:	0020c0        	memw
ffe01e40:	8f0872        	l8ui	a7, a8, 143
ffe01e43:	207790        	or	a7, a7, a9
ffe01e46:	0020c0        	memw
ffe01e49:	8f4872        	s8i	a7, a8, 143
    rSDC_COMMAND_STATUS = 0x50;
ffe01e4c:	065c      	movi.n	a6, 80
ffe01e4e:	0020c0        	memw
ffe01e51:	0b4262        	s8i	a6, a2, 11
    rSDC_FEATURE_ERROR = 0;
ffe01e54:	050c      	movi.n	a5, 0
ffe01e56:	0020c0        	memw
ffe01e59:	054252        	s8i	a5, a2, 5
    rSDC_FISDirInt |= BIT_SDC_FIS_INTFLAG;
ffe01e5c:	240c      	movi.n	a4, 2
ffe01e5e:	0020c0        	memw
ffe01e61:	2b0232        	l8ui	a3, a2, 43
ffe01e64:	203340        	or	a3, a3, a4
ffe01e67:	0020c0        	memw
ffe01e6a:	2b4232        	s8i	a3, a2, 43
Modify History:
20090528    Yao Chen    001: first created
===================================================================*/
void HAL_SataSendRegD2HFIS(void)
{
    rSDC_IOControl = BIT_SDC_IOCTRL_SENDREGD2H_FIS;
ffe01e6d:	80af02        	movi	a0, -128
ffe01e70:	0020c0        	memw
ffe01e73:	2c4202        	s8i	a0, a2, 44

ffe01e76 <HAL_SataSendSuccessStatus+0x46>:
    Lock_ShadowRegister();
    rSDC_COMMAND_STATUS = 0x50;
    rSDC_FEATURE_ERROR = 0;
    rSDC_FISDirInt |= BIT_SDC_FIS_INTFLAG;
    HAL_SataSendRegD2HFIS();
    while ( FALSE == HAL_SataIsFISXferAvailable() );
ffe01e76:	01da45        	call0	ffe03c1c <HAL_SataIsFISXferAvailable>
ffe01e79:	ff9216        	beqz	a2, ffe01e76 <HAL_SataSendSuccessStatus+0x46>
    UnLock_ShadowRegister();
ffe01e7c:	f7a002        	movi	a0, 247
ffe01e7f:	0020c0        	memw
ffe01e82:	febfb1        	l32r	a11, ffe01980 <_bss_table_end+0x4>
ffe01e85:	8f0ba2        	l8ui	a10, a11, 143
ffe01e88:	10aa00        	and	a10, a10, a0
ffe01e8b:	0020c0        	memw
ffe01e8e:	8f4ba2        	s8i	a10, a11, 143

    return;
ffe01e91:	0108      	l32i.n	a0, a1, 0
ffe01e93:	10c112        	addi	a1, a1, 16
ffe01e96:	f00d      	ret.n

ffe01e98 <HAL_TriggerSataDsg>:
Usage:
    when build sata DSG chain, call this function to triger next sata DSG.
    caution:HAL_GetSataDsg = HAL_GetCurSataDsg + HAL_TriggerSataDsg
------------------------------------------------------------------------------*/
void HAL_TriggerSataDsg( U8 Type)
{
ffe01e98:	febc61        	l32r	a6, ffe01988 <_bss_table_end+0xc>
ffe01e9b:	febc51        	l32r	a5, ffe0198c <_bss_table_end+0x10>
ffe01e9e:	feb971        	l32r	a7, ffe01984 <_bss_table_end+0x8>
ffe01ea1:	62dc      	bnez.n	a2, ffe01ebb <HAL_TriggerSataDsg+0x23>
    }    
#else
    //SIM_XTENSA
    if(DSG_TYPE_WRITE == Type)
    {
        l_pSataDsgReport1->HsgTrigger = TRUE;
ffe01ea3:	0020c0        	memw
ffe01ea6:	272742        	l32i	a4, a7, 156
ffe01ea9:	0020c0        	memw
ffe01eac:	272722        	l32i	a2, a7, 156

ffe01eaf <HAL_TriggerSataDsg+0x17>:
ffe01eaf:	0238      	l32i.n	a3, a2, 0
ffe01eb1:	103350        	and	a3, a3, a5
ffe01eb4:	203360        	or	a3, a3, a6
ffe01eb7:	0439      	s32i.n	a3, a4, 0
    {
        l_pSataDsgReport2->HsgTrigger = TRUE;
    }

#endif    
}
ffe01eb9:	f00d      	ret.n

ffe01ebb <HAL_TriggerSataDsg+0x23>:
    {
        l_pSataDsgReport1->HsgTrigger = TRUE;
    }
    else
    {
        l_pSataDsgReport2->HsgTrigger = TRUE;
ffe01ebb:	0020c0        	memw
ffe01ebe:	282742        	l32i	a4, a7, 160
ffe01ec1:	0020c0        	memw
ffe01ec4:	282722        	l32i	a2, a7, 160
ffe01ec7:	fff906        	j	ffe01eaf <HAL_TriggerSataDsg+0x17>

ffe01eca <HAL_TriggerSataDsg+0x32>:
	...

ffe01ecc <HAL_GetCurSataDsg>:
Usage:
    when build sata DSG chain, call this function to get one sata DSG.
    caution:after call funtion HAL_TriggerSataDsg,current sata DSG owns to you really.
------------------------------------------------------------------------------*/
BOOL HAL_GetCurSataDsg(U16 *PDsgId, U8 Type)
{
ffe01ecc:	feb161        	l32r	a6, ffe01990 <_bss_table_end+0x14>
ffe01ecf:	feb151        	l32r	a5, ffe01994 <_bss_table_end+0x18>
ffe01ed2:	f0c112        	addi	a1, a1, -16
ffe01ed5:	0109      	s32i.n	a0, a1, 0
ffe01ed7:	feab01        	l32r	a0, ffe01984 <_bss_table_end+0x8>
ffe01eda:	f3dc      	bnez.n	a3, ffe01efd <HAL_GetCurSataDsg+0x31>
    BOOL ucStsFlag;

    if(DSG_TYPE_WRITE == Type)
    {
        if(TRUE == l_pSataDsgReport1->HsgValidEn)
ffe01edc:	0020c0        	memw
ffe01edf:	272032        	l32i	a3, a0, 156
ffe01ee2:	0338      	l32i.n	a3, a3, 0
ffe01ee4:	4d73f7        	bbci	a3, 31, ffe01f35 <HAL_GetCurSataDsg+0x69>
        {
            *PDsgId = l_pSataDsgReport1->HsgId;
ffe01ee7:	0020c0        	memw
ffe01eea:	272042        	l32i	a4, a0, 156
ffe01eed:	0448      	l32i.n	a4, a4, 0
            ucStsFlag = 1;
ffe01eef:	100c      	movi.n	a0, 1

    if(DSG_TYPE_WRITE == Type)
    {
        if(TRUE == l_pSataDsgReport1->HsgValidEn)
        {
            *PDsgId = l_pSataDsgReport1->HsgId;
ffe01ef1:	104450        	and	a4, a4, a5
ffe01ef4:	a54540        	extui	a4, a4, 21, 11
ffe01ef7:	005242        	s16i	a4, a2, 0
            ucStsFlag = 1;
ffe01efa:	000986        	j	ffe01f24 <HAL_GetCurSataDsg+0x58>

ffe01efd <HAL_GetCurSataDsg+0x31>:
            *PDsgId = INVALID_4F;
            ucStsFlag = 0;        
        }
        
    }
    else if(DSG_TYPE_READ == Type)
ffe01efd:	201366        	bnei	a3, 1, ffe01f21 <HAL_GetCurSataDsg+0x55>
    {
        if(TRUE == l_pSataDsgReport2->HsgValidEn)
ffe01f00:	0020c0        	memw
ffe01f03:	282072        	l32i	a7, a0, 160
ffe01f06:	0778      	l32i.n	a7, a7, 0
ffe01f08:	2177f7        	bbci	a7, 31, ffe01f2d <HAL_GetCurSataDsg+0x61>
        {
            *PDsgId = l_pSataDsgReport2->HsgId;        
ffe01f0b:	0020c0        	memw
ffe01f0e:	282082        	l32i	a8, a0, 160
ffe01f11:	0888      	l32i.n	a8, a8, 0
            ucStsFlag = 1;            
ffe01f13:	100c      	movi.n	a0, 1
    }
    else if(DSG_TYPE_READ == Type)
    {
        if(TRUE == l_pSataDsgReport2->HsgValidEn)
        {
            *PDsgId = l_pSataDsgReport2->HsgId;        
ffe01f15:	108850        	and	a8, a8, a5
ffe01f18:	a58580        	extui	a8, a8, 21, 11
ffe01f1b:	005282        	s16i	a8, a2, 0
            ucStsFlag = 1;            
ffe01f1e:	000086        	j	ffe01f24 <HAL_GetCurSataDsg+0x58>

ffe01f21 <HAL_GetCurSataDsg+0x55>:
            ucStsFlag = 0;    
        }        
    }
    else
    {
        DBG_Getch();
ffe01f21:	02cc45        	call0	ffe04be8 <DBG_Getch>
    }
    return ucStsFlag;
ffe01f24:	002d      	mov.n	a2, a0
ffe01f26:	0108      	l32i.n	a0, a1, 0
ffe01f28:	10c112        	addi	a1, a1, 16
ffe01f2b:	f00d      	ret.n

ffe01f2d <HAL_GetCurSataDsg+0x61>:
            *PDsgId = l_pSataDsgReport2->HsgId;        
            ucStsFlag = 1;            
        }
        else
        {
            *PDsgId = INVALID_4F;
ffe01f2d:	005262        	s16i	a6, a2, 0
            ucStsFlag = 0;    
ffe01f30:	000c      	movi.n	a0, 0
ffe01f32:	fffb86        	j	ffe01f24 <HAL_GetCurSataDsg+0x58>

ffe01f35 <HAL_GetCurSataDsg+0x69>:
            *PDsgId = l_pSataDsgReport1->HsgId;
            ucStsFlag = 1;
        }
        else
        {
            *PDsgId = INVALID_4F;
ffe01f35:	005262        	s16i	a6, a2, 0
            ucStsFlag = 0;        
ffe01f38:	000c      	movi.n	a0, 0
ffe01f3a:	fff986        	j	ffe01f24 <HAL_GetCurSataDsg+0x58>

ffe01f3d <HAL_GetCurSataDsg+0x71>:
ffe01f3d:	000000                                        ...

ffe01f40 <HAL_UsedSataDSG>:
    rFIRST_DSG_ID[CmdTag] = DSGID;
    return 0;
}

void HAL_UsedSataDSG(U8 ucDSGID)
{
ffe01f40:	f0c112        	addi	a1, a1, -16
ffe01f43:	0109      	s32i.n	a0, a1, 0
ffe01f45:	11c9      	s32i.n	a12, a1, 4
ffe01f47:	21d9      	s32i.n	a13, a1, 8
ffe01f49:	02cd      	mov.n	a12, a2
{

#ifdef SIM
    DSG_SetSataDsgValid(usDsgId);
#else
    if(usDsgId >= SATA_TOTAL_DSG_NUM)
ffe01f4b:	f4d020        	extui	a13, a2, 0, 16
ffe01f4e:	02edb6        	bltui	a13, 128, ffe01f54 <HAL_UsedSataDSG+0x14>
    {
        DBG_Getch();
ffe01f51:	02c945        	call0	ffe04be8 <DBG_Getch>

ffe01f54 <HAL_UsedSataDSG+0x14>:
ffe01f54:	fe9161        	l32r	a6, ffe01998 <_bss_table_end+0x1c>
ffe01f57:	120c      	movi.n	a2, 1
ffe01f59:	e07c      	movi.n	a0, -2
ffe01f5b:	fe9051        	l32r	a5, ffe0199c <_bss_table_end+0x20>
ffe01f5e:	fe8941        	l32r	a4, ffe01984 <_bss_table_end+0x8>
    }
    if(usDsgId < SATA_TYPE1_DSG_NUM)
ffe01f61:	58ddf6        	bgeui	a13, 64, ffe01fbd <HAL_UsedSataDSG+0x7d>
    {      
        l_pSataDsgReport2->HsgWrIndex = usDsgId;
ffe01f64:	0020c0        	memw
ffe01f67:	282492        	l32i	a9, a4, 160
ffe01f6a:	0020c0        	memw
ffe01f6d:	282482        	l32i	a8, a4, 160
ffe01f70:	0888      	l32i.n	a8, a8, 0
ffe01f72:	421d84        	insbits	a8, a13, 1, 10
ffe01f75:	0989      	s32i.n	a8, a9, 0
        l_pSataDsgReport2->HsgValue = 1;
ffe01f77:	0020c0        	memw
ffe01f7a:	282432        	l32i	a3, a4, 160
ffe01f7d:	0020c0        	memw
ffe01f80:	282472        	l32i	a7, a4, 160
ffe01f83:	0778      	l32i.n	a7, a7, 0
ffe01f85:	100700        	and	a0, a7, a0
ffe01f88:	200020        	or	a0, a0, a2
ffe01f8b:	0309      	s32i.n	a0, a3, 0
        l_pSataDsgReport2->HsgWrEn = TRUE;
ffe01f8d:	0020c0        	memw
ffe01f90:	282422        	l32i	a2, a4, 160
ffe01f93:	0020c0        	memw
ffe01f96:	282402        	l32i	a0, a4, 160
    }
    else
    {
        g_CurrUsedWriteDSGID = INVALID_4F;
    }
}
ffe01f99:	21d8      	l32i.n	a13, a1, 8
ffe01f9b:	0098      	l32i.n	a9, a0, 0
    return 0;
}

void HAL_UsedSataDSG(U8 ucDSGID)
{
    HAL_SetSataDsgValid(ucDSGID);
ffe01f9d:	fe7c01        	l32r	a0, ffe01990 <_bss_table_end+0x14>
ffe01fa0:	109960        	and	a9, a9, a6
ffe01fa3:	209950        	or	a9, a9, a5
ffe01fa6:	0299      	s32i.n	a9, a2, 0
        }
    }

#endif

    if(ucDSGID < SATA_TYPE1_DSG_NUM)
ffe01fa8:	05dcb6        	bltui	a12, 64, ffe01fb1 <HAL_UsedSataDSG+0x71>
    {
        g_CurrUsedReadDSGID = INVALID_4F;
    }
    else
    {
        g_CurrUsedWriteDSGID = INVALID_4F;
ffe01fab:	5d5402        	s16i	a0, a4, 186
ffe01fae:	000086        	j	ffe01fb4 <HAL_UsedSataDSG+0x74>

ffe01fb1 <HAL_UsedSataDSG+0x71>:

#endif

    if(ucDSGID < SATA_TYPE1_DSG_NUM)
    {
        g_CurrUsedReadDSGID = INVALID_4F;
ffe01fb1:	5c5402        	s16i	a0, a4, 184
    }
    else
    {
        g_CurrUsedWriteDSGID = INVALID_4F;
    }
}
ffe01fb4:	11c8      	l32i.n	a12, a1, 4
ffe01fb6:	0108      	l32i.n	a0, a1, 0
ffe01fb8:	10c112        	addi	a1, a1, 16
ffe01fbb:	f00d      	ret.n

ffe01fbd <HAL_UsedSataDSG+0x7d>:
    }
    else
    {
        l_pSataDsgReport1->HsgWrIndex = usDsgId;
ffe01fbd:	0020c0        	memw
ffe01fc0:	272432        	l32i	a3, a4, 156
ffe01fc3:	0020c0        	memw
ffe01fc6:	2724b2        	l32i	a11, a4, 156
ffe01fc9:	0bb8      	l32i.n	a11, a11, 0
ffe01fcb:	421db4        	insbits	a11, a13, 1, 10
ffe01fce:	03b9      	s32i.n	a11, a3, 0
        l_pSataDsgReport1->HsgValue = 1;
ffe01fd0:	0020c0        	memw
ffe01fd3:	2724b2        	l32i	a11, a4, 156
ffe01fd6:	0020c0        	memw
ffe01fd9:	2724a2        	l32i	a10, a4, 156
ffe01fdc:	0aa8      	l32i.n	a10, a10, 0
ffe01fde:	10aa00        	and	a10, a10, a0
ffe01fe1:	20aa20        	or	a10, a10, a2
ffe01fe4:	0ba9      	s32i.n	a10, a11, 0
        l_pSataDsgReport1->HsgWrEn = TRUE;
ffe01fe6:	0020c0        	memw
ffe01fe9:	272422        	l32i	a2, a4, 156
ffe01fec:	0020c0        	memw
ffe01fef:	272402        	l32i	a0, a4, 156
ffe01ff2:	ffe8c6        	j	ffe01f99 <HAL_UsedSataDSG+0x59>

ffe01ff5 <HAL_UsedSataDSG+0xb5>:
ffe01ff5:	000000                                        ...

ffe01ff8 <HAL_GetSataDsgAddr>:
    U32: address for sata DSG
Usage:
    if get one sata DSG by HAL_GetNormalDsg function, call this function to get its address.
------------------------------------------------------------------------------*/
U32 HAL_GetSataDsgAddr(U16 DsgId)
{
ffe01ff8:	f0c112        	addi	a1, a1, -16
ffe01ffb:	0109      	s32i.n	a0, a1, 0
    //SIM_XTENSA
    if(DsgId  >= SATA_TOTAL_DSG_NUM)
ffe01ffd:	05e2b6        	bltui	a2, 128, ffe02006 <HAL_GetSataDsgAddr+0xe>
    {
        DBG_Getch();
ffe02000:	02be45        	call0	ffe04be8 <DBG_Getch>
ffe02003:	0001c6        	j	ffe0200e <HAL_GetSataDsgAddr+0x16>

ffe02006 <HAL_GetSataDsgAddr+0xe>:
    }
    else
    {
        //return (U32)(DsgId*sizeof(SATA_DSG)+SATA_DSG_BASE+OTFB_START_ADDRESS);
        return (U32)(DsgId*sizeof(SATA_DSG)+SATA_DSG_BASE);
ffe02006:	fe6631        	l32r	a3, ffe019a0 <_bss_table_end+0x24>
ffe02009:	1122b0        	slli	a2, a2, 5
ffe0200c:	223a      	add.n	a2, a2, a3
ffe0200e:	0108      	l32i.n	a0, a1, 0
ffe02010:	10c112        	addi	a1, a1, 16
ffe02013:	f00d      	ret.n

ffe02015 <HAL_GetSataDsgAddr+0x1d>:
ffe02015:	000000                                        ...

ffe02018 <L1_GetSpecialReadDSG>:
Usage      : 
History    : 
    1. 2013.11.25 Haven Yang create function
==============================================================================*/
U8  L1_GetSpecialReadDSG(void)
{
ffe02018:	f0c112        	addi	a1, a1, -16
ffe0201b:	1109      	s32i.n	a0, a1, 4
ffe0201d:	fe5901        	l32r	a0, ffe01984 <_bss_table_end+0x8>
ffe02020:	fe5c21        	l32r	a2, ffe01990 <_bss_table_end+0x14>
    U16  usCurrDSG;

    if (INVALID_4F == g_CurrUsedReadDSGID)
ffe02023:	5c1002        	l16ui	a0, a0, 184
ffe02026:	299027        	bne	a0, a2, ffe02053 <L1_GetSpecialReadDSG+0x3b>
ffe02029:	012d      	mov.n	a2, a1
    {
        HAL_GetCurSataDsg(&usCurrDSG, DSG_TYPE_READ);
ffe0202b:	130c      	movi.n	a3, 1
ffe0202d:	ffe9c5        	call0	ffe01ecc <HAL_GetCurSataDsg>
        HAL_TriggerSataDsg(DSG_TYPE_READ);
ffe02030:	120c      	movi.n	a2, 1
ffe02032:	ffe645        	call0	ffe01e98 <HAL_TriggerSataDsg>

        if (INVALID_4F == usCurrDSG)
ffe02035:	fe5621        	l32r	a2, ffe01990 <_bss_table_end+0x14>
ffe02038:	001102        	l16ui	a0, a1, 0
ffe0203b:	0e9027        	bne	a0, a2, ffe0204d <L1_GetSpecialReadDSG+0x35>
ffe0203e:	012d      	mov.n	a2, a1
        {
            HAL_GetCurSataDsg(&usCurrDSG, DSG_TYPE_READ);
ffe02040:	130c      	movi.n	a3, 1
ffe02042:	ffe885        	call0	ffe01ecc <HAL_GetCurSataDsg>
            HAL_TriggerSataDsg(DSG_TYPE_READ);
ffe02045:	120c      	movi.n	a2, 1
ffe02047:	ffe505        	call0	ffe01e98 <HAL_TriggerSataDsg>
ffe0204a:	001102        	l16ui	a0, a1, 0

ffe0204d <L1_GetSpecialReadDSG+0x35>:
        }

        g_CurrUsedReadDSGID = usCurrDSG;        
ffe0204d:	fe4d31        	l32r	a3, ffe01984 <_bss_table_end+0x8>
ffe02050:	5c5302        	s16i	a0, a3, 184
    }

    return g_CurrUsedReadDSGID;
ffe02053:	742000        	extui	a2, a0, 0, 8
ffe02056:	1108      	l32i.n	a0, a1, 4
ffe02058:	10c112        	addi	a1, a1, 16
ffe0205b:	f00d      	ret.n

ffe0205d <L1_GetSpecialReadDSG+0x45>:
ffe0205d:	000000                                        ...

ffe02060 <L1_TaskSataIO>:
Description :
Others      :
Modify      :2012.11.22  modify for L1 ramdisk desgin
****************************************************************************/
BOOL L1_TaskSataIO(SUBCMD* pSubCmd)
{
ffe02060:	a0c112        	addi	a1, a1, -96
ffe02063:	1561e2        	s32i	a14, a1, 84
ffe02066:	1361c2        	s32i	a12, a1, 76
ffe02069:	126102        	s32i	a0, a1, 72
ffe0206c:	1661f2        	s32i	a15, a1, 88
ffe0206f:	1461d2        	s32i	a13, a1, 80
ffe02072:	fe44d1        	l32r	a13, ffe01984 <_bss_table_end+0x8>
ffe02075:	0f0c      	movi.n	a15, 0
    HCMD *pHCMD;
    U16 usLogicBufId = 0;
    U8 ucDSGId;
    
    if (SATA_PIO_NOCMD != gPIOInfoBlock.ucCurrPIOState)
ffe02077:	d00d02        	l8ui	a0, a13, 208
Description :
Others      :
Modify      :2012.11.22  modify for L1 ramdisk desgin
****************************************************************************/
BOOL L1_TaskSataIO(SUBCMD* pSubCmd)
{
ffe0207a:	02cd      	mov.n	a12, a2
ffe0207c:	b0ac      	beqz.n	a0, ffe020ab <L1_TaskSataIO+0x4b>
    static HCMD *pCurrHostCmd;
    static U32 ulRemainSectorCount;
    static U8 ucDRQBlkLen, ucCurrDataFISLen;

    /* No PIO command pending? It is an error assertion. */
    if (NULL == gPIOInfoBlock.pCommand )
ffe0207e:	352d22        	l32i	a2, a13, 212
    {
        return;
    }
    
    /* Entering PIO state machine. */
    switch ( gPIOInfoBlock.ucCurrPIOState ) 
ffe02081:	2e0c      	movi.n	a14, 2
ffe02083:	42ac      	beqz.n	a2, ffe020ab <L1_TaskSataIO+0x4b>
ffe02085:	300b      	addi.n	a3, a0, -1
ffe02087:	4ab316        	beqz	a3, ffe02536 <L1_TaskSataIO+0x4d6>
ffe0208a:	fec042        	addi	a4, a0, -2
ffe0208d:	44b416        	beqz	a4, ffe024dc <L1_TaskSataIO+0x47c>
ffe02090:	fdc052        	addi	a5, a0, -3
ffe02093:	45c516        	beqz	a5, ffe024f3 <L1_TaskSataIO+0x493>
ffe02096:	fcc062        	addi	a6, a0, -4
ffe02099:	3dc616        	beqz	a6, ffe02479 <L1_TaskSataIO+0x419>
ffe0209c:	fbc072        	addi	a7, a0, -5
ffe0209f:	3f9716        	beqz	a7, ffe0249c <L1_TaskSataIO+0x43c>

            break;

            /* 6. The dummy branch for a incorrect PIO state. */
        default:
            DBG_Printf("L1_SataHandlePIODataProtocol State ERROR!!\n");
ffe020a2:	fe4021        	l32r	a2, ffe019a4 <_bss_table_end+0x28>
ffe020a5:	02e185        	call0	ffe04ec0 <dbg_printf>
            DBG_Getch();
ffe020a8:	02b3c5        	call0	ffe04be8 <DBG_Getch>

ffe020ab <L1_TaskSataIO+0x4b>:
#endif
        /* PIO Step 3/3: process */
        L1_SataHandlePIODataProtocol();
    }

    if(pSubCmd == NULL)
ffe020ab:	25ac16        	beqz	a12, ffe02309 <L1_TaskSataIO+0x2a9>
   Modification : Created function

*****************************************************************************/
BOOL L1_CheckDSGResource(SUBCMD* pSubCmd)
{
    if (HCMD_WRITE == pSubCmd->pHCMD->ucCmdRW)
ffe020ae:	322d82        	l32i	a8, a13, 200
ffe020b1:	176182        	s32i	a8, a1, 92
ffe020b4:	0888      	l32i.n	a8, a8, 0
    {
        /*no subcmd or prd resource */
        return FALSE;
    }

    if (FALSE == L1_CheckDSGResource(gpCurSubCmd))
ffe020b6:	fe36e1        	l32r	a14, ffe01990 <_bss_table_end+0x14>
ffe020b9:	070882        	l8ui	a8, a8, 7
    U16  usNextDSG;

    /*========================================================================*/
    /* 1. Get Current DSG ID                                                  */
    /*========================================================================*/
    if (INVALID_4F == g_CurrUsedReadDSGID)
ffe020bc:	5c1d02        	l16ui	a0, a13, 184
ffe020bf:	98dc      	bnez.n	a8, ffe020dc <L1_TaskSataIO+0x7c>
    U16  usNextDSG;

    /*========================================================================*/
    /* 1. Get Current DSG ID                                                  */
    /*========================================================================*/
    if (INVALID_4F == g_CurrUsedWriteDSGID)
ffe020c1:	5d1d02        	l16ui	a0, a13, 186
ffe020c4:	c090e0        	sub	a9, a0, a14
ffe020c7:	385956        	bnez	a9, ffe02450 <L1_TaskSataIO+0x3f0>
ffe020ca:	012d      	mov.n	a2, a1
    {
        HAL_GetCurSataDsg(&usCurrDSG, DSG_TYPE_WRITE);
ffe020cc:	030c      	movi.n	a3, 0
ffe020ce:	ffdfc5        	call0	ffe01ecc <HAL_GetCurSataDsg>
        HAL_TriggerSataDsg(DSG_TYPE_WRITE);
ffe020d1:	020c      	movi.n	a2, 0
ffe020d3:	ffdc45        	call0	ffe01e98 <HAL_TriggerSataDsg>
ffe020d6:	001102        	l16ui	a0, a1, 0
ffe020d9:	00dd86        	j	ffe02453 <L1_TaskSataIO+0x3f3>

ffe020dc <L1_TaskSataIO+0x7c>:
    U16  usNextDSG;

    /*========================================================================*/
    /* 1. Get Current DSG ID                                                  */
    /*========================================================================*/
    if (INVALID_4F == g_CurrUsedReadDSGID)
ffe020dc:	1190e7        	bne	a0, a14, ffe020f1 <L1_TaskSataIO+0x91>
    {
        HAL_GetCurSataDsg(&usCurrDSG, DSG_TYPE_READ);
ffe020df:	214b      	addi.n	a2, a1, 4
ffe020e1:	130c      	movi.n	a3, 1
ffe020e3:	ffde85        	call0	ffe01ecc <HAL_GetCurSataDsg>
        HAL_TriggerSataDsg(DSG_TYPE_READ);
ffe020e6:	120c      	movi.n	a2, 1
ffe020e8:	ffdac5        	call0	ffe01e98 <HAL_TriggerSataDsg>
ffe020eb:	021102        	l16ui	a0, a1, 4
ffe020ee:	000086        	j	ffe020f4 <L1_TaskSataIO+0x94>

ffe020f1 <L1_TaskSataIO+0x91>:
         }
#endif
    }
    else
    {
        usCurrDSG = g_CurrUsedReadDSGID;
ffe020f1:	025102        	s16i	a0, a1, 4
    }

    if (INVALID_4F == usCurrDSG)
ffe020f4:	2010e7        	beq	a0, a14, ffe02118 <L1_TaskSataIO+0xb8>
    g_CurrUsedReadDSGID = usCurrDSG;

    /*========================================================================*/
    /* 2. Check Next DSG ID                                                   */
    /*========================================================================*/
    if (TRUE != pSubCmd->SubCmdLast)
ffe020f7:	1721a2        	l32i	a10, a1, 92
ffe020fa:	1a0aa2        	l8ui	a10, a10, 26
    if (INVALID_4F == usCurrDSG)
    {
        return FALSE;
    }

    g_CurrUsedReadDSGID = usCurrDSG;
ffe020fd:	5c5d02        	s16i	a0, a13, 184

    /*========================================================================*/
    /* 2. Check Next DSG ID                                                   */
    /*========================================================================*/
    if (TRUE != pSubCmd->SubCmdLast)
ffe02100:	191a26        	beqi	a10, 1, ffe0211d <L1_TaskSataIO+0xbd>
    {
        HAL_GetCurSataDsg(&usNextDSG, DSG_TYPE_READ);
ffe02103:	216b      	addi.n	a2, a1, 6
ffe02105:	130c      	movi.n	a3, 1
ffe02107:	ffdc45        	call0	ffe01ecc <HAL_GetCurSataDsg>
        
        if (INVALID_4F == usNextDSG)
ffe0210a:	031122        	l16ui	a2, a1, 6
ffe0210d:	c0b2e0        	sub	a11, a2, a14
ffe02110:	336b56        	bnez	a11, ffe0244a <L1_TaskSataIO+0x3ea>
        {
            HAL_TriggerSataDsg(DSG_TYPE_READ);
ffe02113:	120c      	movi.n	a2, 1
ffe02115:	ffd805        	call0	ffe01e98 <HAL_TriggerSataDsg>
    else
    {
        usCurrDSG = g_CurrUsedReadDSGID;
    }

    if (INVALID_4F == usCurrDSG)
ffe02118:	000c      	movi.n	a0, 0
ffe0211a:	000406        	j	ffe0212e <L1_TaskSataIO+0xce>

ffe0211d <L1_TaskSataIO+0xbd>:
            return FALSE;
        }
    }
    else    /* Last DSG */
    {
        usNextDSG = INVALID_4F;
ffe0211d:	fe1c21        	l32r	a2, ffe01990 <_bss_table_end+0x14>
ffe02120:	035122        	s16i	a2, a1, 6
        printf("alloc read dsg wrong 3\n");
        DBG_Getch();
    }       
#endif
    
    pSubCmd->SubDSGId     = (U8)usCurrDSG;
ffe02123:	1721e2        	l32i	a14, a1, 92
    pSubCmd->SubNextDsgId = (U8)usNextDSG;
ffe02126:	154e22        	s8i	a2, a14, 21
        printf("alloc read dsg wrong 3\n");
        DBG_Getch();
    }       
#endif
    
    pSubCmd->SubDSGId     = (U8)usCurrDSG;
ffe02129:	144e02        	s8i	a0, a14, 20
    pSubCmd->SubNextDsgId = (U8)usNextDSG;
ffe0212c:	100c      	movi.n	a0, 1
ffe0212e:	1d7016        	beqz	a0, ffe02309 <L1_TaskSataIO+0x2a9>
    
#ifdef SIM_XTENSA
    rTraceData = TL_SATAIO_CK_DSG | gpCurSubCmd->SubDSGId;
#endif

    pHCMD = pSubCmd->pHCMD;
ffe02131:	fe2221        	l32r	a2, ffe019bc <_bss_table_end+0x40>
ffe02134:	fe2141        	l32r	a4, ffe019b8 <_bss_table_end+0x3c>
ffe02137:	fe1f61        	l32r	a6, ffe019b4 <_bss_table_end+0x38>
ffe0213a:	fe1d71        	l32r	a7, ffe019b0 <_bss_table_end+0x34>
ffe0213d:	fe1b81        	l32r	a8, ffe019ac <_bss_table_end+0x30>
ffe02140:	fe1591        	l32r	a9, ffe01994 <_bss_table_end+0x18>
ffe02143:	0ce8      	l32i.n	a14, a12, 0
ffe02145:	fe10a1        	l32r	a10, ffe01988 <_bss_table_end+0xc>
    usLogicBufId = LGCBUFID_FROM_PHYBUFID(pSubCmd->SubCmdPhyBufferID);

    if(HCMD_READ == pHCMD->ucCmdRW)
ffe02148:	070e32        	l8ui	a3, a14, 7
    
#ifdef SIM_XTENSA
    rTraceData = TL_SATAIO_CK_DSG | gpCurSubCmd->SubDSGId;
#endif

    pHCMD = pSubCmd->pHCMD;
ffe0214b:	fe17b1        	l32r	a11, ffe019a8 <_bss_table_end+0x2c>
ffe0214e:	530b      	addi.n	a5, a3, -1
ffe02150:	1da556        	bnez	a5, ffe0232e <L1_TaskSataIO+0x2ce>
ffe02153:	fe1b31        	l32r	a3, ffe019c0 <_bss_table_end+0x44>
****************************************************************************/
void HAL_MemSet(U32* TargetAddr,U32 LengthDW,U32 SetValue)
{
    U32 i;

    for (i = 0 ; i < LengthDW; i++)
ffe02156:	018b      	addi.n	a0, a1, 8
ffe02158:	850c      	movi.n	a5, 8
ffe0215a:	03a576        	loopgtz	a5, ffe02161 <L1_TaskSataIO+0x101>
    {
        *TargetAddr++ = SetValue;
ffe0215d:	00f9      	s32i.n	a15, a0, 0
ffe0215f:	004b      	addi.n	a0, a0, 4

ffe02161 <L1_TaskSataIO+0x101>:

    /*========================================================================*/
    /* DW2                                                                    */
    /*========================================================================*/
    tSataDsg.NextDsgId       = pSubCmd->SubNextDsgId;
    tSataDsg.CacheStsData    = 0;
ffe02161:	1141f2        	s8i	a15, a1, 17
    tSataDsg.AtaProtInfo.XferEndIntEn    = SDC_NOT_INT_MCU;

    /*========================================================================*/
    /* DW1: Transfer control info                                             */
    /*========================================================================*/
    tSataDsg.XferCtrlInfo.Reserved       = 0;
ffe02164:	fe1851        	l32r	a5, ffe019c4 <_bss_table_end+0x48>
ffe02167:	3108      	l32i.n	a0, a1, 12
    /*========================================================================*/
    /* DW2                                                                    */
    /*========================================================================*/
    tSataDsg.NextDsgId       = pSubCmd->SubNextDsgId;
    tSataDsg.CacheStsData    = 0;
    tSataDsg.CmdLbaHigh      = 0;
ffe02169:	0951f2        	s16i	a15, a1, 18
    tSataDsg.AtaProtInfo.XferEndIntEn    = SDC_NOT_INT_MCU;

    /*========================================================================*/
    /* DW1: Transfer control info                                             */
    /*========================================================================*/
    tSataDsg.XferCtrlInfo.Reserved       = 0;
ffe0216c:	100050        	and	a0, a0, a5
    tSataDsg.XferCtrlInfo.DummyDataEn    = BIT_DISABLE;
ffe0216f:	100080        	and	a0, a0, a8
    tSataDsg.CacheStsLocSel = CS_IN_SRAM;
#ifdef OTFB_VERSION
    tSataDsg.XferCtrlInfo.DataLocSel     = DATA_IN_SRAM;
ffe02172:	200060        	or	a0, a0, a6
ffe02175:	3109      	s32i.n	a0, a1, 12
    HAL_MemSet((U32*)&tSataDsg, SATA_DSG_SIZE_DW, 0);

    /*========================================================================*/
    /* DW0: ata prot info                                                     */
    /*========================================================================*/
    tSataDsg.AtaProtInfo.AutoActiveEn    = BIT_DISABLE;
ffe02177:	2168      	l32i.n	a6, a1, 8
    tSataDsg.AtaProtInfo.IsWriteCmd      = BIT_FALSE;
ffe02179:	fe1301        	l32r	a0, ffe019c8 <_bss_table_end+0x4c>
    HAL_MemSet((U32*)&tSataDsg, SATA_DSG_SIZE_DW, 0);

    /*========================================================================*/
    /* DW0: ata prot info                                                     */
    /*========================================================================*/
    tSataDsg.AtaProtInfo.AutoActiveEn    = BIT_DISABLE;
ffe0217c:	106680        	and	a6, a6, a8
    tSataDsg.AtaProtInfo.IsWriteCmd      = BIT_FALSE;
    tSataDsg.AtaProtInfo.EcpEn           = BIT_DISABLE;
    tSataDsg.AtaProtInfo.EcpKeySel       = 0;
ffe0217f:	fe1381        	l32r	a8, ffe019cc <_bss_table_end+0x50>

    /*========================================================================*/
    /* DW0: ata prot info                                                     */
    /*========================================================================*/
    tSataDsg.AtaProtInfo.AutoActiveEn    = BIT_DISABLE;
    tSataDsg.AtaProtInfo.IsWriteCmd      = BIT_FALSE;
ffe02182:	106600        	and	a6, a6, a0
    tSataDsg.AtaProtInfo.EcpEn           = BIT_DISABLE;
ffe02185:	1066b0        	and	a6, a6, a11
    tSataDsg.AtaProtInfo.EcpKeySel       = 0;
    tSataDsg.AtaProtInfo.IsNonDataCmd    = BIT_FALSE;
    tSataDsg.AtaProtInfo.FwAckHostEn     = BIT_DISABLE;
    tSataDsg.AtaProtInfo.ProtSel         = PROTOCAL_SELECT(pHostCmd->ucCmdProtocol);//PROT_DMA_FPDMA;
ffe02188:	060e02        	l8ui	a0, a14, 6
    tSataDsg.AtaProtInfo.CmdTag          = pHostCmd->ucCmdTag;
ffe0218b:	050eb2        	l8ui	a11, a14, 5
    /* DW0: ata prot info                                                     */
    /*========================================================================*/
    tSataDsg.AtaProtInfo.AutoActiveEn    = BIT_DISABLE;
    tSataDsg.AtaProtInfo.IsWriteCmd      = BIT_FALSE;
    tSataDsg.AtaProtInfo.EcpEn           = BIT_DISABLE;
    tSataDsg.AtaProtInfo.EcpKeySel       = 0;
ffe0218e:	106680        	and	a6, a6, a8
    tSataDsg.AtaProtInfo.IsNonDataCmd    = BIT_FALSE;
    tSataDsg.AtaProtInfo.FwAckHostEn     = BIT_DISABLE;
    tSataDsg.AtaProtInfo.ProtSel         = PROTOCAL_SELECT(pHostCmd->ucCmdProtocol);//PROT_DMA_FPDMA;
ffe02191:	fcc002        	addi	a0, a0, -4
    /*========================================================================*/
    tSataDsg.AtaProtInfo.AutoActiveEn    = BIT_DISABLE;
    tSataDsg.AtaProtInfo.IsWriteCmd      = BIT_FALSE;
    tSataDsg.AtaProtInfo.EcpEn           = BIT_DISABLE;
    tSataDsg.AtaProtInfo.EcpKeySel       = 0;
    tSataDsg.AtaProtInfo.IsNonDataCmd    = BIT_FALSE;
ffe02194:	106640        	and	a6, a6, a4
#ifdef OTFB_VERSION
    tSataDsg.XferCtrlInfo.DataLocSel     = DATA_IN_SRAM;
#else
    tSataDsg.XferCtrlInfo.DataLocSel     = DATA_IN_DRAM;
#endif
    tSataDsg.XferCtrlInfo.BuffLen        = pSubCmd->SubCmdAddInfo.ucSubCmdlengthIN;// for 128k bufsize: [0(256),255~1]
ffe02197:	090c82        	l8ui	a8, a12, 9
    tSataDsg.CmdLbaHigh      = 0;

    /*========================================================================*/
    /* DW3-5:Cache status Address/ Data Address(DRAM)/ Command LBA Low 32 bit */
    /*========================================================================*/
    tSataDsg.CacheStsAddr    = ((U32)g_pCacheStatus) + (pHostCmd->ucCmdTag * 4) - OTFB_START_ADDRESS; //pSubCmd->CacheStatusAddr; //???
ffe0219a:	2b2d42        	l32i	a4, a13, 172
    tSataDsg.AtaProtInfo.AutoActiveEn    = BIT_DISABLE;
    tSataDsg.AtaProtInfo.IsWriteCmd      = BIT_FALSE;
    tSataDsg.AtaProtInfo.EcpEn           = BIT_DISABLE;
    tSataDsg.AtaProtInfo.EcpKeySel       = 0;
    tSataDsg.AtaProtInfo.IsNonDataCmd    = BIT_FALSE;
    tSataDsg.AtaProtInfo.FwAckHostEn     = BIT_DISABLE;
ffe0219d:	106620        	and	a6, a6, a2
#ifdef OTFB_VERSION
    tSataDsg.XferCtrlInfo.DataLocSel     = DATA_IN_SRAM;
#else
    tSataDsg.XferCtrlInfo.DataLocSel     = DATA_IN_DRAM;
#endif
    tSataDsg.XferCtrlInfo.BuffLen        = pSubCmd->SubCmdAddInfo.ucSubCmdlengthIN;// for 128k bufsize: [0(256),255~1]
ffe021a0:	0c4182        	s8i	a8, a1, 12
    tSataDsg.XferCtrlInfo.BuffMapId      = BUFMAP_ID(pSubCmd->SubDSGId);
ffe021a3:	3158      	l32i.n	a5, a1, 12
    /*========================================================================*/
    /* DW1: Transfer control info                                             */
    /*========================================================================*/
    tSataDsg.XferCtrlInfo.Reserved       = 0;
    tSataDsg.XferCtrlInfo.DummyDataEn    = BIT_DISABLE;
    tSataDsg.CacheStsLocSel = CS_IN_SRAM;
ffe021a5:	5128      	l32i.n	a2, a1, 20
    tSataDsg.XferCtrlInfo.BuffLen        = pSubCmd->SubCmdAddInfo.ucSubCmdlengthIN;// for 128k bufsize: [0(256),255~1]
    tSataDsg.XferCtrlInfo.BuffMapId      = BUFMAP_ID(pSubCmd->SubDSGId);
    tSataDsg.XferCtrlInfo.BuffOffset     = pSubCmd->SubCmdAddInfo.ucSubCmdOffsetIN;// for 128k bufsize: [0     ,1~255]
    tSataDsg.XferCtrlInfo.CacheStsEn     = BIT_DISABLE;//((BIT_TRUE == pSubCmd->SubCmdLast) ? BIT_ENABLE : BIT_DISABLE);    // for cosim validate cs
    tSataDsg.XferCtrlInfo.BuffMapEn      = BIT_ENABLE;
    tSataDsg.XferCtrlInfo.Eot            = pSubCmd->SubCmdLast;
ffe021a7:	1a0c82        	l8ui	a8, a12, 26
    tSataDsg.CmdLbaHigh      = 0;

    /*========================================================================*/
    /* DW3-5:Cache status Address/ Data Address(DRAM)/ Command LBA Low 32 bit */
    /*========================================================================*/
    tSataDsg.CacheStsAddr    = ((U32)g_pCacheStatus) + (pHostCmd->ucCmdTag * 4) - OTFB_START_ADDRESS; //pSubCmd->CacheStatusAddr; //???
ffe021aa:	a04b40        	addx4	a4, a11, a4
    tSataDsg.XferCtrlInfo.BuffLen        = pSubCmd->SubCmdAddInfo.ucSubCmdlengthIN;// for 128k bufsize: [0(256),255~1]
    tSataDsg.XferCtrlInfo.BuffMapId      = BUFMAP_ID(pSubCmd->SubDSGId);
    tSataDsg.XferCtrlInfo.BuffOffset     = pSubCmd->SubCmdAddInfo.ucSubCmdOffsetIN;// for 128k bufsize: [0     ,1~255]
    tSataDsg.XferCtrlInfo.CacheStsEn     = BIT_DISABLE;//((BIT_TRUE == pSubCmd->SubCmdLast) ? BIT_ENABLE : BIT_DISABLE);    // for cosim validate cs
    tSataDsg.XferCtrlInfo.BuffMapEn      = BIT_ENABLE;
    tSataDsg.XferCtrlInfo.Eot            = pSubCmd->SubCmdLast;
ffe021ad:	018810        	slli	a8, a8, 31
    tSataDsg.CmdLbaHigh      = 0;

    /*========================================================================*/
    /* DW3-5:Cache status Address/ Data Address(DRAM)/ Command LBA Low 32 bit */
    /*========================================================================*/
    tSataDsg.CacheStsAddr    = ((U32)g_pCacheStatus) + (pHostCmd->ucCmdTag * 4) - OTFB_START_ADDRESS; //pSubCmd->CacheStatusAddr; //???
ffe021b0:	44aa      	add.n	a4, a4, a10
    /*========================================================================*/
    /* DW1: Transfer control info                                             */
    /*========================================================================*/
    tSataDsg.XferCtrlInfo.Reserved       = 0;
    tSataDsg.XferCtrlInfo.DummyDataEn    = BIT_DISABLE;
    tSataDsg.CacheStsLocSel = CS_IN_SRAM;
ffe021b2:	102290        	and	a2, a2, a9
    tSataDsg.XferCtrlInfo.DataLocSel     = DATA_IN_DRAM;
#endif
    tSataDsg.XferCtrlInfo.BuffLen        = pSubCmd->SubCmdAddInfo.ucSubCmdlengthIN;// for 128k bufsize: [0(256),255~1]
    tSataDsg.XferCtrlInfo.BuffMapId      = BUFMAP_ID(pSubCmd->SubDSGId);
    tSataDsg.XferCtrlInfo.BuffOffset     = pSubCmd->SubCmdAddInfo.ucSubCmdOffsetIN;// for 128k bufsize: [0     ,1~255]
    tSataDsg.XferCtrlInfo.CacheStsEn     = BIT_DISABLE;//((BIT_TRUE == pSubCmd->SubCmdLast) ? BIT_ENABLE : BIT_DISABLE);    // for cosim validate cs
ffe021b5:	fe06a1        	l32r	a10, ffe019d0 <_bss_table_end+0x54>
    tSataDsg.CmdLbaHigh      = 0;

    /*========================================================================*/
    /* DW3-5:Cache status Address/ Data Address(DRAM)/ Command LBA Low 32 bit */
    /*========================================================================*/
    tSataDsg.CacheStsAddr    = ((U32)g_pCacheStatus) + (pHostCmd->ucCmdTag * 4) - OTFB_START_ADDRESS; //pSubCmd->CacheStatusAddr; //???
ffe021b8:	e20424        	insbits	a2, a4, 0, 30
ffe021bb:	5129      	s32i.n	a2, a1, 20
    tSataDsg.DataAddr        = L1_GetMemAddrByLBA(pSubCmd->SubCmdAddInfo.ulSubCmdLBA + pSubCmd->SubCmdAddInfo.ucSubCmdOffsetIN);
ffe021bd:	1c48      	l32i.n	a4, a12, 4
    tSataDsg.AtaProtInfo.IsWriteCmd      = BIT_FALSE;
    tSataDsg.AtaProtInfo.EcpEn           = BIT_DISABLE;
    tSataDsg.AtaProtInfo.EcpKeySel       = 0;
    tSataDsg.AtaProtInfo.IsNonDataCmd    = BIT_FALSE;
    tSataDsg.AtaProtInfo.FwAckHostEn     = BIT_DISABLE;
    tSataDsg.AtaProtInfo.ProtSel         = PROTOCAL_SELECT(pHostCmd->ucCmdProtocol);//PROT_DMA_FPDMA;
ffe021bf:	120c      	movi.n	a2, 1
ffe021c1:	930200        	movnez	a0, a2, a0
ffe021c4:	f3f064        	insbits	a6, a0, 31, 31
    tSataDsg.XferCtrlInfo.DataLocSel     = DATA_IN_SRAM;
#else
    tSataDsg.XferCtrlInfo.DataLocSel     = DATA_IN_DRAM;
#endif
    tSataDsg.XferCtrlInfo.BuffLen        = pSubCmd->SubCmdAddInfo.ucSubCmdlengthIN;// for 128k bufsize: [0(256),255~1]
    tSataDsg.XferCtrlInfo.BuffMapId      = BUFMAP_ID(pSubCmd->SubDSGId);
ffe021c7:	140c22        	l8ui	a2, a12, 20
    tSataDsg.XferCtrlInfo.BuffOffset     = pSubCmd->SubCmdAddInfo.ucSubCmdOffsetIN;// for 128k bufsize: [0     ,1~255]
ffe021ca:	080c02        	l8ui	a0, a12, 8
    tSataDsg.AtaProtInfo.EcpEn           = BIT_DISABLE;
    tSataDsg.AtaProtInfo.EcpKeySel       = 0;
    tSataDsg.AtaProtInfo.IsNonDataCmd    = BIT_FALSE;
    tSataDsg.AtaProtInfo.FwAckHostEn     = BIT_DISABLE;
    tSataDsg.AtaProtInfo.ProtSel         = PROTOCAL_SELECT(pHostCmd->ucCmdProtocol);//PROT_DMA_FPDMA;
    tSataDsg.AtaProtInfo.CmdTag          = pHostCmd->ucCmdTag;
ffe021cd:	f08b64        	insbits	a6, a11, 24, 28
ffe021d0:	2169      	s32i.n	a6, a1, 8
    tSataDsg.XferCtrlInfo.DataLocSel     = DATA_IN_SRAM;
#else
    tSataDsg.XferCtrlInfo.DataLocSel     = DATA_IN_DRAM;
#endif
    tSataDsg.XferCtrlInfo.BuffLen        = pSubCmd->SubCmdAddInfo.ucSubCmdlengthIN;// for 128k bufsize: [0(256),255~1]
    tSataDsg.XferCtrlInfo.BuffMapId      = BUFMAP_ID(pSubCmd->SubDSGId);
ffe021d2:	b20254        	insbits	a5, a2, 16, 22
ffe021d5:	3159      	s32i.n	a5, a1, 12

    /*========================================================================*/
    /* DW3-5:Cache status Address/ Data Address(DRAM)/ Command LBA Low 32 bit */
    /*========================================================================*/
    tSataDsg.CacheStsAddr    = ((U32)g_pCacheStatus) + (pHostCmd->ucCmdTag * 4) - OTFB_START_ADDRESS; //pSubCmd->CacheStatusAddr; //???
    tSataDsg.DataAddr        = L1_GetMemAddrByLBA(pSubCmd->SubCmdAddInfo.ulSubCmdLBA + pSubCmd->SubCmdAddInfo.ucSubCmdOffsetIN);
ffe021d7:	440a      	add.n	a4, a4, a0
    tSataDsg.CmdLbaLow       = pHostCmd->ulCmdLba;
ffe021d9:	0e68      	l32i.n	a6, a14, 0
ffe021db:	7169      	s32i.n	a6, a1, 28

    /*========================================================================*/
    /* DW3-5:Cache status Address/ Data Address(DRAM)/ Command LBA Low 32 bit */
    /*========================================================================*/
    tSataDsg.CacheStsAddr    = ((U32)g_pCacheStatus) + (pHostCmd->ucCmdTag * 4) - OTFB_START_ADDRESS; //pSubCmd->CacheStatusAddr; //???
    tSataDsg.DataAddr        = L1_GetMemAddrByLBA(pSubCmd->SubCmdAddInfo.ulSubCmdLBA + pSubCmd->SubCmdAddInfo.ucSubCmdOffsetIN);
ffe021dd:	114470        	slli	a4, a4, 9
#else
    tSataDsg.XferCtrlInfo.DataLocSel     = DATA_IN_DRAM;
#endif
    tSataDsg.XferCtrlInfo.BuffLen        = pSubCmd->SubCmdAddInfo.ucSubCmdlengthIN;// for 128k bufsize: [0(256),255~1]
    tSataDsg.XferCtrlInfo.BuffMapId      = BUFMAP_ID(pSubCmd->SubDSGId);
    tSataDsg.XferCtrlInfo.BuffOffset     = pSubCmd->SubCmdAddInfo.ucSubCmdOffsetIN;// for 128k bufsize: [0     ,1~255]
ffe021e0:	0d4102        	s8i	a0, a1, 13
    tSataDsg.XferCtrlInfo.CacheStsEn     = BIT_DISABLE;//((BIT_TRUE == pSubCmd->SubCmdLast) ? BIT_ENABLE : BIT_DISABLE);    // for cosim validate cs
ffe021e3:	3198      	l32i.n	a9, a1, 12

    /*========================================================================*/
    /* DW3-5:Cache status Address/ Data Address(DRAM)/ Command LBA Low 32 bit */
    /*========================================================================*/
    tSataDsg.CacheStsAddr    = ((U32)g_pCacheStatus) + (pHostCmd->ucCmdTag * 4) - OTFB_START_ADDRESS; //pSubCmd->CacheStatusAddr; //???
    tSataDsg.DataAddr        = L1_GetMemAddrByLBA(pSubCmd->SubCmdAddInfo.ulSubCmdLBA + pSubCmd->SubCmdAddInfo.ucSubCmdOffsetIN);
ffe021e5:	443a      	add.n	a4, a4, a3
ffe021e7:	6149      	s32i.n	a4, a1, 24
    tSataDsg.AtaProtInfo.EcpKeySel       = 0;
    tSataDsg.AtaProtInfo.IsNonDataCmd    = BIT_FALSE;
    tSataDsg.AtaProtInfo.FwAckHostEn     = BIT_DISABLE;
    tSataDsg.AtaProtInfo.ProtSel         = PROTOCAL_SELECT(pHostCmd->ucCmdProtocol);//PROT_DMA_FPDMA;
    tSataDsg.AtaProtInfo.CmdTag          = pHostCmd->ucCmdTag;
    tSataDsg.AtaProtInfo.CmdXferSecCnt   = pHostCmd->ulCmdSectorCnt;
ffe021e9:	2e38      	l32i.n	a3, a14, 8
    tSataDsg.XferCtrlInfo.DataLocSel     = DATA_IN_DRAM;
#endif
    tSataDsg.XferCtrlInfo.BuffLen        = pSubCmd->SubCmdAddInfo.ucSubCmdlengthIN;// for 128k bufsize: [0(256),255~1]
    tSataDsg.XferCtrlInfo.BuffMapId      = BUFMAP_ID(pSubCmd->SubDSGId);
    tSataDsg.XferCtrlInfo.BuffOffset     = pSubCmd->SubCmdAddInfo.ucSubCmdOffsetIN;// for 128k bufsize: [0     ,1~255]
    tSataDsg.XferCtrlInfo.CacheStsEn     = BIT_DISABLE;//((BIT_TRUE == pSubCmd->SubCmdLast) ? BIT_ENABLE : BIT_DISABLE);    // for cosim validate cs
ffe021eb:	1099a0        	and	a9, a9, a10
    tSataDsg.AtaProtInfo.EcpKeySel       = 0;
    tSataDsg.AtaProtInfo.IsNonDataCmd    = BIT_FALSE;
    tSataDsg.AtaProtInfo.FwAckHostEn     = BIT_DISABLE;
    tSataDsg.AtaProtInfo.ProtSel         = PROTOCAL_SELECT(pHostCmd->ucCmdProtocol);//PROT_DMA_FPDMA;
    tSataDsg.AtaProtInfo.CmdTag          = pHostCmd->ucCmdTag;
    tSataDsg.AtaProtInfo.CmdXferSecCnt   = pHostCmd->ulCmdSectorCnt;
ffe021ee:	045132        	s16i	a3, a1, 8
#endif
    tSataDsg.XferCtrlInfo.BuffLen        = pSubCmd->SubCmdAddInfo.ucSubCmdlengthIN;// for 128k bufsize: [0(256),255~1]
    tSataDsg.XferCtrlInfo.BuffMapId      = BUFMAP_ID(pSubCmd->SubDSGId);
    tSataDsg.XferCtrlInfo.BuffOffset     = pSubCmd->SubCmdAddInfo.ucSubCmdOffsetIN;// for 128k bufsize: [0     ,1~255]
    tSataDsg.XferCtrlInfo.CacheStsEn     = BIT_DISABLE;//((BIT_TRUE == pSubCmd->SubCmdLast) ? BIT_ENABLE : BIT_DISABLE);    // for cosim validate cs
    tSataDsg.XferCtrlInfo.BuffMapEn      = BIT_ENABLE;
ffe021f1:	fdf8a1        	l32r	a10, ffe019d4 <_bss_table_end+0x58>
    tSataDsg.AtaProtInfo.IsNonDataCmd    = BIT_FALSE;
    tSataDsg.AtaProtInfo.FwAckHostEn     = BIT_DISABLE;
    tSataDsg.AtaProtInfo.ProtSel         = PROTOCAL_SELECT(pHostCmd->ucCmdProtocol);//PROT_DMA_FPDMA;
    tSataDsg.AtaProtInfo.CmdTag          = pHostCmd->ucCmdTag;
    tSataDsg.AtaProtInfo.CmdXferSecCnt   = pHostCmd->ulCmdSectorCnt;
    tSataDsg.AtaProtInfo.XferEndIntEn    = SDC_NOT_INT_MCU;
ffe021f4:	21b8      	l32i.n	a11, a1, 8
#endif
    tSataDsg.XferCtrlInfo.BuffLen        = pSubCmd->SubCmdAddInfo.ucSubCmdlengthIN;// for 128k bufsize: [0(256),255~1]
    tSataDsg.XferCtrlInfo.BuffMapId      = BUFMAP_ID(pSubCmd->SubDSGId);
    tSataDsg.XferCtrlInfo.BuffOffset     = pSubCmd->SubCmdAddInfo.ucSubCmdOffsetIN;// for 128k bufsize: [0     ,1~255]
    tSataDsg.XferCtrlInfo.CacheStsEn     = BIT_DISABLE;//((BIT_TRUE == pSubCmd->SubCmdLast) ? BIT_ENABLE : BIT_DISABLE);    // for cosim validate cs
    tSataDsg.XferCtrlInfo.BuffMapEn      = BIT_ENABLE;
ffe021f6:	2099a0        	or	a9, a9, a10
    tSataDsg.AtaProtInfo.IsNonDataCmd    = BIT_FALSE;
    tSataDsg.AtaProtInfo.FwAckHostEn     = BIT_DISABLE;
    tSataDsg.AtaProtInfo.ProtSel         = PROTOCAL_SELECT(pHostCmd->ucCmdProtocol);//PROT_DMA_FPDMA;
    tSataDsg.AtaProtInfo.CmdTag          = pHostCmd->ucCmdTag;
    tSataDsg.AtaProtInfo.CmdXferSecCnt   = pHostCmd->ulCmdSectorCnt;
    tSataDsg.AtaProtInfo.XferEndIntEn    = SDC_NOT_INT_MCU;
ffe021f9:	10bb70        	and	a11, a11, a7
ffe021fc:	21b9      	s32i.n	a11, a1, 8
    tSataDsg.XferCtrlInfo.Eot            = pSubCmd->SubCmdLast;

    /*========================================================================*/
    /* DW2                                                                    */
    /*========================================================================*/
    tSataDsg.NextDsgId       = pSubCmd->SubNextDsgId;
ffe021fe:	150c72        	l8ui	a7, a12, 21
    tSataDsg.XferCtrlInfo.BuffLen        = pSubCmd->SubCmdAddInfo.ucSubCmdlengthIN;// for 128k bufsize: [0(256),255~1]
    tSataDsg.XferCtrlInfo.BuffMapId      = BUFMAP_ID(pSubCmd->SubDSGId);
    tSataDsg.XferCtrlInfo.BuffOffset     = pSubCmd->SubCmdAddInfo.ucSubCmdOffsetIN;// for 128k bufsize: [0     ,1~255]
    tSataDsg.XferCtrlInfo.CacheStsEn     = BIT_DISABLE;//((BIT_TRUE == pSubCmd->SubCmdLast) ? BIT_ENABLE : BIT_DISABLE);    // for cosim validate cs
    tSataDsg.XferCtrlInfo.BuffMapEn      = BIT_ENABLE;
    tSataDsg.XferCtrlInfo.Eot            = pSubCmd->SubCmdLast;
ffe02201:	e20984        	insbits	a8, a9, 0, 30
ffe02204:	3189      	s32i.n	a8, a1, 12

    /*========================================================================*/
    /* DW2                                                                    */
    /*========================================================================*/
    tSataDsg.NextDsgId       = pSubCmd->SubNextDsgId;
ffe02206:	104172        	s8i	a7, a1, 16
    tSataDsg.CmdLbaLow       = pHostCmd->ulCmdLba;

    /*========================================================================*/
    /* copy DSG entry from local to DRAM/ASIC  & Trigger it                   */
    /*========================================================================*/
    HAL_MemCpy((U32 *)HAL_GetSataDsgAddr(pSubCmd->SubDSGId), (U32 *)&tSataDsg, SATA_DSG_SIZE_DW);
ffe02209:	ffdec5        	call0	ffe01ff8 <HAL_GetSataDsgAddr>
ffe0220c:	80a0f2        	movi	a15, 128
ffe0220f:	318b      	addi.n	a3, a1, 8
ffe02211:	840c      	movi.n	a4, 8
ffe02213:	02e445        	call0	ffe05058 <HAL_MemCpy>
    usActualBuffLen = ((0==tSataDsg.XferCtrlInfo.BuffLen)? SEC_PER_BUF:tSataDsg.XferCtrlInfo.BuffLen);

    ulBuffMapValue = (0xffffffff << (tSataDsg.XferCtrlInfo.BuffOffset >> SEC_PER_LPN_BITS))
                   & (0xffffffff >> (31 - ((tSataDsg.XferCtrlInfo.BuffOffset + usActualBuffLen - 1) >> SEC_PER_LPN_BITS)));

    HAL_SetBufMapInitValue(tSataDsg.XferCtrlInfo.BuffMapId, ulBuffMapValue);
ffe02216:	fdf181        	l32r	a8, ffe019dc <_bss_table_end+0x60>
ffe02219:	c0a092        	movi	a9, 192
ffe0221c:	fb7c      	movi.n	a11, -1
    // bit[7:6] = 11'b, Setting high 16 bit
    //rBufMapSet = ((ulInitValue & 0xffff0000) >> 8) | (3 << 6) |(ucBufMapId);

    // bit[23:16] = mask bits. 0 = set, 1 = don't set.
    // bit[7:6] = 10'b, Setting low 8 bit
    rBufMapSet = (0 << 16) | ((ulInitValueL & 0x000000ff) << 8) | (2 << 6) | (ucBufMapId & 0x3f);
ffe0221e:	f01c      	movi.n	a0, 31
ffe02220:	024c      	movi.n	a2, 64
ffe02222:	3178      	l32i.n	a7, a1, 12
ffe02224:	0c0142        	l8ui	a4, a1, 12
ffe02227:	160c      	movi.n	a6, 1
ffe02229:	045d      	mov.n	a5, a4
ffe0222b:	935640        	movnez	a5, a6, a4
ffe0222e:	743870        	extui	a3, a7, 8, 8
ffe02231:	932450        	movnez	a2, a4, a5
ffe02234:	223a      	add.n	a2, a2, a3
ffe02236:	220b      	addi.n	a2, a2, -1
ffe02238:	212320        	srai	a2, a2, 3
ffe0223b:	c00020        	sub	a0, a0, a2
ffe0223e:	442b70        	extui	a2, a7, 11, 5
ffe02241:	557070        	extui	a7, a7, 16, 6
ffe02244:	401200        	ssl	a2
ffe02247:	a1ab00        	sll	a10, a11
ffe0224a:	074d      	mov.n	a4, a7
ffe0224c:	400000        	ssr	a0
    // bit[7:6] = 11'b, Setting high 8 bit
    rBufMapSet = (0 << 16) | (ulInitValueL & 0x0000ff00) | (3 << 6) | (ucBufMapId & 0x3f);

    /* Buffer map set high 16 bits */
    ulInitValueH = ulInitValue >> 16;
    rBufMapSetH = (0 << 16) | ((ulInitValueH & 0x000000ff) << 8) | (2 << 6) | (ucBufMapId & 0x3f);
ffe0224f:	070d      	mov.n	a0, a7
    // bit[7:6] = 11'b, Setting high 16 bit
    //rBufMapSet = ((ulInitValue & 0xffff0000) >> 8) | (3 << 6) |(ucBufMapId);

    // bit[23:16] = mask bits. 0 = set, 1 = don't set.
    // bit[7:6] = 10'b, Setting low 8 bit
    rBufMapSet = (0 << 16) | ((ulInitValueL & 0x000000ff) << 8) | (2 << 6) | (ucBufMapId & 0x3f);
ffe02251:	91b0b0        	srl	a11, a11
ffe02254:	10aab0        	and	a10, a10, a11
ffe02257:	638a44        	insbits	a4, a10, 8, 15
ffe0225a:	fddfb1        	l32r	a11, ffe019d8 <_bss_table_end+0x5c>
ffe0225d:	2044f0        	or	a4, a4, a15
ffe02260:	0020c0        	memw
ffe02263:	0849      	s32i.n	a4, a8, 0
    // bit[7:6] = 11'b, Setting high 8 bit
    rBufMapSet = (0 << 16) | (ulInitValueL & 0x0000ff00) | (3 << 6) | (ucBufMapId & 0x3f);
ffe02265:	103ab0        	and	a3, a10, a11
ffe02268:	203730        	or	a3, a7, a3
ffe0226b:	203390        	or	a3, a3, a9
ffe0226e:	0020c0        	memw

    /* Buffer map set high 16 bits */
    ulInitValueH = ulInitValue >> 16;
    rBufMapSetH = (0 << 16) | ((ulInitValueH & 0x000000ff) << 8) | (2 << 6) | (ucBufMapId & 0x3f);
ffe02271:	7520a0        	extui	a2, a10, 16, 8

    // bit[23:16] = mask bits. 0 = set, 1 = don't set.
    // bit[7:6] = 10'b, Setting low 8 bit
    rBufMapSet = (0 << 16) | ((ulInitValueL & 0x000000ff) << 8) | (2 << 6) | (ucBufMapId & 0x3f);
    // bit[7:6] = 11'b, Setting high 8 bit
    rBufMapSet = (0 << 16) | (ulInitValueL & 0x0000ff00) | (3 << 6) | (ucBufMapId & 0x3f);
ffe02274:	0839      	s32i.n	a3, a8, 0

    /* Buffer map set high 16 bits */
    ulInitValueH = ulInitValue >> 16;
    rBufMapSetH = (0 << 16) | ((ulInitValueH & 0x000000ff) << 8) | (2 << 6) | (ucBufMapId & 0x3f);
ffe02276:	f5a0a0        	extui	a10, a10, 16, 16
ffe02279:	638204        	insbits	a0, a2, 8, 15
ffe0227c:	2000f0        	or	a0, a0, a15
ffe0227f:	0020c0        	memw
ffe02282:	4809      	s32i.n	a0, a8, 16
    rBufMapSetH = (0 << 16) | (ulInitValueH & 0x0000ff00) | (3 << 6) | (ucBufMapId & 0x3f);
ffe02284:	10aab0        	and	a10, a10, a11
ffe02287:	2077a0        	or	a7, a7, a10
ffe0228a:	207790        	or	a7, a7, a9
ffe0228d:	0020c0        	memw
    
    if(BIT_TRUE == pSubCmd->SubCmdLast)
ffe02290:	1a0c62        	l8ui	a6, a12, 26
ffe02293:	4879      	s32i.n	a7, a8, 16
ffe02295:	101666        	bnei	a6, 1, ffe022a9 <L1_TaskSataIO+0x249>
GLOBAL void HAL_SetLastDataReady(U8 ucCmdTag)
{
#ifdef SIM
        SDC_SetLastDataReady(((1<<7) | ucCmdTag));
#else
        rLastDataStatusInit = (1<<7) | ucCmdTag;
ffe02298:	0c78      	l32i.n	a7, a12, 0
ffe0229a:	050772        	l8ui	a7, a7, 5
ffe0229d:	2077f0        	or	a7, a7, a15
ffe022a0:	0020c0        	memw
ffe022a3:	fdcf81        	l32r	a8, ffe019e0 <_bss_table_end+0x64>
ffe022a6:	854872        	s8i	a7, a8, 133

ffe022a9 <L1_TaskSataIO+0x249>:
        HAL_SetLastDataReady(pSubCmd->pHCMD->ucCmdTag);
 //       cosim_SetCacheStsAddr(pSubCmd->pHCMD->ucCmdTag, tSataDsg.CacheStsAddr);
 //       cosim_SetCacheStatus(tSataDsg.CacheStsAddr);
    }

    HAL_UsedSataDSG(pSubCmd->SubDSGId);
ffe022a9:	140c22        	l8ui	a2, a12, 20
ffe022ac:	ffc905        	call0	ffe01f40 <HAL_UsedSataDSG>
    
    if (BIT_TRUE == pSubCmd->SubCmdFirst)
ffe022af:	190c82        	l8ui	a8, a12, 25
ffe022b2:	140c02        	l8ui	a0, a12, 20
ffe022b5:	2a1866        	bnei	a8, 1, ffe022e3 <L1_TaskSataIO+0x283>
U16 g_CurrUsedWriteDSGID;// = INVALID_4F;


U32 HAL_SetFirstDSGID(U8 CmdTag, U8 DSGID)
{
    rFIRST_DSG_ID[CmdTag] = DSGID;
ffe022b8:	0c98      	l32i.n	a9, a12, 0
ffe022ba:	fdb0b1        	l32r	a11, ffe0197c <_bss_table_end>
ffe022bd:	0509a2        	l8ui	a10, a9, 5
ffe022c0:	aaba      	add.n	a10, a10, a11
ffe022c2:	0020c0        	memw
ffe022c5:	804a02        	s8i	a0, a10, 128
GLOBAL void HAL_SetFirstReadDataReady(U8 ucCmdTag)
{
#ifdef SIM
        SDC_SetFirstReadDataReady(((1<<7) | ucCmdTag));
#else
        rReadDataStatusInit = (1<<7) | ucCmdTag;
ffe022c8:	050992        	l8ui	a9, a9, 5
ffe022cb:	2099f0        	or	a9, a9, a15
ffe022ce:	0020c0        	memw
ffe022d1:	fdc3a1        	l32r	a10, ffe019e0 <_bss_table_end+0x64>
ffe022d4:	844a92        	s8i	a9, a10, 132
ffe022d7:	000206        	j	ffe022e3 <L1_TaskSataIO+0x283>

ffe022da <L1_TaskSataIO+0x27a>:
    {        
        ucDSGId = HAL_SataBuildWriteDSG(pSubCmd);
    }
    else
    {
        DBG_Printf("L1_TaskSataIO pHCMD->ucCmdRW %d ERROR!!\n", pHCMD->ucCmdRW);
ffe022da:	fdc221        	l32r	a2, ffe019e4 <_bss_table_end+0x68>
ffe022dd:	02be05        	call0	ffe04ec0 <dbg_printf>
        DBG_Getch();
ffe022e0:	029045        	call0	ffe04be8 <DBG_Getch>
    }
    
    /* PIO step 2/3: Mark the beginning of a PIO data command */
    if ((HCMD_PROTOCOL_PIO == pHCMD->ucCmdProtocol) && (TRUE == pSubCmd->SubCmdFirst)) 
ffe022e3:	060e22        	l8ui	a2, a14, 6

#ifdef SIM_XTENSA
    rTraceData = TL_SATAIO_BD_DSG | gpCurSubCmd->SubDSGId;
#endif

    if(INVALID_2F == ucDSGId)
ffe022e6:	ffa042        	movi	a4, 255
        DBG_Printf("L1_TaskSataIO pHCMD->ucCmdRW %d ERROR!!\n", pHCMD->ucCmdRW);
        DBG_Getch();
    }
    
    /* PIO step 2/3: Mark the beginning of a PIO data command */
    if ((HCMD_PROTOCOL_PIO == pHCMD->ucCmdProtocol) && (TRUE == pSubCmd->SubCmdFirst)) 
ffe022e9:	0d4266        	bnei	a2, 4, ffe022fa <L1_TaskSataIO+0x29a>
ffe022ec:	190cf2        	l8ui	a15, a12, 25
ffe022ef:	071f66        	bnei	a15, 1, ffe022fa <L1_TaskSataIO+0x29a>
    {
        gPIOInfoBlock.pCommand = pHCMD;
ffe022f2:	356de2        	s32i	a14, a13, 212
        gPIOInfoBlock.ucCurrPIOState = SATA_PIO_NEWCMD;
ffe022f5:	130c      	movi.n	a3, 1
ffe022f7:	d04d32        	s8i	a3, a13, 208

#ifdef SIM_XTENSA
    rTraceData = TL_SATAIO_BD_DSG | gpCurSubCmd->SubDSGId;
#endif

    if(INVALID_2F == ucDSGId)
ffe022fa:	109047        	bne	a0, a4, ffe0230e <L1_TaskSataIO+0x2ae>
    {
        if (HCMD_PROTOCOL_PIO != pHCMD->ucCmdProtocol)
ffe022fd:	084226        	beqi	a2, 4, ffe02309 <L1_TaskSataIO+0x2a9>
        {
            DBG_Printf("L1_TaskSataIO PRD ERROR!!\n");
ffe02300:	fdba21        	l32r	a2, ffe019e8 <_bss_table_end+0x6c>
ffe02303:	02bbc5        	call0	ffe04ec0 <dbg_printf>
            DBG_Getch();
ffe02306:	028e05        	call0	ffe04be8 <DBG_Getch>
    }

    if(pSubCmd == NULL)
    {
        /*no subcmd or prd resource */
        return FALSE;
ffe02309:	020c      	movi.n	a2, 0
#endif
        /* PIO Step 3/3: process */
        L1_SataHandlePIODataProtocol();
    }

    if(pSubCmd == NULL)
ffe0230b:	0002c6        	j	ffe0231a <L1_TaskSataIO+0x2ba>

ffe0230e <L1_TaskSataIO+0x2ae>:
    FIRMWARE_L1_LogInfo(LOG_FILE, 0, "L1_TaskSataIO TAG %d PRD built stage SATAIO\n", pSubCmd->pHCMD->ucCmdTag);
#endif

    g_ucL1returnflag = 5;
    pSubCmd->SubCmdStage = SUBCMD_STAGE_SATAIO;
    return TRUE;
ffe0230e:	120c      	movi.n	a2, 1
#ifdef SIM_DBG
    FIRMWARE_L1_LogInfo(LOG_FILE, 0, "L1_TaskSataIO TAG %d PRD built stage SATAIO\n", pSubCmd->pHCMD->ucCmdTag);
#endif

    g_ucL1returnflag = 5;
    pSubCmd->SubCmdStage = SUBCMD_STAGE_SATAIO;
ffe02310:	450c      	movi.n	a5, 4

#ifdef SIM_DBG
    FIRMWARE_L1_LogInfo(LOG_FILE, 0, "L1_TaskSataIO TAG %d PRD built stage SATAIO\n", pSubCmd->pHCMD->ucCmdTag);
#endif

    g_ucL1returnflag = 5;
ffe02312:	560c      	movi.n	a6, 5
ffe02314:	d84d62        	s8i	a6, a13, 216
    pSubCmd->SubCmdStage = SUBCMD_STAGE_SATAIO;
ffe02317:	174c52        	s8i	a5, a12, 23
    return TRUE;
ffe0231a:	1321c2        	l32i	a12, a1, 76
ffe0231d:	1421d2        	l32i	a13, a1, 80
ffe02320:	1521e2        	l32i	a14, a1, 84
ffe02323:	1621f2        	l32i	a15, a1, 88
ffe02326:	122102        	l32i	a0, a1, 72
ffe02329:	60c112        	addi	a1, a1, 96
ffe0232c:	f00d      	ret.n

ffe0232e <L1_TaskSataIO+0x2ce>:

    if(HCMD_READ == pHCMD->ucCmdRW)
    {
        ucDSGId = HAL_SataBuildReadDSG(pSubCmd);
    }
    else if(HCMD_WRITE == pHCMD->ucCmdRW)
ffe0232e:	fa8356        	bnez	a3, ffe022da <L1_TaskSataIO+0x27a>
****************************************************************************/
void HAL_MemSet(U32* TargetAddr,U32 LengthDW,U32 SetValue)
{
    U32 i;

    for (i = 0 ; i < LengthDW; i++)
ffe02331:	28c102        	addi	a0, a1, 40
ffe02334:	850c      	movi.n	a5, 8
ffe02336:	03a576        	loopgtz	a5, ffe0233d <L1_TaskSataIO+0x2dd>
    {
        *TargetAddr++ = SetValue;
ffe02339:	00f9      	s32i.n	a15, a0, 0
ffe0233b:	004b      	addi.n	a0, a0, 4

ffe0233d <L1_TaskSataIO+0x2dd>:

    /*========================================================================*/
    /* DW2                                                                    */
    /*========================================================================*/
    tSataDsg.NextDsgId       = pSubCmd->SubNextDsgId;
    tSataDsg.CacheStsData    = 0;
ffe0233d:	3141f2        	s8i	a15, a1, 49
    tSataDsg.CmdLbaHigh      = 0;
ffe02340:	1951f2        	s16i	a15, a1, 50
    /* DW0: ata prot info                                                     */
    /*========================================================================*/
#ifdef ONLY_ODD_CMD_TAG_DMA_AUTO_ACTIVE_EN
    tSataDsg.AtaProtInfo.AutoActiveEn    = (((HCMD_PROTOCOL_NCQ == pHostCmd->ucCmdProtocol) && (pHostCmd->ucCmdTag & 0x01)) ? BIT_ENABLE : BIT_DISABLE);
#else
    tSataDsg.AtaProtInfo.AutoActiveEn    = (HCMD_PROTOCOL_NCQ == pHostCmd->ucCmdProtocol) ? BIT_ENABLE : BIT_DISABLE;
ffe02343:	130c      	movi.n	a3, 1
ffe02345:	060e02        	l8ui	a0, a14, 6
ffe02348:	040c      	movi.n	a4, 0
ffe0234a:	fac052        	addi	a5, a0, -6
ffe0234d:	834350        	moveqz	a4, a3, a5
ffe02350:	014420        	slli	a4, a4, 30
    tSataDsg.AtaProtInfo.XferEndIntEn    = SDC_NOT_INT_MCU;

    /*========================================================================*/
    /* DW1: Transfer control info                                             */
    /*========================================================================*/
    tSataDsg.XferCtrlInfo.Reserved       = 0;
ffe02353:	b158      	l32i.n	a5, a1, 44
    tSataDsg.AtaProtInfo.IsWriteCmd      = BIT_TRUE;
    tSataDsg.AtaProtInfo.EcpEn           = BIT_DISABLE;
    tSataDsg.AtaProtInfo.EcpKeySel       = 0;
    tSataDsg.AtaProtInfo.IsNonDataCmd    = BIT_FALSE;
    tSataDsg.AtaProtInfo.FwAckHostEn     = BIT_DISABLE;
    tSataDsg.AtaProtInfo.ProtSel         = PROTOCAL_SELECT(pHostCmd->ucCmdProtocol);
ffe02355:	fcc0f2        	addi	a15, a0, -4
ffe02358:	93f3f0        	movnez	a15, a3, a15
    tSataDsg.AtaProtInfo.XferEndIntEn    = SDC_NOT_INT_MCU;

    /*========================================================================*/
    /* DW1: Transfer control info                                             */
    /*========================================================================*/
    tSataDsg.XferCtrlInfo.Reserved       = 0;
ffe0235b:	fd9a01        	l32r	a0, ffe019c4 <_bss_table_end+0x48>
    /* DW0: ata prot info                                                     */
    /*========================================================================*/
#ifdef ONLY_ODD_CMD_TAG_DMA_AUTO_ACTIVE_EN
    tSataDsg.AtaProtInfo.AutoActiveEn    = (((HCMD_PROTOCOL_NCQ == pHostCmd->ucCmdProtocol) && (pHostCmd->ucCmdTag & 0x01)) ? BIT_ENABLE : BIT_DISABLE);
#else
    tSataDsg.AtaProtInfo.AutoActiveEn    = (HCMD_PROTOCOL_NCQ == pHostCmd->ucCmdProtocol) ? BIT_ENABLE : BIT_DISABLE;
ffe0235e:	a138      	l32i.n	a3, a1, 40
    tSataDsg.AtaProtInfo.XferEndIntEn    = SDC_NOT_INT_MCU;

    /*========================================================================*/
    /* DW1: Transfer control info                                             */
    /*========================================================================*/
    tSataDsg.XferCtrlInfo.Reserved       = 0;
ffe02360:	105500        	and	a5, a5, a0
    /* DW0: ata prot info                                                     */
    /*========================================================================*/
#ifdef ONLY_ODD_CMD_TAG_DMA_AUTO_ACTIVE_EN
    tSataDsg.AtaProtInfo.AutoActiveEn    = (((HCMD_PROTOCOL_NCQ == pHostCmd->ucCmdProtocol) && (pHostCmd->ucCmdTag & 0x01)) ? BIT_ENABLE : BIT_DISABLE);
#else
    tSataDsg.AtaProtInfo.AutoActiveEn    = (HCMD_PROTOCOL_NCQ == pHostCmd->ucCmdProtocol) ? BIT_ENABLE : BIT_DISABLE;
ffe02363:	103380        	and	a3, a3, a8

    /*========================================================================*/
    /* DW1: Transfer control info                                             */
    /*========================================================================*/
    tSataDsg.XferCtrlInfo.Reserved       = 0;
    tSataDsg.XferCtrlInfo.DummyDataEn    = BIT_DISABLE;
ffe02366:	105580        	and	a5, a5, a8
    tSataDsg.CacheStsLocSel = CS_IN_SRAM;
#ifdef OTFB_VERSION
    tSataDsg.XferCtrlInfo.DataLocSel     = DATA_IN_SRAM;
ffe02369:	205560        	or	a5, a5, a6
    /* DW0: ata prot info                                                     */
    /*========================================================================*/
#ifdef ONLY_ODD_CMD_TAG_DMA_AUTO_ACTIVE_EN
    tSataDsg.AtaProtInfo.AutoActiveEn    = (((HCMD_PROTOCOL_NCQ == pHostCmd->ucCmdProtocol) && (pHostCmd->ucCmdTag & 0x01)) ? BIT_ENABLE : BIT_DISABLE);
#else
    tSataDsg.AtaProtInfo.AutoActiveEn    = (HCMD_PROTOCOL_NCQ == pHostCmd->ucCmdProtocol) ? BIT_ENABLE : BIT_DISABLE;
ffe0236c:	203340        	or	a3, a3, a4
#endif
    tSataDsg.AtaProtInfo.IsWriteCmd      = BIT_TRUE;
    tSataDsg.AtaProtInfo.EcpEn           = BIT_DISABLE;
    tSataDsg.AtaProtInfo.EcpKeySel       = 0;
    tSataDsg.AtaProtInfo.IsNonDataCmd    = BIT_FALSE;
ffe0236f:	fd9281        	l32r	a8, ffe019b8 <_bss_table_end+0x3c>
#else
    tSataDsg.AtaProtInfo.AutoActiveEn    = (HCMD_PROTOCOL_NCQ == pHostCmd->ucCmdProtocol) ? BIT_ENABLE : BIT_DISABLE;
#endif
    tSataDsg.AtaProtInfo.IsWriteCmd      = BIT_TRUE;
    tSataDsg.AtaProtInfo.EcpEn           = BIT_DISABLE;
    tSataDsg.AtaProtInfo.EcpKeySel       = 0;
ffe02372:	fd9641        	l32r	a4, ffe019cc <_bss_table_end+0x50>
    /*========================================================================*/
    tSataDsg.XferCtrlInfo.Reserved       = 0;
    tSataDsg.XferCtrlInfo.DummyDataEn    = BIT_DISABLE;
    tSataDsg.CacheStsLocSel = CS_IN_SRAM;
#ifdef OTFB_VERSION
    tSataDsg.XferCtrlInfo.DataLocSel     = DATA_IN_SRAM;
ffe02375:	b159      	s32i.n	a5, a1, 44
#ifdef ONLY_ODD_CMD_TAG_DMA_AUTO_ACTIVE_EN
    tSataDsg.AtaProtInfo.AutoActiveEn    = (((HCMD_PROTOCOL_NCQ == pHostCmd->ucCmdProtocol) && (pHostCmd->ucCmdTag & 0x01)) ? BIT_ENABLE : BIT_DISABLE);
#else
    tSataDsg.AtaProtInfo.AutoActiveEn    = (HCMD_PROTOCOL_NCQ == pHostCmd->ucCmdProtocol) ? BIT_ENABLE : BIT_DISABLE;
#endif
    tSataDsg.AtaProtInfo.IsWriteCmd      = BIT_TRUE;
ffe02377:	203360        	or	a3, a3, a6
    tSataDsg.AtaProtInfo.EcpEn           = BIT_DISABLE;
    tSataDsg.AtaProtInfo.EcpKeySel       = 0;
    tSataDsg.AtaProtInfo.IsNonDataCmd    = BIT_FALSE;
    tSataDsg.AtaProtInfo.FwAckHostEn     = BIT_DISABLE;
    tSataDsg.AtaProtInfo.ProtSel         = PROTOCAL_SELECT(pHostCmd->ucCmdProtocol);
    tSataDsg.AtaProtInfo.CmdTag          = pHostCmd->ucCmdTag;
ffe0237a:	050e52        	l8ui	a5, a14, 5
    tSataDsg.AtaProtInfo.AutoActiveEn    = (((HCMD_PROTOCOL_NCQ == pHostCmd->ucCmdProtocol) && (pHostCmd->ucCmdTag & 0x01)) ? BIT_ENABLE : BIT_DISABLE);
#else
    tSataDsg.AtaProtInfo.AutoActiveEn    = (HCMD_PROTOCOL_NCQ == pHostCmd->ucCmdProtocol) ? BIT_ENABLE : BIT_DISABLE;
#endif
    tSataDsg.AtaProtInfo.IsWriteCmd      = BIT_TRUE;
    tSataDsg.AtaProtInfo.EcpEn           = BIT_DISABLE;
ffe0237d:	1033b0        	and	a3, a3, a11
    /*========================================================================*/
    /* DW1: Transfer control info                                             */
    /*========================================================================*/
    tSataDsg.XferCtrlInfo.Reserved       = 0;
    tSataDsg.XferCtrlInfo.DummyDataEn    = BIT_DISABLE;
    tSataDsg.CacheStsLocSel = CS_IN_SRAM;
ffe02380:	d168      	l32i.n	a6, a1, 52
    tSataDsg.CmdLbaHigh      = 0;

    /*========================================================================*/
    /* DW3-5:Cache status Address/ Data Address(DRAM)/ Command LBA Low 32 bit */
    /*========================================================================*/
    tSataDsg.CacheStsAddr    = ((U32)g_pCacheStatus) + (pHostCmd->ucCmdTag * 4) - OTFB_START_ADDRESS; //pSubCmd->CacheStatusAddr - OTFB_START_ADDRESS; 
ffe02382:	2b2db2        	l32i	a11, a13, 172
#else
    tSataDsg.AtaProtInfo.AutoActiveEn    = (HCMD_PROTOCOL_NCQ == pHostCmd->ucCmdProtocol) ? BIT_ENABLE : BIT_DISABLE;
#endif
    tSataDsg.AtaProtInfo.IsWriteCmd      = BIT_TRUE;
    tSataDsg.AtaProtInfo.EcpEn           = BIT_DISABLE;
    tSataDsg.AtaProtInfo.EcpKeySel       = 0;
ffe02385:	103340        	and	a3, a3, a4
    tSataDsg.AtaProtInfo.IsNonDataCmd    = BIT_FALSE;
ffe02388:	103380        	and	a3, a3, a8
    /*========================================================================*/
    /* DW1: Transfer control info                                             */
    /*========================================================================*/
    tSataDsg.XferCtrlInfo.Reserved       = 0;
    tSataDsg.XferCtrlInfo.DummyDataEn    = BIT_DISABLE;
    tSataDsg.CacheStsLocSel = CS_IN_SRAM;
ffe0238b:	106690        	and	a6, a6, a9
#ifdef OTFB_VERSION
    tSataDsg.XferCtrlInfo.DataLocSel     = DATA_IN_SRAM;
#else
    tSataDsg.XferCtrlInfo.DataLocSel     = DATA_IN_DRAM;
#endif
    tSataDsg.XferCtrlInfo.BuffLen        = pSubCmd->SubCmdAddInfo.ucSubCmdlengthIN;
ffe0238e:	090c42        	l8ui	a4, a12, 9
ffe02391:	2c4142        	s8i	a4, a1, 44
    tSataDsg.CmdLbaHigh      = 0;

    /*========================================================================*/
    /* DW3-5:Cache status Address/ Data Address(DRAM)/ Command LBA Low 32 bit */
    /*========================================================================*/
    tSataDsg.CacheStsAddr    = ((U32)g_pCacheStatus) + (pHostCmd->ucCmdTag * 4) - OTFB_START_ADDRESS; //pSubCmd->CacheStatusAddr - OTFB_START_ADDRESS; 
ffe02394:	a095b0        	addx4	a9, a5, a11
#endif
    tSataDsg.AtaProtInfo.IsWriteCmd      = BIT_TRUE;
    tSataDsg.AtaProtInfo.EcpEn           = BIT_DISABLE;
    tSataDsg.AtaProtInfo.EcpKeySel       = 0;
    tSataDsg.AtaProtInfo.IsNonDataCmd    = BIT_FALSE;
    tSataDsg.AtaProtInfo.FwAckHostEn     = BIT_DISABLE;
ffe02397:	103320        	and	a3, a3, a2
    tSataDsg.AtaProtInfo.ProtSel         = PROTOCAL_SELECT(pHostCmd->ucCmdProtocol);
    tSataDsg.AtaProtInfo.CmdTag          = pHostCmd->ucCmdTag;
    tSataDsg.AtaProtInfo.CmdXferSecCnt   = pHostCmd->ulCmdSectorCnt;
ffe0239a:	2eb8      	l32i.n	a11, a14, 8
    tSataDsg.XferCtrlInfo.DataLocSel     = DATA_IN_SRAM;
#else
    tSataDsg.XferCtrlInfo.DataLocSel     = DATA_IN_DRAM;
#endif
    tSataDsg.XferCtrlInfo.BuffLen        = pSubCmd->SubCmdAddInfo.ucSubCmdlengthIN;
    tSataDsg.XferCtrlInfo.BuffMapId      = BUFMAP_ID(pSubCmd->SubDSGId);
ffe0239c:	140c22        	l8ui	a2, a12, 20
ffe0239f:	b108      	l32i.n	a0, a1, 44
    tSataDsg.AtaProtInfo.IsWriteCmd      = BIT_TRUE;
    tSataDsg.AtaProtInfo.EcpEn           = BIT_DISABLE;
    tSataDsg.AtaProtInfo.EcpKeySel       = 0;
    tSataDsg.AtaProtInfo.IsNonDataCmd    = BIT_FALSE;
    tSataDsg.AtaProtInfo.FwAckHostEn     = BIT_DISABLE;
    tSataDsg.AtaProtInfo.ProtSel         = PROTOCAL_SELECT(pHostCmd->ucCmdProtocol);
ffe023a1:	f3ff34        	insbits	a3, a15, 31, 31
    tSataDsg.CmdLbaHigh      = 0;

    /*========================================================================*/
    /* DW3-5:Cache status Address/ Data Address(DRAM)/ Command LBA Low 32 bit */
    /*========================================================================*/
    tSataDsg.CacheStsAddr    = ((U32)g_pCacheStatus) + (pHostCmd->ucCmdTag * 4) - OTFB_START_ADDRESS; //pSubCmd->CacheStatusAddr - OTFB_START_ADDRESS; 
ffe023a4:	99aa      	add.n	a9, a9, a10
    tSataDsg.XferCtrlInfo.Eot            = pSubCmd->SubCmdLast;

    /*========================================================================*/
    /* DW2                                                                    */
    /*========================================================================*/
    tSataDsg.NextDsgId       = pSubCmd->SubNextDsgId;
ffe023a6:	150c42        	l8ui	a4, a12, 21
ffe023a9:	304142        	s8i	a4, a1, 48
#else
    tSataDsg.XferCtrlInfo.DataLocSel     = DATA_IN_DRAM;
#endif
    tSataDsg.XferCtrlInfo.BuffLen        = pSubCmd->SubCmdAddInfo.ucSubCmdlengthIN;
    tSataDsg.XferCtrlInfo.BuffMapId      = BUFMAP_ID(pSubCmd->SubDSGId);
    tSataDsg.XferCtrlInfo.BuffOffset     = pSubCmd->SubCmdAddInfo.ucSubCmdOffsetIN;
ffe023ac:	080ca2        	l8ui	a10, a12, 8

    /*========================================================================*/
    /* DW3-5:Cache status Address/ Data Address(DRAM)/ Command LBA Low 32 bit */
    /*========================================================================*/
    tSataDsg.CacheStsAddr    = ((U32)g_pCacheStatus) + (pHostCmd->ucCmdTag * 4) - OTFB_START_ADDRESS; //pSubCmd->CacheStatusAddr - OTFB_START_ADDRESS; 
    tSataDsg.DataAddr        = L1_GetMemAddrByLBA(pSubCmd->SubCmdAddInfo.ulSubCmdLBA + pSubCmd->SubCmdAddInfo.ucSubCmdOffsetIN);
ffe023af:	1cf8      	l32i.n	a15, a12, 4
    tSataDsg.AtaProtInfo.EcpEn           = BIT_DISABLE;
    tSataDsg.AtaProtInfo.EcpKeySel       = 0;
    tSataDsg.AtaProtInfo.IsNonDataCmd    = BIT_FALSE;
    tSataDsg.AtaProtInfo.FwAckHostEn     = BIT_DISABLE;
    tSataDsg.AtaProtInfo.ProtSel         = PROTOCAL_SELECT(pHostCmd->ucCmdProtocol);
    tSataDsg.AtaProtInfo.CmdTag          = pHostCmd->ucCmdTag;
ffe023b1:	f08534        	insbits	a3, a5, 24, 28
    tSataDsg.CmdLbaHigh      = 0;

    /*========================================================================*/
    /* DW3-5:Cache status Address/ Data Address(DRAM)/ Command LBA Low 32 bit */
    /*========================================================================*/
    tSataDsg.CacheStsAddr    = ((U32)g_pCacheStatus) + (pHostCmd->ucCmdTag * 4) - OTFB_START_ADDRESS; //pSubCmd->CacheStatusAddr - OTFB_START_ADDRESS; 
ffe023b4:	e20964        	insbits	a6, a9, 0, 30
ffe023b7:	d169      	s32i.n	a6, a1, 52
    tSataDsg.XferCtrlInfo.BuffLen        = pSubCmd->SubCmdAddInfo.ucSubCmdlengthIN;
    tSataDsg.XferCtrlInfo.BuffMapId      = BUFMAP_ID(pSubCmd->SubDSGId);
    tSataDsg.XferCtrlInfo.BuffOffset     = pSubCmd->SubCmdAddInfo.ucSubCmdOffsetIN;
    tSataDsg.XferCtrlInfo.CacheStsEn     = BIT_DISABLE;//((BIT_TRUE == pSubCmd->SubCmdLast) ? BIT_ENABLE : BIT_DISABLE); // for cosim validate cs //ramdisk must disable cs, and wholechip write enable.
    tSataDsg.XferCtrlInfo.BuffMapEn      = BIT_DISABLE;
    tSataDsg.XferCtrlInfo.Eot            = pSubCmd->SubCmdLast;
ffe023b9:	1a0c52        	l8ui	a5, a12, 26
    tSataDsg.AtaProtInfo.EcpEn           = BIT_DISABLE;
    tSataDsg.AtaProtInfo.EcpKeySel       = 0;
    tSataDsg.AtaProtInfo.IsNonDataCmd    = BIT_FALSE;
    tSataDsg.AtaProtInfo.FwAckHostEn     = BIT_DISABLE;
    tSataDsg.AtaProtInfo.ProtSel         = PROTOCAL_SELECT(pHostCmd->ucCmdProtocol);
    tSataDsg.AtaProtInfo.CmdTag          = pHostCmd->ucCmdTag;
ffe023bc:	a139      	s32i.n	a3, a1, 40
    tSataDsg.XferCtrlInfo.DataLocSel     = DATA_IN_SRAM;
#else
    tSataDsg.XferCtrlInfo.DataLocSel     = DATA_IN_DRAM;
#endif
    tSataDsg.XferCtrlInfo.BuffLen        = pSubCmd->SubCmdAddInfo.ucSubCmdlengthIN;
    tSataDsg.XferCtrlInfo.BuffMapId      = BUFMAP_ID(pSubCmd->SubDSGId);
ffe023be:	b20204        	insbits	a0, a2, 16, 22
    tSataDsg.AtaProtInfo.EcpKeySel       = 0;
    tSataDsg.AtaProtInfo.IsNonDataCmd    = BIT_FALSE;
    tSataDsg.AtaProtInfo.FwAckHostEn     = BIT_DISABLE;
    tSataDsg.AtaProtInfo.ProtSel         = PROTOCAL_SELECT(pHostCmd->ucCmdProtocol);
    tSataDsg.AtaProtInfo.CmdTag          = pHostCmd->ucCmdTag;
    tSataDsg.AtaProtInfo.CmdXferSecCnt   = pHostCmd->ulCmdSectorCnt;
ffe023c1:	1451b2        	s16i	a11, a1, 40
    /*========================================================================*/
    /* DW3-5:Cache status Address/ Data Address(DRAM)/ Command LBA Low 32 bit */
    /*========================================================================*/
    tSataDsg.CacheStsAddr    = ((U32)g_pCacheStatus) + (pHostCmd->ucCmdTag * 4) - OTFB_START_ADDRESS; //pSubCmd->CacheStatusAddr - OTFB_START_ADDRESS; 
    tSataDsg.DataAddr        = L1_GetMemAddrByLBA(pSubCmd->SubCmdAddInfo.ulSubCmdLBA + pSubCmd->SubCmdAddInfo.ucSubCmdOffsetIN);
    tSataDsg.CmdLbaLow       = pHostCmd->ulCmdLba;
ffe023c4:	0e38      	l32i.n	a3, a14, 0
ffe023c6:	f139      	s32i.n	a3, a1, 60
    tSataDsg.XferCtrlInfo.BuffLen        = pSubCmd->SubCmdAddInfo.ucSubCmdlengthIN;
    tSataDsg.XferCtrlInfo.BuffMapId      = BUFMAP_ID(pSubCmd->SubDSGId);
    tSataDsg.XferCtrlInfo.BuffOffset     = pSubCmd->SubCmdAddInfo.ucSubCmdOffsetIN;
    tSataDsg.XferCtrlInfo.CacheStsEn     = BIT_DISABLE;//((BIT_TRUE == pSubCmd->SubCmdLast) ? BIT_ENABLE : BIT_DISABLE); // for cosim validate cs //ramdisk must disable cs, and wholechip write enable.
    tSataDsg.XferCtrlInfo.BuffMapEn      = BIT_DISABLE;
    tSataDsg.XferCtrlInfo.Eot            = pSubCmd->SubCmdLast;
ffe023c8:	015510        	slli	a5, a5, 31
    tSataDsg.AtaProtInfo.IsNonDataCmd    = BIT_FALSE;
    tSataDsg.AtaProtInfo.FwAckHostEn     = BIT_DISABLE;
    tSataDsg.AtaProtInfo.ProtSel         = PROTOCAL_SELECT(pHostCmd->ucCmdProtocol);
    tSataDsg.AtaProtInfo.CmdTag          = pHostCmd->ucCmdTag;
    tSataDsg.AtaProtInfo.CmdXferSecCnt   = pHostCmd->ulCmdSectorCnt;
    tSataDsg.AtaProtInfo.XferEndIntEn    = SDC_NOT_INT_MCU;
ffe023cb:	a198      	l32i.n	a9, a1, 40
    tSataDsg.XferCtrlInfo.DataLocSel     = DATA_IN_SRAM;
#else
    tSataDsg.XferCtrlInfo.DataLocSel     = DATA_IN_DRAM;
#endif
    tSataDsg.XferCtrlInfo.BuffLen        = pSubCmd->SubCmdAddInfo.ucSubCmdlengthIN;
    tSataDsg.XferCtrlInfo.BuffMapId      = BUFMAP_ID(pSubCmd->SubDSGId);
ffe023cd:	b109      	s32i.n	a0, a1, 44

    /*========================================================================*/
    /* DW3-5:Cache status Address/ Data Address(DRAM)/ Command LBA Low 32 bit */
    /*========================================================================*/
    tSataDsg.CacheStsAddr    = ((U32)g_pCacheStatus) + (pHostCmd->ucCmdTag * 4) - OTFB_START_ADDRESS; //pSubCmd->CacheStatusAddr - OTFB_START_ADDRESS; 
    tSataDsg.DataAddr        = L1_GetMemAddrByLBA(pSubCmd->SubCmdAddInfo.ulSubCmdLBA + pSubCmd->SubCmdAddInfo.ucSubCmdOffsetIN);
ffe023cf:	ffaa      	add.n	a15, a15, a10
ffe023d1:	fd7b01        	l32r	a0, ffe019c0 <_bss_table_end+0x44>
ffe023d4:	11ff70        	slli	a15, a15, 9
#else
    tSataDsg.XferCtrlInfo.DataLocSel     = DATA_IN_DRAM;
#endif
    tSataDsg.XferCtrlInfo.BuffLen        = pSubCmd->SubCmdAddInfo.ucSubCmdlengthIN;
    tSataDsg.XferCtrlInfo.BuffMapId      = BUFMAP_ID(pSubCmd->SubDSGId);
    tSataDsg.XferCtrlInfo.BuffOffset     = pSubCmd->SubCmdAddInfo.ucSubCmdOffsetIN;
ffe023d7:	2d41a2        	s8i	a10, a1, 45
    tSataDsg.XferCtrlInfo.CacheStsEn     = BIT_DISABLE;//((BIT_TRUE == pSubCmd->SubCmdLast) ? BIT_ENABLE : BIT_DISABLE); // for cosim validate cs //ramdisk must disable cs, and wholechip write enable.
ffe023da:	b168      	l32i.n	a6, a1, 44
    tSataDsg.AtaProtInfo.IsNonDataCmd    = BIT_FALSE;
    tSataDsg.AtaProtInfo.FwAckHostEn     = BIT_DISABLE;
    tSataDsg.AtaProtInfo.ProtSel         = PROTOCAL_SELECT(pHostCmd->ucCmdProtocol);
    tSataDsg.AtaProtInfo.CmdTag          = pHostCmd->ucCmdTag;
    tSataDsg.AtaProtInfo.CmdXferSecCnt   = pHostCmd->ulCmdSectorCnt;
    tSataDsg.AtaProtInfo.XferEndIntEn    = SDC_NOT_INT_MCU;
ffe023dc:	109970        	and	a9, a9, a7
ffe023df:	a199      	s32i.n	a9, a1, 40
    tSataDsg.XferCtrlInfo.DataLocSel     = DATA_IN_DRAM;
#endif
    tSataDsg.XferCtrlInfo.BuffLen        = pSubCmd->SubCmdAddInfo.ucSubCmdlengthIN;
    tSataDsg.XferCtrlInfo.BuffMapId      = BUFMAP_ID(pSubCmd->SubDSGId);
    tSataDsg.XferCtrlInfo.BuffOffset     = pSubCmd->SubCmdAddInfo.ucSubCmdOffsetIN;
    tSataDsg.XferCtrlInfo.CacheStsEn     = BIT_DISABLE;//((BIT_TRUE == pSubCmd->SubCmdLast) ? BIT_ENABLE : BIT_DISABLE); // for cosim validate cs //ramdisk must disable cs, and wholechip write enable.
ffe023e1:	fd7b71        	l32r	a7, ffe019d0 <_bss_table_end+0x54>

    /*========================================================================*/
    /* DW3-5:Cache status Address/ Data Address(DRAM)/ Command LBA Low 32 bit */
    /*========================================================================*/
    tSataDsg.CacheStsAddr    = ((U32)g_pCacheStatus) + (pHostCmd->ucCmdTag * 4) - OTFB_START_ADDRESS; //pSubCmd->CacheStatusAddr - OTFB_START_ADDRESS; 
    tSataDsg.DataAddr        = L1_GetMemAddrByLBA(pSubCmd->SubCmdAddInfo.ulSubCmdLBA + pSubCmd->SubCmdAddInfo.ucSubCmdOffsetIN);
ffe023e4:	ff0a      	add.n	a15, a15, a0
ffe023e6:	e1f9      	s32i.n	a15, a1, 56
    tSataDsg.XferCtrlInfo.DataLocSel     = DATA_IN_DRAM;
#endif
    tSataDsg.XferCtrlInfo.BuffLen        = pSubCmd->SubCmdAddInfo.ucSubCmdlengthIN;
    tSataDsg.XferCtrlInfo.BuffMapId      = BUFMAP_ID(pSubCmd->SubDSGId);
    tSataDsg.XferCtrlInfo.BuffOffset     = pSubCmd->SubCmdAddInfo.ucSubCmdOffsetIN;
    tSataDsg.XferCtrlInfo.CacheStsEn     = BIT_DISABLE;//((BIT_TRUE == pSubCmd->SubCmdLast) ? BIT_ENABLE : BIT_DISABLE); // for cosim validate cs //ramdisk must disable cs, and wholechip write enable.
ffe023e8:	106670        	and	a6, a6, a7
    tSataDsg.XferCtrlInfo.BuffMapEn      = BIT_DISABLE;
ffe023eb:	106680        	and	a6, a6, a8
    tSataDsg.XferCtrlInfo.Eot            = pSubCmd->SubCmdLast;
ffe023ee:	e20654        	insbits	a5, a6, 0, 30
ffe023f1:	b159      	s32i.n	a5, a1, 44
    tSataDsg.CmdLbaLow       = pHostCmd->ulCmdLba;

    /*========================================================================*/
    /* copy DSG entry from local to DRAM/ASIC  & Trigger it                   */
    /*========================================================================*/
    HAL_MemCpy((U32 *)HAL_GetSataDsgAddr(pSubCmd->SubDSGId), (U32 *)&tSataDsg, SATA_DSG_SIZE_DW);
ffe023f3:	ffc045        	call0	ffe01ff8 <HAL_GetSataDsgAddr>
ffe023f6:	80a0f2        	movi	a15, 128
ffe023f9:	28c132        	addi	a3, a1, 40
ffe023fc:	840c      	movi.n	a4, 8
ffe023fe:	02c585        	call0	ffe05058 <HAL_MemCpy>
    
    if(pSubCmd->SubCmdLast)
ffe02401:	1a0c22        	l8ui	a2, a12, 26
ffe02404:	f28c      	beqz.n	a2, ffe02417 <L1_TaskSataIO+0x3b7>
GLOBAL void HAL_SetLastDataReady(U8 ucCmdTag)
{
#ifdef SIM
        SDC_SetLastDataReady(((1<<7) | ucCmdTag));
#else
        rLastDataStatusInit = (1<<7) | ucCmdTag;
ffe02406:	0c38      	l32i.n	a3, a12, 0
ffe02408:	050332        	l8ui	a3, a3, 5
ffe0240b:	2033f0        	or	a3, a3, a15
ffe0240e:	0020c0        	memw
ffe02411:	fd7341        	l32r	a4, ffe019e0 <_bss_table_end+0x64>
ffe02414:	854432        	s8i	a3, a4, 133

ffe02417 <L1_TaskSataIO+0x3b7>:
        HAL_SetLastDataReady(pSubCmd->pHCMD->ucCmdTag);
//        cosim_SetCacheStsAddr(pSubCmd->pHCMD->ucCmdTag, tSataDsg.CacheStsAddr);
//        cosim_SetCacheStatus(tSataDsg.CacheStsAddr);
    }

    HAL_UsedSataDSG(pSubCmd->SubDSGId);
ffe02417:	140c22        	l8ui	a2, a12, 20
ffe0241a:	ffb245        	call0	ffe01f40 <HAL_UsedSataDSG>

    if (BIT_TRUE == pSubCmd->SubCmdFirst)
ffe0241d:	190c42        	l8ui	a4, a12, 25
ffe02420:	140c02        	l8ui	a0, a12, 20
ffe02423:	440b      	addi.n	a4, a4, -1
ffe02425:	eba456        	bnez	a4, ffe022e3 <L1_TaskSataIO+0x283>
ffe02428:	0c58      	l32i.n	a5, a12, 0
ffe0242a:	fd5471        	l32r	a7, ffe0197c <_bss_table_end>
ffe0242d:	050562        	l8ui	a6, a5, 5
ffe02430:	667a      	add.n	a6, a6, a7
ffe02432:	0020c0        	memw
ffe02435:	804602        	s8i	a0, a6, 128
GLOBAL void HAL_SetFirstReadDataReady(U8 ucCmdTag)
{
#ifdef SIM
        SDC_SetFirstReadDataReady(((1<<7) | ucCmdTag));
#else
        rReadDataStatusInit = (1<<7) | ucCmdTag;
ffe02438:	050552        	l8ui	a5, a5, 5
ffe0243b:	2055f0        	or	a5, a5, a15
ffe0243e:	0020c0        	memw
ffe02441:	fd6761        	l32r	a6, ffe019e0 <_bss_table_end+0x64>
ffe02444:	844652        	s8i	a5, a6, 132
ffe02447:	ffa606        	j	ffe022e3 <L1_TaskSataIO+0x283>

ffe0244a <L1_TaskSataIO+0x3ea>:
    {
        HAL_GetCurSataDsg(&usNextDSG, DSG_TYPE_READ);
        
        if (INVALID_4F == usNextDSG)
        {
            HAL_TriggerSataDsg(DSG_TYPE_READ);
ffe0244a:	021102        	l16ui	a0, a1, 4
ffe0244d:	ff3486        	j	ffe02123 <L1_TaskSataIO+0xc3>

ffe02450 <L1_TaskSataIO+0x3f0>:
         }
#endif
    }
    else
    {
        usCurrDSG = g_CurrUsedWriteDSGID;
ffe02450:	005102        	s16i	a0, a1, 0
    }

    if (INVALID_4F == usCurrDSG)
ffe02453:	1d10e7        	beq	a0, a14, ffe02474 <L1_TaskSataIO+0x414>
    g_CurrUsedWriteDSGID = usCurrDSG;

    /*========================================================================*/
    /* 2. Check Next DSG ID                                                   */
    /*========================================================================*/
    if (TRUE != pSubCmd->SubCmdLast)
ffe02456:	172182        	l32i	a8, a1, 92
ffe02459:	1a0882        	l8ui	a8, a8, 26
    if (INVALID_4F == usCurrDSG)
    {
        return FALSE;
    }

    g_CurrUsedWriteDSGID = usCurrDSG;
ffe0245c:	5d5d02        	s16i	a0, a13, 186

    /*========================================================================*/
    /* 2. Check Next DSG ID                                                   */
    /*========================================================================*/
    if (TRUE != pSubCmd->SubCmdLast)
ffe0245f:	5f1826        	beqi	a8, 1, ffe024c2 <L1_TaskSataIO+0x462>
    {
        HAL_GetCurSataDsg(&usNextDSG, DSG_TYPE_WRITE);
ffe02462:	212b      	addi.n	a2, a1, 2
ffe02464:	030c      	movi.n	a3, 0
ffe02466:	ffa645        	call0	ffe01ecc <HAL_GetCurSataDsg>
        
        if (INVALID_4F == usNextDSG)
ffe02469:	011122        	l16ui	a2, a1, 2
ffe0246c:	6692e7        	bne	a2, a14, ffe024d6 <L1_TaskSataIO+0x476>
        {
            HAL_TriggerSataDsg(DSG_TYPE_WRITE);
ffe0246f:	020c      	movi.n	a2, 0
ffe02471:	ffa245        	call0	ffe01e98 <HAL_TriggerSataDsg>
    else
    {
        usCurrDSG = g_CurrUsedWriteDSGID;
    }

    if (INVALID_4F == usCurrDSG)
ffe02474:	000c      	movi.n	a0, 0
ffe02476:	ff2d06        	j	ffe0212e <L1_TaskSataIO+0xce>

ffe02479 <L1_TaskSataIO+0x419>:
#ifdef SIM_XTENSA
            rTracer = TL_PIO_STAGE | (SATA_PIO_DATA_OUT<<24) | 1;
#endif

            /* Check whether a data FIS from host has been received. */
            if ( TRUE == g_bFlagPIODataRec ) 
ffe02479:	2c2d92        	l32i	a9, a13, 176
ffe0247c:	161966        	bnei	a9, 1, ffe02496 <L1_TaskSataIO+0x436>
            {
                /* Clear the corresponding global flag. */
                g_bFlagPIODataRec = FALSE;
ffe0247f:	2c6df2        	s32i	a15, a13, 176
                //dbg_printf("PIOW\n\r");

                /* Update our global data record of current command. */
                ulRemainSectorCount -= ucCurrDataFISLen;
ffe02482:	f50d02        	l8ui	a0, a13, 245
ffe02485:	3c2db2        	l32i	a11, a13, 240

                /* Select the next stage according to the remaining data length. */
                if ( 0 == ulRemainSectorCount )
ffe02488:	5a0c      	movi.n	a10, 5
                /* Clear the corresponding global flag. */
                g_bFlagPIODataRec = FALSE;
                //dbg_printf("PIOW\n\r");

                /* Update our global data record of current command. */
                ulRemainSectorCount -= ucCurrDataFISLen;
ffe0248a:	c0bb00        	sub	a11, a11, a0
ffe0248d:	3c6db2        	s32i	a11, a13, 240

                /* Select the next stage according to the remaining data length. */
                if ( 0 == ulRemainSectorCount )
ffe02490:	83eab0        	moveqz	a14, a10, a11
ffe02493:	d04de2        	s8i	a14, a13, 208
    20141028    Gavin   add "INLINE" attribute
------------------------------------------------------------------------------*/
INLINE void HAL_EnableMCUIntAck(void)
{
#ifndef SIM
    XT_RSIL(0);
ffe02496:	006020        	rsil	a2, 0
            }
#ifndef SIM
            HAL_EnableMCUIntAck();
#endif
            /* The data FIS has not been received yet and we shall keep waiting in current state. */
            break;
ffe02499:	ff0386        	j	ffe020ab <L1_TaskSataIO+0x4b>

ffe0249c <L1_TaskSataIO+0x43c>:
#ifdef SIM_XTENSA
            rTracer = TL_PIO_STAGE | (SATA_PIO_FINISH<<24) | 1;
#endif

            /* If there is any pending FIS, we shall neither trigger another FIS nor modify PIO state now. */
            if( FAIL == HAL_SataIsFISXferAvailable() )
ffe0249c:	0177c5        	call0	ffe03c1c <HAL_SataIsFISXferAvailable>
            {
                break;
ffe0249f:	c08216        	beqz	a2, ffe020ab <L1_TaskSataIO+0x4b>
ffe024a2:	8e0c      	movi.n	a14, 8
#ifdef SIM_XTENSA
            rTracer = TL_PIO_STAGE | (SATA_PIO_FINISH<<24) | 2;
#endif

            /* Send the status report to host. */
            HAL_SataSendSuccessStatus();
ffe024a4:	ff9885        	call0	ffe01e30 <HAL_SataSendSuccessStatus>
#ifdef SIM_XTENSA
            rTracer = TL_PIO_STAGE | (SATA_PIO_FINISH<<24) | 3;
#endif

            gPIOInfoBlock.pCommand = NULL;
ffe024a7:	356df2        	s32i	a15, a13, 212
            gPIOInfoBlock.ucCurrPIOState = SATA_PIO_NOCMD;
ffe024aa:	d04df2        	s8i	a15, a13, 208
            //dbg_printf("PIOWFin\n\r");
            
            /* Now we can clear the PIO command pending flag. */
            rSDC_FW_Ctrl  |= CLR_PIOCMD_DATA; //VT3514, clear small busy
ffe024ad:	0020c0        	memw
ffe024b0:	fd3341        	l32r	a4, ffe0197c <_bss_table_end>
ffe024b3:	4e0432        	l8ui	a3, a4, 78
ffe024b6:	2033e0        	or	a3, a3, a14
ffe024b9:	0020c0        	memw
ffe024bc:	4e4432        	s8i	a3, a4, 78

            break;
ffe024bf:	fefa06        	j	ffe020ab <L1_TaskSataIO+0x4b>

ffe024c2 <L1_TaskSataIO+0x462>:
            return FALSE;
        }
    }
    else    /* Last DSG */
    {
        usNextDSG = INVALID_4F;
ffe024c2:	fd3321        	l32r	a2, ffe01990 <_bss_table_end+0x14>
ffe024c5:	015122        	s16i	a2, a1, 2
        printf("alloc read dsg wrong 3\n");
        DBG_Getch();
    }       
#endif
    
    pSubCmd->SubDSGId     = (U8)usCurrDSG;
ffe024c8:	172142        	l32i	a4, a1, 92
ffe024cb:	144402        	s8i	a0, a4, 20
    pSubCmd->SubNextDsgId = (U8)usNextDSG;
ffe024ce:	154422        	s8i	a2, a4, 21
ffe024d1:	100c      	movi.n	a0, 1
ffe024d3:	ff15c6        	j	ffe0212e <L1_TaskSataIO+0xce>

ffe024d6 <L1_TaskSataIO+0x476>:
    {
        HAL_GetCurSataDsg(&usNextDSG, DSG_TYPE_WRITE);
        
        if (INVALID_4F == usNextDSG)
        {
            HAL_TriggerSataDsg(DSG_TYPE_WRITE);
ffe024d6:	001102        	l16ui	a0, a1, 0
ffe024d9:	fffac6        	j	ffe024c8 <L1_TaskSataIO+0x468>

ffe024dc <L1_TaskSataIO+0x47c>:
#ifdef SIM_XTENSA
            rTracer = TL_PIO_STAGE | (SATA_PIO_SETUP<<24) | 1;
#endif

            /* If there is any pending FIS, we shall neither trigger another FIS nor modify PIO state now. */
            if (FAIL == HAL_SataIsFISXferAvailable())
ffe024dc:	0173c5        	call0	ffe03c1c <HAL_SataIsFISXferAvailable>
            {
                break;
ffe024df:	bc8216        	beqz	a2, ffe020ab <L1_TaskSataIO+0x4b>
                bFirstDRQBlk = FALSE;
            }
            
            /* Calculate current DRQ block length and decide whether
            current DRQ block is the last one within current host command. */
            if ( ulRemainSectorCount > (U32)ucDRQBlkLen ) 
ffe024e2:	3c2d02        	l32i	a0, a13, 240
ffe024e5:	f40d42        	l8ui	a4, a13, 244
ffe024e8:	63b407        	bgeu	a4, a0, ffe0254f <L1_TaskSataIO+0x4ef>
            {
                ucCurrDataFISLen = ucDRQBlkLen;
ffe024eb:	f54d42        	s8i	a4, a13, 245
ffe024ee:	030c      	movi.n	a3, 0
ffe024f0:	0018c6        	j	ffe02557 <L1_TaskSataIO+0x4f7>

ffe024f3 <L1_TaskSataIO+0x493>:
#ifdef SIM_XTENSA
            rTracer = TL_PIO_STAGE | (SATA_PIO_DATA_IN<<24) | 1;
#endif

            /* If there is any pending FIS, we shall neither trigger another FIS nor modify PIO state now. */
            if( FAIL == HAL_SataIsFISXferAvailable() )
ffe024f3:	017285        	call0	ffe03c1c <HAL_SataIsFISXferAvailable>
            {
                break;
ffe024f6:	bb1216        	beqz	a2, ffe020ab <L1_TaskSataIO+0x4b>
Modify History:
20090528    Yao Chen    001: first created
===================================================================*/
void HAL_SataSendPIODataFIS(void)
{
    rSDC_IOControl = BIT_SDC_IOCTRL_SENDPIODATA_FIS;
ffe024f9:	0020c0        	memw
#ifdef SIM_XTENSA
            rTracer = TL_PIO_STAGE | (SATA_PIO_DATA_IN<<24) | 3;
#endif

            /* Update our global data record of current command. */
            ulRemainSectorCount -= ucCurrDataFISLen;
ffe024fc:	f50d62        	l8ui	a6, a13, 245
ffe024ff:	3c2d52        	l32i	a5, a13, 240
ffe02502:	fd1e81        	l32r	a8, ffe0197c <_bss_table_end>
ffe02505:	870c      	movi.n	a7, 8
ffe02507:	2c4872        	s8i	a7, a8, 44
ffe0250a:	c05560        	sub	a5, a5, a6
ffe0250d:	3c6d52        	s32i	a5, a13, 240

            /* Select the next stage according to the remaining data length. */
            if ( 0 == ulRemainSectorCount ) 
ffe02510:	06d556        	bnez	a5, ffe02581 <L1_TaskSataIO+0x521>
            {                
                gPIOInfoBlock.pCommand = NULL;
ffe02513:	356df2        	s32i	a15, a13, 212
                gPIOInfoBlock.ucCurrPIOState = SATA_PIO_NOCMD;
ffe02516:	d04df2        	s8i	a15, a13, 208

                while ( FALSE == HAL_SataIsFISXferAvailable() ); //wait Data FIS transfer finish.
ffe02519:	017005        	call0	ffe03c1c <HAL_SataIsFISXferAvailable>
ffe0251c:	ff9216        	beqz	a2, ffe02519 <L1_TaskSataIO+0x4b9>
                
                rSDC_FW_Ctrl  |= CLR_PIOCMD_DATA; //VT3514, clear small busy
ffe0251f:	0020c0        	memw
ffe02522:	fd16a1        	l32r	a10, ffe0197c <_bss_table_end>
ffe02525:	4e0a92        	l8ui	a9, a10, 78
ffe02528:	8b0c      	movi.n	a11, 8
ffe0252a:	2099b0        	or	a9, a9, a11
ffe0252d:	0020c0        	memw
ffe02530:	4e4a92        	s8i	a9, a10, 78
ffe02533:	fedd06        	j	ffe020ab <L1_TaskSataIO+0x4b>

ffe02536 <L1_TaskSataIO+0x4d6>:
    switch ( gPIOInfoBlock.ucCurrPIOState ) 
    {
        /* 1. A new host command is pending and we shall record its parameters and initialize our data record. */
        case SATA_PIO_NEWCMD:
        
            g_bFlagPIODataRec   = FALSE;
ffe02536:	2c6df2        	s32i	a15, a13, 176
            pCurrHostCmd        = gPIOInfoBlock.pCommand;
ffe02539:	3b6d22        	s32i	a2, a13, 236
            ulRemainSectorCount = pCurrHostCmd->ulCmdSectorCnt;
ffe0253c:	2208      	l32i.n	a0, a2, 8
ffe0253e:	3c6d02        	s32i	a0, a13, 240
            ucDRQBlkLen         = L1_GetDRQBlkLen(pCurrHostCmd->ucCmdCode);
ffe02541:	040222        	l8ui	a2, a2, 4
ffe02544:	ff8c45        	call0	ffe01e0c <L1_GetDRQBlkLen>
ffe02547:	0e0d      	mov.n	a0, a14
ffe02549:	f44d22        	s8i	a2, a13, 244
ffe0254c:	000ac6        	j	ffe0257b <L1_TaskSataIO+0x51b>

ffe0254f <L1_TaskSataIO+0x4ef>:
                bLastDRQBlk = FALSE;
            }
            else 
            {
                ucCurrDataFISLen = ulRemainSectorCount;
                bLastDRQBlk = TRUE;
ffe0254f:	130c      	movi.n	a3, 1
                ucCurrDataFISLen = ucDRQBlkLen;
                bLastDRQBlk = FALSE;
            }
            else 
            {
                ucCurrDataFISLen = ulRemainSectorCount;
ffe02551:	744000        	extui	a4, a0, 0, 8
ffe02554:	f54d42        	s8i	a4, a13, 245
                bLastDRQBlk = TRUE;
            }

            /* Construct the PIO setup FIS through our information on current DRQ block. */
            //            dbg_printf("PIO Setup\n\r");
            HAL_SataConstructAndSendPIOSetupFIS(bFirstDRQBlk, bLastDRQBlk, ucCurrDataFISLen, pCurrHostCmd->ucCmdRW);
ffe02557:	160c      	movi.n	a6, 1
ffe02559:	3b2d52        	l32i	a5, a13, 236
ffe0255c:	020c      	movi.n	a2, 0
ffe0255e:	2578      	l32i.n	a7, a5, 8
ffe02560:	070552        	l8ui	a5, a5, 7
ffe02563:	c07700        	sub	a7, a7, a0
ffe02566:	832670        	moveqz	a2, a6, a7
ffe02569:	ff7fc5        	call0	ffe01d68 <HAL_SataConstructAndSendPIOSetupFIS>
#ifdef SIM_XTENSA
            rTracer = TL_PIO_STAGE | (SATA_PIO_SETUP<<24) | 3;
#endif

            /* Select the next stage according to the data direction. */
            if ( HCMD_READ == pCurrHostCmd->ucCmdRW )
ffe0256c:	3b2d92        	l32i	a9, a13, 236
ffe0256f:	380c      	movi.n	a8, 3
ffe02571:	070992        	l8ui	a9, a9, 7
ffe02574:	400c      	movi.n	a0, 4
ffe02576:	990b      	addi.n	a9, a9, -1
ffe02578:	830890        	moveqz	a0, a8, a9
ffe0257b:	d04d02        	s8i	a0, a13, 208
            }
            else
            {
                gPIOInfoBlock.ucCurrPIOState = SATA_PIO_DATA_OUT;
            }
            break;
ffe0257e:	feca46        	j	ffe020ab <L1_TaskSataIO+0x4b>

ffe02581 <L1_TaskSataIO+0x521>:
                rTracer = TL_PIO_STAGE | (SATA_PIO_DATA_IN<<24) | 4;
#endif
            }
            else
            {
                gPIOInfoBlock.ucCurrPIOState = SATA_PIO_SETUP;
ffe02581:	d04de2        	s8i	a14, a13, 208
ffe02584:	fec8c6        	j	ffe020ab <L1_TaskSataIO+0x4b>

ffe02587 <L1_TaskSataIO+0x527>:
	...

ffe02588 <L1_SplitHCMD>:
        DBG_Getch();
    }
#endif

    /*  First Check whether Host usCmdRemSector ==0 */
    if(0 == pTgtHCMD->ulCmdRemSector)
ffe02588:	3278      	l32i.n	a7, a2, 12
20120209   Brooke Wang create detailed code
20120118   peterxiu   001 first create function
****************************************************************************/

SUBCMD* L1_SplitHCMD(HCMD *pTgtHCMD)
{
ffe0258a:	f0c112        	addi	a1, a1, -16
ffe0258d:	57cc      	bnez.n	a7, ffe02596 <L1_SplitHCMD+0xe>
#endif

    /*  First Check whether Host usCmdRemSector ==0 */
    if(0 == pTgtHCMD->ulCmdRemSector)
    {
        return NULL;
ffe0258f:	020c      	movi.n	a2, 0
              gNextPuToSelect = 0;
        }
#endif

    pTgtSUBCMD->SubCmdStage = SUBCMD_STAGE_SPLIT;
    return pTgtSUBCMD;
ffe02591:	10c112        	addi	a1, a1, 16
ffe02594:	f00d      	ret.n

ffe02596 <L1_SplitHCMD+0xe>:
    {
        return NULL;
    }

    /* SubCmdEntry is only for debug to log recent SubCmds */
    pTgtSUBCMD = &gSubCmdEntry[gCurSubCmd];
ffe02596:	060c      	movi.n	a6, 0
ffe02598:	fcfbb1        	l32r	a11, ffe01984 <_bss_table_end+0x8>
ffe0259b:	c52c      	movi.n	a5, 44
ffe0259d:	cc0b42        	l8ui	a4, a11, 204
    {
        gCurSubCmd = 0;
    }

    /* Then Initialize this SUBCMD */
    for (ucLoop = 0; ucLoop < SUBCMD_SIZE; ucLoop++)
ffe025a0:	b80c      	movi.n	a8, 11
    {
        return NULL;
    }

    /* SubCmdEntry is only for debug to log recent SubCmds */
    pTgtSUBCMD = &gSubCmdEntry[gCurSubCmd];
ffe025a2:	d15450        	mul16s	a5, a4, a5
    
    gCurSubCmd++;
ffe025a5:	441b      	addi.n	a4, a4, 1
ffe025a7:	744040        	extui	a4, a4, 0, 8
    {
        return NULL;
    }

    /* SubCmdEntry is only for debug to log recent SubCmds */
    pTgtSUBCMD = &gSubCmdEntry[gCurSubCmd];
ffe025aa:	5b5a      	add.n	a5, a11, a5
ffe025ac:	04d552        	addmi	a5, a5, 0x400
ffe025af:	40c552        	addi	a5, a5, 64
    
    gCurSubCmd++;
    if (gCurSubCmd == SUBCMD_ENTRY_DEPTH)
ffe025b2:	05b466        	bnei	a4, 16, ffe025bb <L1_SplitHCMD+0x33>
    {
        gCurSubCmd = 0;
ffe025b5:	cc4b62        	s8i	a6, a11, 204
ffe025b8:	000086        	j	ffe025be <L1_SplitHCMD+0x36>

ffe025bb <L1_SplitHCMD+0x33>:
ffe025bb:	cc4b42        	s8i	a4, a11, 204
    }

    /* Then Initialize this SUBCMD */
    for (ucLoop = 0; ucLoop < SUBCMD_SIZE; ucLoop++)
ffe025be:	040c      	movi.n	a4, 0
ffe025c0:	2109      	s32i.n	a0, a1, 8
    {
      *((U32*)(pTgtSUBCMD) + ucLoop) = 0;
    }

    /* (0)  Fill in the according field of subcmd from hcmd */
    pTgtSUBCMD->pHCMD = pTgtHCMD;
ffe025c2:	034c      	movi.n	a3, 64
    pTgtSUBCMD->SubDSGId = INVALID_2F;
    pTgtSUBCMD->SubNextDsgId = INVALID_2F;

    /* (1) get the host cmd  start LBA in this subcmd */
    ulStartLBA = pTgtHCMD->ulCmdLba + pTgtHCMD->ulCmdSectorCnt - pTgtHCMD->ulCmdRemSector;
ffe025c4:	2298      	l32i.n	a9, a2, 8
    {
      *((U32*)(pTgtSUBCMD) + ucLoop) = 0;
    }

    /* (0)  Fill in the according field of subcmd from hcmd */
    pTgtSUBCMD->pHCMD = pTgtHCMD;
ffe025c6:	ffafa2        	movi	a10, -1
ffe025c9:	09a876        	loopgtz	a8, ffe025d6 <L1_SplitHCMD+0x4e>
    }

    /* Then Initialize this SUBCMD */
    for (ucLoop = 0; ucLoop < SUBCMD_SIZE; ucLoop++)
    {
      *((U32*)(pTgtSUBCMD) + ucLoop) = 0;
ffe025cc:	a08450        	addx4	a8, a4, a5
ffe025cf:	0869      	s32i.n	a6, a8, 0
    {
        gCurSubCmd = 0;
    }

    /* Then Initialize this SUBCMD */
    for (ucLoop = 0; ucLoop < SUBCMD_SIZE; ucLoop++)
ffe025d1:	441b      	addi.n	a4, a4, 1
ffe025d3:	744040        	extui	a4, a4, 0, 8

ffe025d6 <L1_SplitHCMD+0x4e>:
      *((U32*)(pTgtSUBCMD) + ucLoop) = 0;
    }

    /* (0)  Fill in the according field of subcmd from hcmd */
    pTgtSUBCMD->pHCMD = pTgtHCMD;
    pTgtSUBCMD->SubDSGId = INVALID_2F;
ffe025d6:	1445a2        	s8i	a10, a5, 20
    pTgtSUBCMD->SubNextDsgId = INVALID_2F;
ffe025d9:	1545a2        	s8i	a10, a5, 21
    {
      *((U32*)(pTgtSUBCMD) + ucLoop) = 0;
    }

    /* (0)  Fill in the according field of subcmd from hcmd */
    pTgtSUBCMD->pHCMD = pTgtHCMD;
ffe025dc:	0529      	s32i.n	a2, a5, 0
    pTgtSUBCMD->SubDSGId = INVALID_2F;
    pTgtSUBCMD->SubNextDsgId = INVALID_2F;

    /* (1) get the host cmd  start LBA in this subcmd */
    ulStartLBA = pTgtHCMD->ulCmdLba + pTgtHCMD->ulCmdSectorCnt - pTgtHCMD->ulCmdRemSector;
ffe025de:	02a8      	l32i.n	a10, a2, 0

    /* (2) get the StartLBA of this SUBCMD, each SUBCMD is split by max_flash_page_size(buffer size) 16K/32K */
    pTgtSUBCMD->SubCmdAddInfo.ulSubCmdLBA = L1_CalcSubLBAForL1(ulStartLBA);
ffe025e0:	c0af82        	movi	a8, -64
    pTgtSUBCMD->pHCMD = pTgtHCMD;
    pTgtSUBCMD->SubDSGId = INVALID_2F;
    pTgtSUBCMD->SubNextDsgId = INVALID_2F;

    /* (1) get the host cmd  start LBA in this subcmd */
    ulStartLBA = pTgtHCMD->ulCmdLba + pTgtHCMD->ulCmdSectorCnt - pTgtHCMD->ulCmdRemSector;
ffe025e3:	99aa      	add.n	a9, a9, a10
ffe025e5:	c09970        	sub	a9, a9, a7

    /* (2) get the StartLBA of this SUBCMD, each SUBCMD is split by max_flash_page_size(buffer size) 16K/32K */
    pTgtSUBCMD->SubCmdAddInfo.ulSubCmdLBA = L1_CalcSubLBAForL1(ulStartLBA);
ffe025e8:	108980        	and	a8, a9, a8
ffe025eb:	1589      	s32i.n	a8, a5, 4
    

    /* (3) Get the SubCmdOffset & SubCmdLength  of this SUBCMD*/
    pTgtSUBCMD->SubCmdAddInfo.ucSubCmdOffsetIN = SUBCMD_OFFSET(ulStartLBA);
ffe025ed:	548090        	extui	a8, a9, 0, 6
ffe025f0:	084582        	s8i	a8, a5, 8

    ucCMDOffset = pTgtSUBCMD->SubCmdAddInfo.ucSubCmdOffsetIN;

    if ((ucCMDOffset + pTgtHCMD->ulCmdRemSector) > SEC_PER_BUF)
ffe025f3:	478a      	add.n	a4, a7, a8
ffe025f5:	62b347        	bgeu	a3, a4, ffe0265b <L1_SplitHCMD+0xd3>
    {
        //SEC_PER_BUF=256, Value Overflow: ucSubCmdlengthIN:[1~255,0] ---> actualLenIN:[1~255,256]
        pTgtSUBCMD->SubCmdAddInfo.ucSubCmdlengthIN = SEC_PER_BUF - pTgtSUBCMD->SubCmdAddInfo.ucSubCmdOffsetIN;
ffe025f8:	044c      	movi.n	a4, 64
ffe025fa:	c04480        	sub	a4, a4, a8

ffe025fd <L1_SplitHCMD+0x75>:
    else
    {
        pTgtSUBCMD->SubCmdAddInfo.ucSubCmdlengthIN = (U8)pTgtHCMD->ulCmdRemSector;
    }

    if (0 == pTgtSUBCMD->SubCmdAddInfo.ucSubCmdlengthIN)
ffe025fd:	034c      	movi.n	a3, 64
    ucCMDOffset = pTgtSUBCMD->SubCmdAddInfo.ucSubCmdOffsetIN;

    if ((ucCMDOffset + pTgtHCMD->ulCmdRemSector) > SEC_PER_BUF)
    {
        //SEC_PER_BUF=256, Value Overflow: ucSubCmdlengthIN:[1~255,0] ---> actualLenIN:[1~255,256]
        pTgtSUBCMD->SubCmdAddInfo.ucSubCmdlengthIN = SEC_PER_BUF - pTgtSUBCMD->SubCmdAddInfo.ucSubCmdOffsetIN;
ffe025ff:	744040        	extui	a4, a4, 0, 8
    {
        usActalSubCmdLength = SEC_PER_BUF;
    }
    else
    {
        usActalSubCmdLength = pTgtSUBCMD->SubCmdAddInfo.ucSubCmdlengthIN;
ffe02602:	040d      	mov.n	a0, a4
    ucCMDOffset = pTgtSUBCMD->SubCmdAddInfo.ucSubCmdOffsetIN;

    if ((ucCMDOffset + pTgtHCMD->ulCmdRemSector) > SEC_PER_BUF)
    {
        //SEC_PER_BUF=256, Value Overflow: ucSubCmdlengthIN:[1~255,0] ---> actualLenIN:[1~255,256]
        pTgtSUBCMD->SubCmdAddInfo.ucSubCmdlengthIN = SEC_PER_BUF - pTgtSUBCMD->SubCmdAddInfo.ucSubCmdOffsetIN;
ffe02604:	094542        	s8i	a4, a5, 9
    else
    {
        pTgtSUBCMD->SubCmdAddInfo.ucSubCmdlengthIN = (U8)pTgtHCMD->ulCmdRemSector;
    }

    if (0 == pTgtSUBCMD->SubCmdAddInfo.ucSubCmdlengthIN)
ffe02607:	830340        	moveqz	a0, a3, a4
    /*first make cmdlength LPN=4K align*/

    pTgtSUBCMD->SubCmdAddInfo.ucSubLPNOffsetIN = SUBCMDLPN_OFFSET(ucCMDOffset);

    ucVirtualSUBCMDLength = SUBCMD_OFFSET_IN_LPN(ucCMDOffset) + usActalSubCmdLength;
    pTgtSUBCMD->SubCmdAddInfo.ucSubLPNCountIN = SUBCMDLPN_COUNT(ucVirtualSUBCMDLength);
ffe0260a:	244080        	extui	a4, a8, 0, 3
    pTgtHCMD->ulCmdRemSector -= usActalSubCmdLength; 
        
    /* (4) Get the LPNoffset & LPN count of this SUBCMD*/    
    /*first make cmdlength LPN=4K align*/

    pTgtSUBCMD->SubCmdAddInfo.ucSubLPNOffsetIN = SUBCMDLPN_OFFSET(ucCMDOffset);
ffe0260d:	413380        	srli	a3, a8, 3
    else
    {
        pTgtSUBCMD->SubCmdAddInfo.ucSubCmdlengthIN = (U8)pTgtHCMD->ulCmdRemSector;
    }

    if (0 == pTgtSUBCMD->SubCmdAddInfo.ucSubCmdlengthIN)
ffe02610:	0109      	s32i.n	a0, a1, 0
    pTgtHCMD->ulCmdRemSector -= usActalSubCmdLength; 
        
    /* (4) Get the LPNoffset & LPN count of this SUBCMD*/    
    /*first make cmdlength LPN=4K align*/

    pTgtSUBCMD->SubCmdAddInfo.ucSubLPNOffsetIN = SUBCMDLPN_OFFSET(ucCMDOffset);
ffe02612:	0a4532        	s8i	a3, a5, 10
    else
    {
        usActalSubCmdLength = pTgtSUBCMD->SubCmdAddInfo.ucSubCmdlengthIN;
    }
    
    pTgtHCMD->ulCmdRemSector -= usActalSubCmdLength; 
ffe02615:	0138      	l32i.n	a3, a1, 0
ffe02617:	2108      	l32i.n	a0, a1, 8
    /*first make cmdlength LPN=4K align*/

    pTgtSUBCMD->SubCmdAddInfo.ucSubLPNOffsetIN = SUBCMDLPN_OFFSET(ucCMDOffset);

    ucVirtualSUBCMDLength = SUBCMD_OFFSET_IN_LPN(ucCMDOffset) + usActalSubCmdLength;
    pTgtSUBCMD->SubCmdAddInfo.ucSubLPNCountIN = SUBCMDLPN_COUNT(ucVirtualSUBCMDLength);
ffe02619:	434a      	add.n	a4, a3, a4
    else
    {
        usActalSubCmdLength = pTgtSUBCMD->SubCmdAddInfo.ucSubCmdlengthIN;
    }
    
    pTgtHCMD->ulCmdRemSector -= usActalSubCmdLength; 
ffe0261b:	c03730        	sub	a3, a7, a3
    /*first make cmdlength LPN=4K align*/

    pTgtSUBCMD->SubCmdAddInfo.ucSubLPNOffsetIN = SUBCMDLPN_OFFSET(ucCMDOffset);

    ucVirtualSUBCMDLength = SUBCMD_OFFSET_IN_LPN(ucCMDOffset) + usActalSubCmdLength;
    pTgtSUBCMD->SubCmdAddInfo.ucSubLPNCountIN = SUBCMDLPN_COUNT(ucVirtualSUBCMDLength);
ffe0261e:	744040        	extui	a4, a4, 0, 8

    /*(4)  Configure SUBCMD  First, Last and ID */

    pTgtSUBCMD->SubCmdFirst = (ulStartLBA == pTgtHCMD->ulCmdLba);
ffe02621:	070c      	movi.n	a7, 0
    else
    {
        usActalSubCmdLength = pTgtSUBCMD->SubCmdAddInfo.ucSubCmdlengthIN;
    }
    
    pTgtHCMD->ulCmdRemSector -= usActalSubCmdLength; 
ffe02623:	3239      	s32i.n	a3, a2, 12
    /*first make cmdlength LPN=4K align*/

    pTgtSUBCMD->SubCmdAddInfo.ucSubLPNOffsetIN = SUBCMDLPN_OFFSET(ucCMDOffset);

    ucVirtualSUBCMDLength = SUBCMD_OFFSET_IN_LPN(ucCMDOffset) + usActalSubCmdLength;
    pTgtSUBCMD->SubCmdAddInfo.ucSubLPNCountIN = SUBCMDLPN_COUNT(ucVirtualSUBCMDLength);
ffe02625:	447b      	addi.n	a4, a4, 7
ffe02627:	214340        	srai	a4, a4, 3
ffe0262a:	0b4542        	s8i	a4, a5, 11
    {
        usActalSubCmdLength = SEC_PER_BUF;
    }
    else
    {
        usActalSubCmdLength = pTgtSUBCMD->SubCmdAddInfo.ucSubCmdlengthIN;
ffe0262d:	120c      	movi.n	a2, 1
    ucVirtualSUBCMDLength = SUBCMD_OFFSET_IN_LPN(ucCMDOffset) + usActalSubCmdLength;
    pTgtSUBCMD->SubCmdAddInfo.ucSubLPNCountIN = SUBCMDLPN_COUNT(ucVirtualSUBCMDLength);

    /*(4)  Configure SUBCMD  First, Last and ID */

    pTgtSUBCMD->SubCmdFirst = (ulStartLBA == pTgtHCMD->ulCmdLba);
ffe0262f:	c04a90        	sub	a4, a10, a9
ffe02632:	837240        	moveqz	a7, a2, a4

    if(pTgtSUBCMD->SubCmdFirst)
ffe02635:	cd0b42        	l8ui	a4, a11, 205
    ucVirtualSUBCMDLength = SUBCMD_OFFSET_IN_LPN(ucCMDOffset) + usActalSubCmdLength;
    pTgtSUBCMD->SubCmdAddInfo.ucSubLPNCountIN = SUBCMDLPN_COUNT(ucVirtualSUBCMDLength);

    /*(4)  Configure SUBCMD  First, Last and ID */

    pTgtSUBCMD->SubCmdFirst = (ulStartLBA == pTgtHCMD->ulCmdLba);
ffe02638:	194572        	s8i	a7, a5, 25

    if(pTgtSUBCMD->SubCmdFirst)
ffe0263b:	934670        	movnez	a4, a6, a7
        gDbgHcmdLba = pTgtSUBCMD->SubCmdAddInfo.ulSubCmdLBA + pTgtSUBCMD->SubCmdAddInfo.ucSubCmdOffsetIN;
        gDbgHcmdLen = 0;
        #endif
    }

    pTgtSUBCMD->SubCmdId = ucSUBCMDId;
ffe0263e:	164542        	s8i	a4, a5, 22
    ucSUBCMDId++;  
ffe02641:	741b      	addi.n	a7, a4, 1
ffe02643:	cd4b72        	s8i	a7, a11, 205
ffe02646:	43cc      	bnez.n	a3, ffe0264e <L1_SplitHCMD+0xc6>
    gDbgHcmdLen = gDbgHcmdLen + usActalSubCmdLength;
    #endif

    if(pTgtHCMD->ulCmdRemSector == 0)
    {
        pTgtSUBCMD->SubCmdLast = TRUE;
ffe02648:	1a4522        	s8i	a2, a5, 26
ffe0264b:	000086        	j	ffe02651 <L1_SplitHCMD+0xc9>

ffe0264e <L1_SplitHCMD+0xc6>:
        }
#endif
    }
    else
    {
        pTgtSUBCMD->SubCmdLast = FALSE;
ffe0264e:	1a4562        	s8i	a6, a5, 26
    {
              gNextPuToSelect = 0;
        }
#endif

    pTgtSUBCMD->SubCmdStage = SUBCMD_STAGE_SPLIT;
ffe02651:	174522        	s8i	a2, a5, 23
    return pTgtSUBCMD;
ffe02654:	10c112        	addi	a1, a1, 16
ffe02657:	052d      	mov.n	a2, a5
ffe02659:	f00d      	ret.n

ffe0265b <L1_SplitHCMD+0xd3>:
ffe0265b:	074d      	mov.n	a4, a7
ffe0265d:	ffe706        	j	ffe025fd <L1_SplitHCMD+0x75>

ffe02660 <HAL_SataSendAbortStatus>:
Description :
Others      :
Modify      :
****************************************************************************/
void HAL_SataSendAbortStatus(void)
{
ffe02660:	f0c112        	addi	a1, a1, -16
ffe02663:	0109      	s32i.n	a0, a1, 0
    Lock_ShadowRegister();
ffe02665:	890c      	movi.n	a9, 8
Description :
Others      :
Modify      :
****************************************************************************/
void HAL_SataSendAbortStatus(void)
{
ffe02667:	fcc521        	l32r	a2, ffe0197c <_bss_table_end>
ffe0266a:	fcc581        	l32r	a8, ffe01980 <_bss_table_end+0x4>
    Lock_ShadowRegister();
ffe0266d:	0020c0        	memw
ffe02670:	8f0872        	l8ui	a7, a8, 143
ffe02673:	207790        	or	a7, a7, a9
ffe02676:	0020c0        	memw
ffe02679:	8f4872        	s8i	a7, a8, 143
    rSDC_COMMAND_STATUS = 0x51;
ffe0267c:	165c      	movi.n	a6, 81
ffe0267e:	0020c0        	memw
ffe02681:	0b4262        	s8i	a6, a2, 11
    rSDC_FEATURE_ERROR = 4;
ffe02684:	450c      	movi.n	a5, 4
ffe02686:	0020c0        	memw
ffe02689:	054252        	s8i	a5, a2, 5
    rSDC_FISDirInt |= BIT_SDC_FIS_INTFLAG;
ffe0268c:	240c      	movi.n	a4, 2
ffe0268e:	0020c0        	memw
ffe02691:	2b0232        	l8ui	a3, a2, 43
ffe02694:	203340        	or	a3, a3, a4
ffe02697:	0020c0        	memw
ffe0269a:	2b4232        	s8i	a3, a2, 43
Modify History:
20090528    Yao Chen    001: first created
===================================================================*/
void HAL_SataSendRegD2HFIS(void)
{
    rSDC_IOControl = BIT_SDC_IOCTRL_SENDREGD2H_FIS;
ffe0269d:	80af02        	movi	a0, -128
ffe026a0:	0020c0        	memw
ffe026a3:	2c4202        	s8i	a0, a2, 44

ffe026a6 <HAL_SataSendAbortStatus+0x46>:
    Lock_ShadowRegister();
    rSDC_COMMAND_STATUS = 0x51;
    rSDC_FEATURE_ERROR = 4;
    rSDC_FISDirInt |= BIT_SDC_FIS_INTFLAG;
    HAL_SataSendRegD2HFIS();
    while ( FALSE == HAL_SataIsFISXferAvailable() );
ffe026a6:	015745        	call0	ffe03c1c <HAL_SataIsFISXferAvailable>
ffe026a9:	ff9216        	beqz	a2, ffe026a6 <HAL_SataSendAbortStatus+0x46>
    rSDC_FEATURE_ERROR = 0;
ffe026ac:	040c      	movi.n	a4, 0
ffe026ae:	0020c0        	memw
ffe026b1:	fcb231        	l32r	a3, ffe0197c <_bss_table_end>
ffe026b4:	054342        	s8i	a4, a3, 5
    rSDC_COMMAND_STATUS = 0x50;
ffe026b7:	025c      	movi.n	a2, 80
ffe026b9:	0020c0        	memw
ffe026bc:	0b4322        	s8i	a2, a3, 11
    UnLock_ShadowRegister();
ffe026bf:	f7a002        	movi	a0, 247
ffe026c2:	0020c0        	memw
ffe026c5:	fcaeb1        	l32r	a11, ffe01980 <_bss_table_end+0x4>
ffe026c8:	8f0ba2        	l8ui	a10, a11, 143
ffe026cb:	10aa00        	and	a10, a10, a0
ffe026ce:	0020c0        	memw
ffe026d1:	8f4ba2        	s8i	a10, a11, 143

    return;
ffe026d4:	0108      	l32i.n	a0, a1, 0
ffe026d6:	10c112        	addi	a1, a1, 16
ffe026d9:	f00d      	ret.n

ffe026db <HAL_SataSendAbortStatus+0x7b>:
	...

ffe026dc <L1_SataCheckPIOMultipleEnable>:
Modify:
****************************************************************************/
BOOL DRAM_ATTR L1_SataCheckPIOMultipleEnable(HCMD *pCurCmd)
{
    BOOL bResult;
    U8 ucCmdCode = pCurCmd->ucCmdCode;
ffe026dc:	040222        	l8ui	a2, a2, 4

    switch ( ucCmdCode ) {
ffe026df:	932c      	movi.n	a3, 41
ffe026e1:	101237        	beq	a2, a3, ffe026f5 <L1_SataCheckPIOMultipleEnable+0x19>
ffe026e4:	943c      	movi.n	a4, 57
ffe026e6:	0b1247        	beq	a2, a4, ffe026f5 <L1_SataCheckPIOMultipleEnable+0x19>
ffe026e9:	c5a052        	movi	a5, 197
ffe026ec:	0d2527        	blt	a5, a2, ffe026fd <L1_SataCheckPIOMultipleEnable+0x21>
ffe026ef:	c4a062        	movi	a6, 196
ffe026f2:	072267        	blt	a2, a6, ffe026fd <L1_SataCheckPIOMultipleEnable+0x21>
        /* For commands implementing PIO data in/out protocol, we shall check the multiple enable flag. */
        case ATA_CMD_READ_MULTIPLE:
        case ATA_CMD_WRITE_MULTIPLE:
        case ATA_CMD_READ_MULTIPLE_EXT:
        case ATA_CMD_WRITE_MULTIPLE_EXT:
            bResult = g_bMultipleDataOpen;
ffe026f5:	fca321        	l32r	a2, ffe01984 <_bss_table_end+0x8>
ffe026f8:	382222        	l32i	a2, a2, 224
        default:
            bResult = SUCCESS;
            break;
    }

    return bResult;
ffe026fb:	f00d      	ret.n

ffe026fd <L1_SataCheckPIOMultipleEnable+0x21>:
            break;

            /* For commands not implementing PIO data in/out protocol, we shall not perform the check. */
        default:
            bResult = SUCCESS;
            break;
ffe026fd:	120c      	movi.n	a2, 1
    }

    return bResult;
ffe026ff:	f00d      	ret.n

ffe02701 <L1_SataCheckPIOMultipleEnable+0x25>:
ffe02701:	000000                                        ...

ffe02704 <L1_TaskScheduleNoneData>:
    return g_ucL1returnflag;
}


BOOL L1_TaskScheduleNoneData(HCMD* pCurHCMD)
{
ffe02704:	90a0a2        	movi	a10, 144
ffe02707:	d0c112        	addi	a1, a1, -48
ffe0270a:	3109      	s32i.n	a0, a1, 12
ffe0270c:	51d9      	s32i.n	a13, a1, 20
    BOOL bRtn = TRUE;
    
    switch( pCurHCMD->ucCmdCode )
ffe0270e:	040262        	l8ui	a6, a2, 4
    return g_ucL1returnflag;
}


BOOL L1_TaskScheduleNoneData(HCMD* pCurHCMD)
{
ffe02711:	41c9      	s32i.n	a12, a1, 16
ffe02713:	71f9      	s32i.n	a15, a1, 28
ffe02715:	61e9      	s32i.n	a14, a1, 24
ffe02717:	1f0c      	movi.n	a15, 1
ffe02719:	0e0c      	movi.n	a14, 0
ffe0271b:	fc98c1        	l32r	a12, ffe0197c <_bss_table_end>
    BOOL bRtn = TRUE;
    
    switch( pCurHCMD->ucCmdCode )
ffe0271e:	4f16a7        	beq	a6, a10, ffe02771 <L1_TaskScheduleNoneData+0x6d>
ffe02721:	fc98d1        	l32r	a13, ffe01984 <_bss_table_end+0x8>
ffe02724:	00a132        	movi	a3, 0x100
ffe02727:	c6a042        	movi	a4, 198
ffe0272a:	511647        	beq	a6, a4, ffe0277f <L1_TaskScheduleNoneData+0x7b>
ffe0272d:	ffa002        	movi	a0, 255
ffe02730:	8139      	s32i.n	a3, a1, 32
ffe02732:	eca052        	movi	a5, 236
ffe02735:	c05650        	sub	a5, a6, a5
ffe02738:	1bb516        	beqz	a5, ffe028f7 <L1_TaskScheduleNoneData+0x1f3>
ffe0273b:	efa082        	movi	a8, 239
ffe0273e:	6c1687        	beq	a6, a8, ffe027ae <L1_TaskScheduleNoneData+0xaa>
ffe02741:	c09600        	sub	a9, a6, a0
ffe02744:	0cf916        	beqz	a9, ffe02817 <L1_TaskScheduleNoneData+0x113>
    case ATA_CMD_RECEIVE_FPDMA_QUEUED:
        bRtn = L1_HandleNCQReceiveFPDMA(pCurHCMD);
        break;
*/
    default:    //unsupported commands
        if( FALSE == HAL_SataIsFISXferAvailable() )
ffe02747:	014d45        	call0	ffe03c1c <HAL_SataIsFISXferAvailable>
ffe0274a:	c2ac      	beqz.n	a2, ffe0277a <L1_TaskScheduleNoneData+0x76>
            return FALSE;        

        HAL_SataSendAbortStatus();
ffe0274c:	fff105        	call0	ffe02660 <HAL_SataSendAbortStatus>

ffe0274f <L1_TaskScheduleNoneData+0x4b>:
        break;
    }

    if (TRUE == bRtn)
    {
        rSDC_FW_Ctrl  |= CLR_PIOCMD_DATA;   //VT3514, clear small busy
ffe0274f:	0020c0        	memw
ffe02752:	4e0ca2        	l8ui	a10, a12, 78
ffe02755:	8b0c      	movi.n	a11, 8
ffe02757:	20aab0        	or	a10, a10, a11
ffe0275a:	0020c0        	memw
ffe0275d:	4e4ca2        	s8i	a10, a12, 78
        //HAL_SetSendSDBFISReady(pCurHCMD->ucCmdTag);//VT3514, allow hardware reporting good status to host 
    }
    
    return    bRtn;
ffe02760:	120c      	movi.n	a2, 1
ffe02762:	41c8      	l32i.n	a12, a1, 16
ffe02764:	51d8      	l32i.n	a13, a1, 20
ffe02766:	61e8      	l32i.n	a14, a1, 24
ffe02768:	71f8      	l32i.n	a15, a1, 28
ffe0276a:	3108      	l32i.n	a0, a1, 12
ffe0276c:	30c112        	addi	a1, a1, 48
ffe0276f:	f00d      	ret.n

ffe02771 <L1_TaskScheduleNoneData+0x6d>:
ffe02771:	fc83d1        	l32r	a13, ffe01980 <_bss_table_end+0x4>
    case    ATA_CMD_SET_MULTIPLE_MODE:
        L1_SataCmdSetMultipleMode();
        break;

    case    ATA_CMD_EXECUTE_DEVICE_DIAGNOSTIC:
        if( FALSE == HAL_SataIsFISXferAvailable() )
ffe02774:	014a45        	call0	ffe03c1c <HAL_SataIsFISXferAvailable>
ffe02777:	0ee256        	bnez	a2, ffe02869 <L1_TaskScheduleNoneData+0x165>
        bRtn = L1_HandleNCQReceiveFPDMA(pCurHCMD);
        break;
*/
    default:    //unsupported commands
        if( FALSE == HAL_SataIsFISXferAvailable() )
            return FALSE;        
ffe0277a:	020c      	movi.n	a2, 0
    case ATA_CMD_RECEIVE_FPDMA_QUEUED:
        bRtn = L1_HandleNCQReceiveFPDMA(pCurHCMD);
        break;
*/
    default:    //unsupported commands
        if( FALSE == HAL_SataIsFISXferAvailable() )
ffe0277c:	fff886        	j	ffe02762 <L1_TaskScheduleNoneData+0x5e>

ffe0277f <L1_TaskScheduleNoneData+0x7b>:
    U8    sectorCount;
    U8     ShiftCount;
    BOOL bSetMultipleError = TRUE;

    //update identify device data;
    sectorCount = rSDC_SECCNT;
ffe0277f:	0020c0        	memw
    if( sectorCount <= (U8) (g_pSataIdentifyData[47] & 0xff))
ffe02782:	292d62        	l32i	a6, a13, 164
    U8    sectorCount;
    U8     ShiftCount;
    BOOL bSetMultipleError = TRUE;

    //update identify device data;
    sectorCount = rSDC_SECCNT;
ffe02785:	060c02        	l8ui	a0, a12, 6
    if( sectorCount <= (U8) (g_pSataIdentifyData[47] & 0xff))
ffe02788:	5e0642        	l8ui	a4, a6, 94
ffe0278b:	6c3407        	bltu	a4, a0, ffe027fb <L1_TaskScheduleNoneData+0xf7>
    {
        if(sectorCount == 0)
ffe0278e:	15d016        	beqz	a0, ffe028ef <L1_TaskScheduleNoneData+0x1eb>
        }

        else
        {    
            ShiftCount = 0;
            while(ShiftCount < 5)
ffe02791:	050c      	movi.n	a5, 0
ffe02793:	570c      	movi.n	a7, 5
ffe02795:	10a776        	loopgtz	a7, ffe027a9 <L1_TaskScheduleNoneData+0xa5>
            {
                if((1<<ShiftCount)  == sectorCount)
ffe02798:	401500        	ssl	a5
ffe0279b:	a18f00        	sll	a8, a15
ffe0279e:	c08080        	sub	a8, a0, a8
ffe027a1:	142816        	beqz	a8, ffe028e7 <L1_TaskScheduleNoneData+0x1e3>
                    g_bMultipleDataOpen = TRUE;
                    g_pSataIdentifyData[59] = (0x0100 | sectorCount);
                    bSetMultipleError = FALSE;
                    break;
                }
                ShiftCount ++;
ffe027a4:	551b      	addi.n	a5, a5, 1
ffe027a6:	745050        	extui	a5, a5, 0, 8

ffe027a9 <L1_TaskScheduleNoneData+0xa5>:
        }

        else
        {    
            ShiftCount = 0;
            while(ShiftCount < 5)
ffe027a9:	100c      	movi.n	a0, 1
ffe027ab:	001386        	j	ffe027fd <L1_TaskScheduleNoneData+0xf9>

ffe027ae <L1_TaskScheduleNoneData+0xaa>:
{
    U8 trans_mode;
    BOOL    berror = FALSE;
    U8 feature_code;

    feature_code = rSDC_FEATURE_ERROR;
ffe027ae:	0020c0        	memw
ffe027b1:	050c32        	l8ui	a3, a12, 5
ffe027b4:	fec362        	addi	a6, a3, -2
ffe027b7:	433616        	beqz	a6, ffe02bee <L1_TaskScheduleNoneData+0x4ea>
ffe027ba:	fdc372        	addi	a7, a3, -3
ffe027bd:	586716        	beqz	a7, ffe02d47 <L1_TaskScheduleNoneData+0x643>
ffe027c0:	fbc382        	addi	a8, a3, -5
ffe027c3:	440816        	beqz	a8, ffe02c07 <L1_TaskScheduleNoneData+0x503>
ffe027c6:	f0c392        	addi	a9, a3, -16
ffe027c9:	5b6916        	beqz	a9, ffe02d83 <L1_TaskScheduleNoneData+0x67f>
    switch(feature_code)
ffe027cc:	82a0b2        	movi	a11, 130
ffe027cf:	c0b3b0        	sub	a11, a3, a11
ffe027d2:	5e1b16        	beqz	a11, ffe02db7 <L1_TaskScheduleNoneData+0x6b3>
ffe027d5:	85a0f2        	movi	a15, 133
ffe027d8:	c0f3f0        	sub	a15, a3, a15
ffe027db:	423f16        	beqz	a15, ffe02c02 <L1_TaskScheduleNoneData+0x4fe>
ffe027de:	c003a0        	sub	a0, a3, a10
ffe027e1:	48b016        	beqz	a0, ffe02c70 <L1_TaskScheduleNoneData+0x56c>
            break;
        }
        break;

    default :
        DBG_Printf("[set features]: invalid feature code 0x%x.\n", feature_code);
ffe027e4:	fc8221        	l32r	a2, ffe019ec <_bss_table_end+0x70>
ffe027e7:	026d85        	call0	ffe04ec0 <dbg_printf>
        berror = TRUE;
        break;
ffe027ea:	100c      	movi.n	a0, 1
    }

    if( TRUE == berror )
ffe027ec:	6d1066        	bnei	a0, 1, ffe0285d <L1_TaskScheduleNoneData+0x159>
    {
        while( FAIL == HAL_SataIsFISXferAvailable() );
ffe027ef:	0142c5        	call0	ffe03c1c <HAL_SataIsFISXferAvailable>
ffe027f2:	ff9216        	beqz	a2, ffe027ef <L1_TaskScheduleNoneData+0xeb>
        HAL_SataSendAbortStatus();    
ffe027f5:	ffe685        	call0	ffe02660 <HAL_SataSendAbortStatus>
ffe027f8:	ffd4c6        	j	ffe0274f <L1_TaskScheduleNoneData+0x4b>

ffe027fb <L1_TaskScheduleNoneData+0xf7>:
        }

        else
        {    
            ShiftCount = 0;
            while(ShiftCount < 5)
ffe027fb:	100c      	movi.n	a0, 1
ffe027fd:	a0cc      	bnez.n	a0, ffe0280b <L1_TaskScheduleNoneData+0x107>
        }
    }

    if(bSetMultipleError == FALSE)
    {
        while( FAIL == HAL_SataIsFISXferAvailable() );
ffe027ff:	0141c5        	call0	ffe03c1c <HAL_SataIsFISXferAvailable>
ffe02802:	ff9216        	beqz	a2, ffe027ff <L1_TaskScheduleNoneData+0xfb>
        HAL_SataSendSuccessStatus();
ffe02805:	ff6285        	call0	ffe01e30 <HAL_SataSendSuccessStatus>
ffe02808:	ffd0c6        	j	ffe0274f <L1_TaskScheduleNoneData+0x4b>

ffe0280b <L1_TaskScheduleNoneData+0x107>:
    }
    else
    {
        //Do not support the transfer count set by host, abort this command
        while( FAIL == HAL_SataIsFISXferAvailable() );
ffe0280b:	014105        	call0	ffe03c1c <HAL_SataIsFISXferAvailable>
ffe0280e:	ff9216        	beqz	a2, ffe0280b <L1_TaskScheduleNoneData+0x107>
        HAL_SataSendAbortStatus();
ffe02811:	ffe4c5        	call0	ffe02660 <HAL_SataSendAbortStatus>
        L1_SataCmdSetFeatures();
        break;

    case    ATA_CMD_SET_MULTIPLE_MODE:
        L1_SataCmdSetMultipleMode();
        break;
ffe02814:	ffcdc6        	j	ffe0274f <L1_TaskScheduleNoneData+0x4b>

ffe02817 <L1_TaskScheduleNoneData+0x113>:

BOOL DRAM_ATTR L1_SataCmdVenderDefine(void)
{
    U8 vd_fea;
    
    vd_fea = rSDC_FEATURE_ERROR;
ffe02817:	0020c0        	memw
ffe0281a:	050ce2        	l8ui	a14, a12, 5
    DBG_Printf("[vencmd]: vencmd code = 0x%x. \n", vd_fea);
ffe0281d:	fc7421        	l32r	a2, ffe019f0 <_bss_table_end+0x74>
ffe02820:	0e3d      	mov.n	a3, a14
ffe02822:	0269c5        	call0	ffe04ec0 <dbg_printf>
ffe02825:	c0a022        	movi	a2, 192
ffe02828:	c02e20        	sub	a2, a14, a2
ffe0282b:	3e8216        	beqz	a2, ffe02c17 <L1_TaskScheduleNoneData+0x513>
    switch( vd_fea )
ffe0282e:	c1a032        	movi	a3, 193
ffe02831:	c03e30        	sub	a3, a14, a3
ffe02834:	4ad316        	beqz	a3, ffe02ce5 <L1_TaskScheduleNoneData+0x5e1>
ffe02837:	c4a042        	movi	a4, 196
ffe0283a:	c04e40        	sub	a4, a14, a4
ffe0283d:	463416        	beqz	a4, ffe02ca4 <L1_TaskScheduleNoneData+0x5a0>
ffe02840:	c5a052        	movi	a5, 197
ffe02843:	c05e50        	sub	a5, a14, a5
ffe02846:	585516        	beqz	a5, ffe02dcf <L1_TaskScheduleNoneData+0x6cb>
            break;
        case VD_READ_STATUS:
            satap_vd_read_status();
            break;
        default:
            DBG_Printf("[vencmd]: invalid feature 0x%x.\n", vd_fea);
ffe02849:	0e3d      	mov.n	a3, a14
ffe0284b:	fc6a21        	l32r	a2, ffe019f4 <_bss_table_end+0x78>
ffe0284e:	026705        	call0	ffe04ec0 <dbg_printf>
            while( FALSE == HAL_SataIsFISXferAvailable() );
ffe02851:	013c85        	call0	ffe03c1c <HAL_SataIsFISXferAvailable>
ffe02854:	ff9216        	beqz	a2, ffe02851 <L1_TaskScheduleNoneData+0x14d>
            HAL_SataSendAbortStatus();
ffe02857:	ffe085        	call0	ffe02660 <HAL_SataSendAbortStatus>
ffe0285a:	ffbc46        	j	ffe0274f <L1_TaskScheduleNoneData+0x4b>

ffe0285d <L1_TaskScheduleNoneData+0x159>:
        while( FAIL == HAL_SataIsFISXferAvailable() );
        HAL_SataSendAbortStatus();    
    }
    else
    {
        while( FAIL == HAL_SataIsFISXferAvailable() );
ffe0285d:	013bc5        	call0	ffe03c1c <HAL_SataIsFISXferAvailable>
ffe02860:	ff9216        	beqz	a2, ffe0285d <L1_TaskScheduleNoneData+0x159>
        HAL_SataSendSuccessStatus();    
ffe02863:	ff5cc5        	call0	ffe01e30 <HAL_SataSendSuccessStatus>
        L1_SataCmdIdentifyDevice();
        break;

    case    ATA_CMD_SET_FEATURES:
        L1_SataCmdSetFeatures();
        break;
ffe02866:	ffb946        	j	ffe0274f <L1_TaskScheduleNoneData+0x4b>

ffe02869 <L1_TaskScheduleNoneData+0x165>:
    return;
}

void HAL_SataSignatureSendGoodStatus(void)
{
    Lock_ShadowRegister();
ffe02869:	0020c0        	memw
ffe0286c:	8f0da2        	l8ui	a10, a13, 143
ffe0286f:	8b0c      	movi.n	a11, 8
ffe02871:	20aab0        	or	a10, a10, a11
ffe02874:	0020c0        	memw
ffe02877:	8f4da2        	s8i	a10, a13, 143
    rSDC_COMMAND_STATUS = 0x50;
ffe0287a:	0020c0        	memw
ffe0287d:	095c      	movi.n	a9, 80
ffe0287f:	0b4c92        	s8i	a9, a12, 11
    rSDC_FEATURE_ERROR = 1;
ffe02882:	0020c0        	memw
ffe02885:	054cf2        	s8i	a15, a12, 5
    rSDC_LBALOW = 1;
ffe02888:	0020c0        	memw
ffe0288b:	074cf2        	s8i	a15, a12, 7
    rSDC_LBAMID = 0;
ffe0288e:	0020c0        	memw
ffe02891:	084ce2        	s8i	a14, a12, 8
    rSDC_LBAHIGH = 0;
ffe02894:	0020c0        	memw
ffe02897:	094ce2        	s8i	a14, a12, 9
    rSDC_SECCNT = 1;
ffe0289a:	0020c0        	memw
ffe0289d:	064cf2        	s8i	a15, a12, 6
    rSDC_DEVICE_HEAD = 0;
ffe028a0:	0020c0        	memw
ffe028a3:	0a4ce2        	s8i	a14, a12, 10
    rSDC_FISDirInt |= BIT_SDC_FIS_INTFLAG;
ffe028a6:	0020c0        	memw
ffe028a9:	2b0c72        	l8ui	a7, a12, 43
ffe028ac:	280c      	movi.n	a8, 2
ffe028ae:	207780        	or	a7, a7, a8
ffe028b1:	0020c0        	memw
ffe028b4:	2b4c72        	s8i	a7, a12, 43
Modify History:
20090528    Yao Chen    001: first created
===================================================================*/
void HAL_SataSendRegD2HFIS(void)
{
    rSDC_IOControl = BIT_SDC_IOCTRL_SENDREGD2H_FIS;
ffe028b7:	80af62        	movi	a6, -128
ffe028ba:	0020c0        	memw
ffe028bd:	2c4c62        	s8i	a6, a12, 44
    rSDC_LBAHIGH = 0;
    rSDC_SECCNT = 1;
    rSDC_DEVICE_HEAD = 0;
    rSDC_FISDirInt |= BIT_SDC_FIS_INTFLAG;
    HAL_SataSendRegD2HFIS();
    while ( FALSE == HAL_SataIsFISXferAvailable() );
ffe028c0:	013585        	call0	ffe03c1c <HAL_SataIsFISXferAvailable>
ffe028c3:	ff9216        	beqz	a2, ffe028c0 <L1_TaskScheduleNoneData+0x1bc>
    rSDC_FEATURE_ERROR = 0;
ffe028c6:	0020c0        	memw
ffe028c9:	054ce2        	s8i	a14, a12, 5
    UnLock_ShadowRegister();
ffe028cc:	0020c0        	memw
ffe028cf:	8f0df2        	l8ui	a15, a13, 143
ffe028d2:	f7a002        	movi	a0, 247
ffe028d5:	10ff00        	and	a15, a15, a0
ffe028d8:	0020c0        	memw
ffe028db:	8f4df2        	s8i	a15, a13, 143

    //send good signature
  //  HAL_SataSendGoodStatus();
    HAL_SataSignatureSendGoodStatus();

    DBG_Printf("L1_SataCmdExecuteDeviceDiagnostic end\n");
ffe028de:	fc4621        	l32r	a2, ffe019f8 <_bss_table_end+0x7c>
ffe028e1:	025dc5        	call0	ffe04ec0 <dbg_printf>
ffe028e4:	ff99c6        	j	ffe0274f <L1_TaskScheduleNoneData+0x4b>

ffe028e7 <L1_TaskScheduleNoneData+0x1e3>:
ffe028e7:	0fed      	mov.n	a14, a15
            while(ShiftCount < 5)
            {
                if((1<<ShiftCount)  == sectorCount)
                {
                    g_bMultipleDataOpen = TRUE;
                    g_pSataIdentifyData[59] = (0x0100 | sectorCount);
ffe028e9:	230034        	insbits	a3, a0, 0, 7
ffe028ec:	3b5632        	s16i	a3, a6, 118
    sectorCount = rSDC_SECCNT;
    if( sectorCount <= (U8) (g_pSataIdentifyData[47] & 0xff))
    {
        if(sectorCount == 0)
        {
            g_bMultipleDataOpen = FALSE;
ffe028ef:	386de2        	s32i	a14, a13, 224
ffe028f2:	000c      	movi.n	a0, 0
ffe028f4:	ffc146        	j	ffe027fd <L1_TaskScheduleNoneData+0xf9>

ffe028f7 <L1_TaskScheduleNoneData+0x1f3>:
Others      :
Modify      :
****************************************************************************/
void DRAM_ATTR L1_SataCmdIdentifyDevice()
{
    DBG_Printf("g_pSataIdentifyData: 0x%x\n",g_pSataIdentifyData);
ffe028f7:	fc4121        	l32r	a2, ffe019fc <_bss_table_end+0x80>
ffe028fa:	292d32        	l32i	a3, a13, 164
ffe028fd:	025c05        	call0	ffe04ec0 <dbg_printf>
ffe02900:	8168      	l32i.n	a6, a1, 32

    ulSum = 0;
    pucIdentifyData = (U8*)g_pSataIdentifyData;
    g_pSataIdentifyData[255] = 0x00A5;

    for (ulLoop = 0; ulLoop < 511; ulLoop++)
ffe02902:	000c      	movi.n	a0, 0
ffe02904:	ffa142        	movi	a4, 0x1ff
    U8  ucSum;
    U32 ulSum;
    U32 ulLoop;

    ulSum = 0;
    pucIdentifyData = (U8*)g_pSataIdentifyData;
ffe02907:	292d52        	l32i	a5, a13, 164
****************************************************************************/
void DRAM_ATTR L1_SataCmdIdentifyDevice()
{
    DBG_Printf("g_pSataIdentifyData: 0x%x\n",g_pSataIdentifyData);

    L1_SataCmdSetIdentifyDataCheckSum();
ffe0290a:	a5a032        	movi	a3, 165
    U32 ulSum;
    U32 ulLoop;

    ulSum = 0;
    pucIdentifyData = (U8*)g_pSataIdentifyData;
    g_pSataIdentifyData[255] = 0x00A5;
ffe0290d:	ff5532        	s16i	a3, a5, 0x1fe

    for (ulLoop = 0; ulLoop < 511; ulLoop++)
ffe02910:	052d      	mov.n	a2, a5
ffe02912:	06a476        	loopgtz	a4, ffe0291c <L1_TaskScheduleNoneData+0x218>
    {
        ulSum += pucIdentifyData[ulLoop];
ffe02915:	000272        	l8ui	a7, a2, 0

    ulSum = 0;
    pucIdentifyData = (U8*)g_pSataIdentifyData;
    g_pSataIdentifyData[255] = 0x00A5;

    for (ulLoop = 0; ulLoop < 511; ulLoop++)
ffe02918:	221b      	addi.n	a2, a2, 1
    {
        ulSum += pucIdentifyData[ulLoop];
ffe0291a:	070a      	add.n	a0, a7, a0

ffe0291c <L1_TaskScheduleNoneData+0x218>:
ffe0291c:	9159      	s32i.n	a5, a1, 36
    }

    ucSum = (ulSum & 0xFF);
    g_pSataIdentifyData[255] |= (0xFF - ucSum + 1) << 8;
ffe0291e:	c08600        	sub	a8, a6, a0

    DBG_Printf("g_pSataIdentifyData[255] = 0x%x\n", g_pSataIdentifyData[255]);
ffe02921:	fc3721        	l32r	a2, ffe01a00 <_bss_table_end+0x84>
    {
        ulSum += pucIdentifyData[ulLoop];
    }

    ucSum = (ulSum & 0xFF);
    g_pSataIdentifyData[255] |= (0xFF - ucSum + 1) << 8;
ffe02924:	e38834        	insbits	a3, a8, 8, 31
ffe02927:	ff5532        	s16i	a3, a5, 0x1fe

    DBG_Printf("g_pSataIdentifyData[255] = 0x%x\n", g_pSataIdentifyData[255]);
ffe0292a:	f43030        	extui	a3, a3, 0, 16
ffe0292d:	025905        	call0	ffe04ec0 <dbg_printf>
ffe02930:	092122        	l32i	a2, a1, 36

    ulSum = 0;
    for (ulLoop = 0; ulLoop < 512; ulLoop++)
ffe02933:	00a002        	movi	a0, 0
ffe02936:	00a292        	movi	a9, 0x200
ffe02939:	06a976        	loopgtz	a9, ffe02943 <L1_TaskScheduleNoneData+0x23f>
    {
        ulSum += pucIdentifyData[ulLoop];
ffe0293c:	0002a2        	l8ui	a10, a2, 0
    g_pSataIdentifyData[255] |= (0xFF - ucSum + 1) << 8;

    DBG_Printf("g_pSataIdentifyData[255] = 0x%x\n", g_pSataIdentifyData[255]);

    ulSum = 0;
    for (ulLoop = 0; ulLoop < 512; ulLoop++)
ffe0293f:	221b      	addi.n	a2, a2, 1
    {
        ulSum += pucIdentifyData[ulLoop];
ffe02941:	0a0a      	add.n	a0, a10, a0
    }

    if ((ulSum & 0xFF) == 0)
ffe02943:	743000        	extui	a3, a0, 0, 8
ffe02946:	73cc      	bnez.n	a3, ffe02951 <L1_TaskScheduleNoneData+0x24d>
    {
        DBG_Printf("IdentifyDataCheckSum OK!!\n");
ffe02948:	fc2f21        	l32r	a2, ffe01a04 <_bss_table_end+0x88>
ffe0294b:	025745        	call0	ffe04ec0 <dbg_printf>
ffe0294e:	000146        	j	ffe02957 <L1_TaskScheduleNoneData+0x253>

ffe02951 <L1_TaskScheduleNoneData+0x24d>:
    }
    else
    {
        DBG_Printf("IdentifyDataCheckSum (ulSum & 0xFF) = %d ERROR!!\n", ulSum & 0xFF);
ffe02951:	fc2d21        	l32r	a2, ffe01a08 <_bss_table_end+0x8c>
ffe02954:	025685        	call0	ffe04ec0 <dbg_printf>
{
    volatile SATA_DSG *pCurDSG; //[P] volatile
    U8    ucDSGId;
    U32   ulBuffMapValue;

    if (ucSecCnt == 0 || ulStartDRamAddr < DRAM_START_ADDRESS)
ffe02957:	fc2db1        	l32r	a11, ffe01a0c <_bss_table_end+0x90>
****************************************************************************/
void DRAM_ATTR L1_SataCmdIdentifyDevice()
{
    DBG_Printf("g_pSataIdentifyData: 0x%x\n",g_pSataIdentifyData);

    L1_SataCmdSetIdentifyDataCheckSum();
ffe0295a:	292d02        	l32i	a0, a13, 164
ffe0295d:	0109      	s32i.n	a0, a1, 0
{
    volatile SATA_DSG *pCurDSG; //[P] volatile
    U8    ucDSGId;
    U32   ulBuffMapValue;

    if (ucSecCnt == 0 || ulStartDRamAddr < DRAM_START_ADDRESS)
ffe0295f:	083b07        	bltu	a11, a0, ffe0296b <L1_TaskScheduleNoneData+0x267>
    {
        DBG_Printf("L1_SataHandleSpecialPIODataIn Input ERROR!\n");
ffe02962:	fc2b21        	l32r	a2, ffe01a10 <_bss_table_end+0x94>
ffe02965:	025585        	call0	ffe04ec0 <dbg_printf>
        DBG_Getch();
ffe02968:	0227c5        	call0	ffe04be8 <DBG_Getch>
    }

    ucDSGId = L1_GetSpecialReadDSG();
ffe0296b:	ff6ac5        	call0	ffe02018 <L1_GetSpecialReadDSG>
ffe0296e:	1129      	s32i.n	a2, a1, 4
    if (INVALID_2F == ucDSGId)
ffe02970:	74d020        	extui	a13, a2, 0, 8
ffe02973:	ffa022        	movi	a2, 255
ffe02976:	089d27        	bne	a13, a2, ffe02982 <L1_TaskScheduleNoneData+0x27e>
    {
        DBG_Printf("L1_SataHandleSpecialPIODataIn No free ReadPRD ERROR!\n");
ffe02979:	fc2621        	l32r	a2, ffe01a14 <_bss_table_end+0x98>
ffe0297c:	025405        	call0	ffe04ec0 <dbg_printf>
        DBG_Getch();
ffe0297f:	022685        	call0	ffe04be8 <DBG_Getch>
    }
    
    pCurDSG = (volatile SATA_DSG *)HAL_GetSataDsgAddr(ucDSGId);//&g_pSataReadPRD[ucRPRDId];
ffe02982:	0d2d      	mov.n	a2, a13
ffe02984:	ff6705        	call0	ffe01ff8 <HAL_GetSataDsgAddr>
ffe02987:	2129      	s32i.n	a2, a1, 8

    // clear PRD area to 0
    HAL_MemZero((U32*)pCurDSG, DSG_SIZE_DW);
ffe02989:	830c      	movi.n	a3, 8
ffe0298b:	01f785        	call0	ffe04904 <HAL_MemZero>
    /*========================================================================*/
    /* DW1: Transfer control info                                             */
    /*========================================================================*/
    pCurDSG->XferCtrlInfo.Reserved       = 0;
    pCurDSG->XferCtrlInfo.DummyDataEn    = BIT_DISABLE;
    pCurDSG->CacheStsLocSel = CS_IN_SRAM;
ffe0298e:	0e0d      	mov.n	a0, a14
    pCurDSG->AtaProtInfo.IsWriteCmd      = BIT_FALSE;
    pCurDSG->AtaProtInfo.EcpEn           = BIT_DISABLE;
    pCurDSG->AtaProtInfo.EcpKeySel       = 0;
    pCurDSG->AtaProtInfo.IsNonDataCmd    = BIT_FALSE;
    pCurDSG->AtaProtInfo.FwAckHostEn     = BIT_DISABLE;
    pCurDSG->AtaProtInfo.ProtSel         = PROT_PIO;
ffe02990:	0e5d      	mov.n	a5, a14
    HAL_MemZero((U32*)pCurDSG, DSG_SIZE_DW);

    /*========================================================================*/
    /* DW0: ata prot info                                                     */
    /*========================================================================*/
    pCurDSG->AtaProtInfo.AutoActiveEn    = BIT_ENABLE;
ffe02992:	fc21f1        	l32r	a15, ffe01a18 <_bss_table_end+0x9c>
ffe02995:	fc0831        	l32r	a3, ffe019b8 <_bss_table_end+0x3c>
ffe02998:	fc0581        	l32r	a8, ffe019ac <_bss_table_end+0x30>
ffe0299b:	fc1141        	l32r	a4, ffe019e0 <_bss_table_end+0x64>
ffe0299e:	fc0f61        	l32r	a6, ffe019dc <_bss_table_end+0x60>
ffe029a1:	fc1e91        	l32r	a9, ffe01a1c <_bss_table_end+0xa0>
ffe029a4:	fc09a1        	l32r	a10, ffe019c8 <_bss_table_end+0x4c>
    pCurDSG->XferCtrlInfo.BuffLen        = ucSecCnt;
    pCurDSG->XferCtrlInfo.BuffMapId      = BUFMAP_ID(ucDSGId);
    pCurDSG->XferCtrlInfo.BuffOffset     = 0;
    pCurDSG->XferCtrlInfo.CacheStsEn     = BIT_DISABLE;
    pCurDSG->XferCtrlInfo.BuffMapEn      = BIT_ENABLE;
    pCurDSG->XferCtrlInfo.Eot            = BIT_TRUE;
ffe029a7:	09bd      	mov.n	a11, a9
    HAL_MemZero((U32*)pCurDSG, DSG_SIZE_DW);

    /*========================================================================*/
    /* DW0: ata prot info                                                     */
    /*========================================================================*/
    pCurDSG->AtaProtInfo.AutoActiveEn    = BIT_ENABLE;
ffe029a9:	0020c0        	memw
ffe029ac:	2178      	l32i.n	a7, a1, 8
ffe029ae:	0728      	l32i.n	a2, a7, 0
ffe029b0:	102280        	and	a2, a2, a8
ffe029b3:	2022f0        	or	a2, a2, a15
ffe029b6:	0020c0        	memw
ffe029b9:	0729      	s32i.n	a2, a7, 0
    pCurDSG->AtaProtInfo.IsWriteCmd      = BIT_FALSE;
ffe029bb:	0020c0        	memw
ffe029be:	07f8      	l32i.n	a15, a7, 0
ffe029c0:	10ffa0        	and	a15, a15, a10
ffe029c3:	20ffe0        	or	a15, a15, a14
ffe029c6:	0020c0        	memw
ffe029c9:	07f9      	s32i.n	a15, a7, 0
    pCurDSG->AtaProtInfo.EcpEn           = BIT_DISABLE;
ffe029cb:	fbf721        	l32r	a2, ffe019a8 <_bss_table_end+0x2c>
ffe029ce:	0020c0        	memw
ffe029d1:	07f8      	l32i.n	a15, a7, 0
ffe029d3:	10ff20        	and	a15, a15, a2
ffe029d6:	20ffe0        	or	a15, a15, a14
ffe029d9:	0020c0        	memw
ffe029dc:	07f9      	s32i.n	a15, a7, 0
    pCurDSG->AtaProtInfo.EcpKeySel       = 0;
ffe029de:	fbfb21        	l32r	a2, ffe019cc <_bss_table_end+0x50>
ffe029e1:	0020c0        	memw
ffe029e4:	07f8      	l32i.n	a15, a7, 0
ffe029e6:	10ff20        	and	a15, a15, a2
ffe029e9:	20ffe0        	or	a15, a15, a14
ffe029ec:	0020c0        	memw
ffe029ef:	07f9      	s32i.n	a15, a7, 0
    pCurDSG->AtaProtInfo.IsNonDataCmd    = BIT_FALSE;
ffe029f1:	0020c0        	memw
ffe029f4:	0728      	l32i.n	a2, a7, 0
ffe029f6:	102230        	and	a2, a2, a3
ffe029f9:	2022e0        	or	a2, a2, a14
ffe029fc:	0020c0        	memw
ffe029ff:	0729      	s32i.n	a2, a7, 0
    pCurDSG->AtaProtInfo.FwAckHostEn     = BIT_DISABLE;
ffe02a01:	fbeef1        	l32r	a15, ffe019bc <_bss_table_end+0x40>
ffe02a04:	0020c0        	memw
ffe02a07:	0728      	l32i.n	a2, a7, 0
ffe02a09:	1022f0        	and	a2, a2, a15
ffe02a0c:	2022e0        	or	a2, a2, a14
ffe02a0f:	0020c0        	memw
ffe02a12:	0729      	s32i.n	a2, a7, 0
    pCurDSG->AtaProtInfo.ProtSel         = PROT_PIO;
ffe02a14:	0020c0        	memw
ffe02a17:	07f8      	l32i.n	a15, a7, 0
ffe02a19:	e20f54        	insbits	a5, a15, 0, 30
ffe02a1c:	0020c0        	memw
ffe02a1f:	0759      	s32i.n	a5, a7, 0
    pCurDSG->AtaProtInfo.CmdTag          = 0;
ffe02a21:	fbff21        	l32r	a2, ffe01a20 <_bss_table_end+0xa4>
ffe02a24:	0020c0        	memw
ffe02a27:	07f8      	l32i.n	a15, a7, 0
ffe02a29:	10ff20        	and	a15, a15, a2
ffe02a2c:	20ffe0        	or	a15, a15, a14
ffe02a2f:	0020c0        	memw
ffe02a32:	07f9      	s32i.n	a15, a7, 0
    pCurDSG->AtaProtInfo.CmdXferSecCnt   = ucSecCnt;
ffe02a34:	0020c0        	memw
ffe02a37:	1f0c      	movi.n	a15, 1
ffe02a39:	0057f2        	s16i	a15, a7, 0
    pCurDSG->AtaProtInfo.XferEndIntEn    = SDC_NOT_INT_MCU;
ffe02a3c:	fbdd51        	l32r	a5, ffe019b0 <_bss_table_end+0x34>
ffe02a3f:	0020c0        	memw
ffe02a42:	0728      	l32i.n	a2, a7, 0
ffe02a44:	102250        	and	a2, a2, a5
ffe02a47:	2022e0        	or	a2, a2, a14
ffe02a4a:	0020c0        	memw
ffe02a4d:	0729      	s32i.n	a2, a7, 0

    /*========================================================================*/
    /* DW1: Transfer control info                                             */
    /*========================================================================*/
    pCurDSG->XferCtrlInfo.Reserved       = 0;
ffe02a4f:	fbdd51        	l32r	a5, ffe019c4 <_bss_table_end+0x48>
ffe02a52:	0020c0        	memw
ffe02a55:	1728      	l32i.n	a2, a7, 4
ffe02a57:	102250        	and	a2, a2, a5
ffe02a5a:	2022e0        	or	a2, a2, a14
ffe02a5d:	0020c0        	memw
ffe02a60:	1729      	s32i.n	a2, a7, 4
    pCurDSG->XferCtrlInfo.DummyDataEn    = BIT_DISABLE;
ffe02a62:	0020c0        	memw
ffe02a65:	1758      	l32i.n	a5, a7, 4
ffe02a67:	105580        	and	a5, a5, a8
ffe02a6a:	2055e0        	or	a5, a5, a14
ffe02a6d:	0020c0        	memw
ffe02a70:	1759      	s32i.n	a5, a7, 4
    pCurDSG->CacheStsLocSel = CS_IN_SRAM;
ffe02a72:	0020c0        	memw
ffe02a75:	3728      	l32i.n	a2, a7, 12
ffe02a77:	e20204        	insbits	a0, a2, 0, 30
ffe02a7a:	0020c0        	memw
ffe02a7d:	3709      	s32i.n	a0, a7, 12
#ifdef OTFB_VERSION
    pCurDSG->XferCtrlInfo.DataLocSel     = DATA_IN_SRAM;
ffe02a7f:	fbcd81        	l32r	a8, ffe019b4 <_bss_table_end+0x38>
ffe02a82:	0020c0        	memw
ffe02a85:	1758      	l32i.n	a5, a7, 4
ffe02a87:	1055a0        	and	a5, a5, a10
ffe02a8a:	205580        	or	a5, a5, a8
ffe02a8d:	0020c0        	memw
ffe02a90:	1759      	s32i.n	a5, a7, 4
    pCurDSG->DataAddr        = ulStartDRamAddr - OTFB_START_ADDRESS;
ffe02a92:	fbbd21        	l32r	a2, ffe01988 <_bss_table_end+0xc>
ffe02a95:	0108      	l32i.n	a0, a1, 0
ffe02a97:	002a      	add.n	a0, a0, a2
ffe02a99:	0020c0        	memw
ffe02a9c:	4709      	s32i.n	a0, a7, 16
#else
    pCurDSG->XferCtrlInfo.DataLocSel     = DATA_IN_DRAM;
    pCurDSG->DataAddr        = ulStartDRamAddr - DRAM_START_ADDRESS;
#endif
    pCurDSG->XferCtrlInfo.BuffLen        = ucSecCnt;
ffe02a9e:	0020c0        	memw
ffe02aa1:	0447f2        	s8i	a15, a7, 4
    pCurDSG->XferCtrlInfo.BuffMapId      = BUFMAP_ID(ucDSGId);
ffe02aa4:	0020c0        	memw
ffe02aa7:	17a8      	l32i.n	a10, a7, 4
ffe02aa9:	b20da4        	insbits	a10, a13, 16, 22
ffe02aac:	0020c0        	memw
ffe02aaf:	17a9      	s32i.n	a10, a7, 4
    pCurDSG->XferCtrlInfo.BuffOffset     = 0;
ffe02ab1:	0020c0        	memw
ffe02ab4:	0547e2        	s8i	a14, a7, 5
    pCurDSG->XferCtrlInfo.CacheStsEn     = BIT_DISABLE;
ffe02ab7:	fbc681        	l32r	a8, ffe019d0 <_bss_table_end+0x54>
ffe02aba:	0020c0        	memw
ffe02abd:	1758      	l32i.n	a5, a7, 4
ffe02abf:	105580        	and	a5, a5, a8
ffe02ac2:	2055e0        	or	a5, a5, a14
ffe02ac5:	0020c0        	memw
ffe02ac8:	1759      	s32i.n	a5, a7, 4
    pCurDSG->XferCtrlInfo.BuffMapEn      = BIT_ENABLE;
ffe02aca:	fbc221        	l32r	a2, ffe019d4 <_bss_table_end+0x58>
ffe02acd:	0020c0        	memw
ffe02ad0:	1708      	l32i.n	a0, a7, 4
ffe02ad2:	100030        	and	a0, a0, a3
ffe02ad5:	200020        	or	a0, a0, a2
                   & (0xffffffff >> (31 - ((ucSecCnt - 1) >> SEC_PER_LPN_BITS)));
                   
    HAL_SetBufMapInitValue(pCurDSG->XferCtrlInfo.BuffMapId, ulBuffMapValue);

    HAL_SetLastDataReady(0);
    HAL_UsedSataDSG(ucDSGId);
ffe02ad8:	0d2d      	mov.n	a2, a13
#endif
    pCurDSG->XferCtrlInfo.BuffLen        = ucSecCnt;
    pCurDSG->XferCtrlInfo.BuffMapId      = BUFMAP_ID(ucDSGId);
    pCurDSG->XferCtrlInfo.BuffOffset     = 0;
    pCurDSG->XferCtrlInfo.CacheStsEn     = BIT_DISABLE;
    pCurDSG->XferCtrlInfo.BuffMapEn      = BIT_ENABLE;
ffe02ada:	0020c0        	memw
ffe02add:	1709      	s32i.n	a0, a7, 4
    pCurDSG->XferCtrlInfo.Eot            = BIT_TRUE;
ffe02adf:	0020c0        	memw
ffe02ae2:	17f8      	l32i.n	a15, a7, 4
ffe02ae4:	e20fb4        	insbits	a11, a15, 0, 30
ffe02ae7:	0020c0        	memw
ffe02aea:	17b9      	s32i.n	a11, a7, 4

    /*========================================================================*/
    /* DW2                                                                    */
    /*========================================================================*/
    pCurDSG->NextDsgId       = INVALID_2F;
ffe02aec:	fa7c      	movi.n	a10, -1
ffe02aee:	0020c0        	memw
ffe02af1:	0847a2        	s8i	a10, a7, 8
    pCurDSG->CacheStsData    = 0;
ffe02af4:	0020c0        	memw
ffe02af7:	0947e2        	s8i	a14, a7, 9
    pCurDSG->CmdLbaHigh      = 0;
ffe02afa:	0020c0        	memw
ffe02afd:	0557e2        	s16i	a14, a7, 10

    /*========================================================================*/
    /* DW3-5:Cache status Address/ Data Address(DRAM)/ Command LBA Low 32 bit */
    /*========================================================================*/
    pCurDSG->CacheStsAddr    = 0;
ffe02b00:	0020c0        	memw
ffe02b03:	3788      	l32i.n	a8, a7, 12
ffe02b05:	108890        	and	a8, a8, a9
ffe02b08:	2088e0        	or	a8, a8, a14
ffe02b0b:	0020c0        	memw
ffe02b0e:	3789      	s32i.n	a8, a7, 12
    pCurDSG->CmdLbaLow       = 0;
ffe02b10:	0020c0        	memw
ffe02b13:	57e9      	s32i.n	a14, a7, 20

    ulBuffMapValue = (0xffffffff << (0 >> SEC_PER_LPN_BITS))
                   & (0xffffffff >> (31 - ((ucSecCnt - 1) >> SEC_PER_LPN_BITS)));
                   
    HAL_SetBufMapInitValue(pCurDSG->XferCtrlInfo.BuffMapId, ulBuffMapValue);
ffe02b15:	fbc381        	l32r	a8, ffe01a24 <_bss_table_end+0xa8>
ffe02b18:	0020c0        	memw
ffe02b1b:	1778      	l32i.n	a7, a7, 4
ffe02b1d:	107780        	and	a7, a7, a8
    // bit[7:6] = 11'b, Setting high 16 bit
    //rBufMapSet = ((ulInitValue & 0xffff0000) >> 8) | (3 << 6) |(ucBufMapId);

    // bit[23:16] = mask bits. 0 = set, 1 = don't set.
    // bit[7:6] = 10'b, Setting low 8 bit
    rBufMapSet = (0 << 16) | ((ulInitValueL & 0x000000ff) << 8) | (2 << 6) | (ucBufMapId & 0x3f);
ffe02b20:	80a182        	movi	a8, 0x180
ffe02b23:	557070        	extui	a7, a7, 16, 6
ffe02b26:	208780        	or	a8, a7, a8
ffe02b29:	0020c0        	memw
ffe02b2c:	0689      	s32i.n	a8, a6, 0
    // bit[7:6] = 11'b, Setting high 8 bit
    rBufMapSet = (0 << 16) | (ulInitValueL & 0x0000ff00) | (3 << 6) | (ucBufMapId & 0x3f);
ffe02b2e:	c0a052        	movi	a5, 192
ffe02b31:	205750        	or	a5, a7, a5
ffe02b34:	0020c0        	memw
ffe02b37:	0659      	s32i.n	a5, a6, 0

    /* Buffer map set high 16 bits */
    ulInitValueH = ulInitValue >> 16;
    rBufMapSetH = (0 << 16) | ((ulInitValueH & 0x000000ff) << 8) | (2 << 6) | (ucBufMapId & 0x3f);
ffe02b39:	80a032        	movi	a3, 128
ffe02b3c:	207730        	or	a7, a7, a3
ffe02b3f:	0020c0        	memw
ffe02b42:	4679      	s32i.n	a7, a6, 16
    rBufMapSetH = (0 << 16) | (ulInitValueH & 0x0000ff00) | (3 << 6) | (ucBufMapId & 0x3f);
ffe02b44:	0020c0        	memw
ffe02b47:	4659      	s32i.n	a5, a6, 16
GLOBAL void HAL_SetLastDataReady(U8 ucCmdTag)
{
#ifdef SIM
        SDC_SetLastDataReady(((1<<7) | ucCmdTag));
#else
        rLastDataStatusInit = (1<<7) | ucCmdTag;
ffe02b49:	0020c0        	memw
ffe02b4c:	854432        	s8i	a3, a4, 133
ffe02b4f:	1f0c      	movi.n	a15, 1

    HAL_SetLastDataReady(0);
    HAL_UsedSataDSG(ucDSGId);
ffe02b51:	ff3ec5        	call0	ffe01f40 <HAL_UsedSataDSG>
U16 g_CurrUsedWriteDSGID;// = INVALID_4F;


U32 HAL_SetFirstDSGID(U8 CmdTag, U8 DSGID)
{
    rFIRST_DSG_ID[CmdTag] = DSGID;
ffe02b54:	0020c0        	memw
ffe02b57:	1148      	l32i.n	a4, a1, 4
ffe02b59:	804c42        	s8i	a4, a12, 128
GLOBAL void HAL_SetFirstReadDataReady(U8 ucCmdTag)
{
#ifdef SIM
        SDC_SetFirstReadDataReady(((1<<7) | ucCmdTag));
#else
        rReadDataStatusInit = (1<<7) | ucCmdTag;
ffe02b5c:	0020c0        	memw
ffe02b5f:	fba031        	l32r	a3, ffe019e0 <_bss_table_end+0x64>
ffe02b62:	80a022        	movi	a2, 128
ffe02b65:	844322        	s8i	a2, a3, 132
    HAL_SetFirstDSGID(0, ucDSGId);
    HAL_SetFirstReadDataReady(0);

    //6. Send a PIO setup FIS to host
    Lock_ShadowRegister();
ffe02b68:	0020c0        	memw
ffe02b6b:	fb85d1        	l32r	a13, ffe01980 <_bss_table_end+0x4>
ffe02b6e:	8f0db2        	l8ui	a11, a13, 143
ffe02b71:	800c      	movi.n	a0, 8
ffe02b73:	20bb00        	or	a11, a11, a0
ffe02b76:	0020c0        	memw
ffe02b79:	8f4db2        	s8i	a11, a13, 143
    rSDC_PIOXferCountLow = (U8)(ucSecCnt << SEC_SZ_BITS);
ffe02b7c:	0020c0        	memw
ffe02b7f:	194ce2        	s8i	a14, a12, 25
    rSDC_PIOXferCountHigh = (U8)(ucSecCnt << (SEC_SZ_BITS - 8));
ffe02b82:	0020c0        	memw
ffe02b85:	2a0c      	movi.n	a10, 2
ffe02b87:	1a4ca2        	s8i	a10, a12, 26
    rSDC_COMMAND_STATUS = 0x58;
ffe02b8a:	895c      	movi.n	a9, 88
ffe02b8c:	0020c0        	memw
ffe02b8f:	0b4c92        	s8i	a9, a12, 11
    rSDC_END_STATUS = 0x50;
ffe02b92:	0020c0        	memw
ffe02b95:	085c      	movi.n	a8, 80
ffe02b97:	174c82        	s8i	a8, a12, 23
    rSDC_FEATURE_ERROR = 0;
ffe02b9a:	0020c0        	memw
ffe02b9d:	054ce2        	s8i	a14, a12, 5
    rSDC_FISDirInt = BIT_SDC_FIS_DIRFLAG | BIT_SDC_FIS_INTFLAG;
ffe02ba0:	370c      	movi.n	a7, 3
ffe02ba2:	0020c0        	memw
ffe02ba5:	2b4c72        	s8i	a7, a12, 43
Modify History:
20090528    Yao Chen    001: first created
===================================================================*/
void HAL_SataSendPIOSetupFIS(void)
{
    rSDC_IOControl = BIT_SDC_IOCTRL_SENDPIOSETUP_FIS;
ffe02ba8:	064c      	movi.n	a6, 64
ffe02baa:	0020c0        	memw
ffe02bad:	2c4c62        	s8i	a6, a12, 44
    HAL_SataSendPIOSetupFIS();

    while (FALSE == HAL_SataIsFISXferAvailable());
ffe02bb0:	010685        	call0	ffe03c1c <HAL_SataIsFISXferAvailable>
ffe02bb3:	ff9216        	beqz	a2, ffe02bb0 <L1_TaskScheduleNoneData+0x4ac>
    
    UnLock_ShadowRegister();
ffe02bb6:	0020c0        	memw
ffe02bb9:	fb7171        	l32r	a7, ffe01980 <_bss_table_end+0x4>
ffe02bbc:	8f0762        	l8ui	a6, a7, 143
ffe02bbf:	f7a082        	movi	a8, 247
ffe02bc2:	106680        	and	a6, a6, a8
ffe02bc5:	0020c0        	memw
ffe02bc8:	8f4762        	s8i	a6, a7, 143
Modify History:
20090528    Yao Chen    001: first created
===================================================================*/
void HAL_SataSendPIODataFIS(void)
{
    rSDC_IOControl = BIT_SDC_IOCTRL_SENDPIODATA_FIS;
ffe02bcb:	0020c0        	memw
ffe02bce:	850c      	movi.n	a5, 8
ffe02bd0:	2c4c52        	s8i	a5, a12, 44

    //7. Send a PIO data FIS to host
    HAL_SataSendPIODataFIS();

    while (FALSE == HAL_SataIsFISXferAvailable()); //wait Data FIS transfer finish.
ffe02bd3:	010485        	call0	ffe03c1c <HAL_SataIsFISXferAvailable>
ffe02bd6:	ff9216        	beqz	a2, ffe02bd3 <L1_TaskScheduleNoneData+0x4cf>
ffe02bd9:	fb93a1        	l32r	a10, ffe01a28 <_bss_table_end+0xac>
void HAL_SetSendSDBFISReady(U8 ucCmdTag)
{
#ifdef SIM
    SDC_SetSDBFISReady(ucCmdTag);
#else
    rSDC_SendSDBFISReady |= (1<<ucCmdTag);
ffe02bdc:	0020c0        	memw
ffe02bdf:	952a92        	l32i	a9, a10, 0x254
ffe02be2:	2099f0        	or	a9, a9, a15
ffe02be5:	0020c0        	memw
ffe02be8:	956a92        	s32i	a9, a10, 0x254
    
    switch( pCurHCMD->ucCmdCode )
    {
    case    ATA_CMD_IDENTIFY_DEVICE:
        L1_SataCmdIdentifyDevice();
        break;
ffe02beb:	fed806        	j	ffe0274f <L1_TaskScheduleNoneData+0x4b>

ffe02bee <L1_TaskScheduleNoneData+0x4ea>:

    feature_code = rSDC_FEATURE_ERROR;
    switch(feature_code)
    {
    case ENABLE_WRITE_CACHE:
        DBG_Printf("[set features]: enable write cache.\n");
ffe02bee:	fb8f21        	l32r	a2, ffe01a2c <_bss_table_end+0xb0>
ffe02bf1:	022cc5        	call0	ffe04ec0 <dbg_printf>
        g_pSataIdentifyData[85] |= 0x0020;        
ffe02bf4:	292db2        	l32i	a11, a13, 164
ffe02bf7:	551ba2        	l16ui	a10, a11, 170
ffe02bfa:	0e2c      	movi.n	a14, 32
ffe02bfc:	20aae0        	or	a10, a10, a14
ffe02bff:	555ba2        	s16i	a10, a11, 170

        break;

    case DISABLE_APM:
        g_ulSataPowerMode = SATA_POWER_ACTIVE;
        break;
ffe02c02:	000c      	movi.n	a0, 0
ffe02c04:	fef906        	j	ffe027ec <L1_TaskScheduleNoneData+0xe8>

ffe02c07 <L1_TaskScheduleNoneData+0x503>:
            break;
        }
        break;

    case ENABLE_APM:
        trans_mode = rSDC_SECCNT;
ffe02c07:	0020c0        	memw
ffe02c0a:	060c22        	l8ui	a2, a12, 6
        if(0 == trans_mode)
ffe02c0d:	0f0c      	movi.n	a15, 0
ffe02c0f:	100c      	movi.n	a0, 1
ffe02c11:	930f20        	movnez	a0, a15, a2
ffe02c14:	fef506        	j	ffe027ec <L1_TaskScheduleNoneData+0xe8>

ffe02c17 <L1_TaskScheduleNoneData+0x513>:
    U32  dma_low;
    U32  dma_mid;
    U32  dma_high;

    /* get reg addr */
    sector_cnt = rSDC_SECCNT;
ffe02c17:	0020c0        	memw
ffe02c1a:	060c32        	l8ui	a3, a12, 6
    dma_low = rSDC_LBALOW;
ffe02c1d:	0020c0        	memw
ffe02c20:	070c42        	l8ui	a4, a12, 7
    dma_mid = rSDC_LBAMID;
ffe02c23:	0020c0        	memw
ffe02c26:	080c52        	l8ui	a5, a12, 8
    dma_high = rSDC_LBAHIGH;
ffe02c29:	0020c0        	memw
    reg_addr = (dma_high << 24) | (dma_mid << 16) | (dma_low << 8) | sector_cnt;
    reg_value = *(U32 *)reg_addr;
ffe02c2c:	115500        	slli	a5, a5, 16
ffe02c2f:	203350        	or	a3, a3, a5

    /* get reg addr */
    sector_cnt = rSDC_SECCNT;
    dma_low = rSDC_LBALOW;
    dma_mid = rSDC_LBAMID;
    dma_high = rSDC_LBAHIGH;
ffe02c32:	090c52        	l8ui	a5, a12, 9
    reg_addr = (dma_high << 24) | (dma_mid << 16) | (dma_low << 8) | sector_cnt;
    reg_value = *(U32 *)reg_addr;
ffe02c35:	114480        	slli	a4, a4, 8
ffe02c38:	015580        	slli	a5, a5, 24
ffe02c3b:	204450        	or	a4, a4, a5
ffe02c3e:	203340        	or	a3, a3, a4
ffe02c41:	0338      	l32i.n	a3, a3, 0

    rSDC_SECCNT = (U8)(reg_value & 0xff);
ffe02c43:	0020c0        	memw
ffe02c46:	064c32        	s8i	a3, a12, 6
    rSDC_LBALOW = (U8)((reg_value >> 8) & 0xff);
ffe02c49:	415830        	srli	a5, a3, 8
ffe02c4c:	0020c0        	memw
ffe02c4f:	074c52        	s8i	a5, a12, 7
    rSDC_LBAMID = (U8)((reg_value >> 16) & 0xff);
ffe02c52:	f54030        	extui	a4, a3, 16, 16
ffe02c55:	0020c0        	memw
ffe02c58:	084c42        	s8i	a4, a12, 8
    rSDC_LBAHIGH = (U8)((reg_value >> 24) & 0xff);
ffe02c5b:	753830        	extui	a3, a3, 24, 8
ffe02c5e:	0020c0        	memw
ffe02c61:	094c32        	s8i	a3, a12, 9
        
    /*return OK status*/
    while( FALSE == HAL_SataIsFISXferAvailable() );
ffe02c64:	00fb45        	call0	ffe03c1c <HAL_SataIsFISXferAvailable>
ffe02c67:	ff9216        	beqz	a2, ffe02c64 <L1_TaskScheduleNoneData+0x560>
    HAL_SataSendSuccessStatus();
ffe02c6a:	ff1c45        	call0	ffe01e30 <HAL_SataSendSuccessStatus>
        case VD_FEA_DISK_STATUS_CHK:
            satap_vd_disk_status_chk();
            break; */
        case VD_READ_REG:
            satap_vd_read_reg();
            break;
ffe02c6d:	feb786        	j	ffe0274f <L1_TaskScheduleNoneData+0x4b>

ffe02c70 <L1_TaskScheduleNoneData+0x56c>:
            break;
        }
        break;

    case DISABLE_SATA_FEATURE:
        DBG_Printf("[set features]: disable sata features 0x%x.\n", rSDC_SECCNT);
ffe02c70:	fb7021        	l32r	a2, ffe01a30 <_bss_table_end+0xb4>
ffe02c73:	0020c0        	memw
ffe02c76:	060c32        	l8ui	a3, a12, 6
ffe02c79:	022445        	call0	ffe04ec0 <dbg_printf>
        switch( rSDC_SECCNT )
ffe02c7c:	0020c0        	memw
ffe02c7f:	060c02        	l8ui	a0, a12, 6
ffe02c82:	600b      	addi.n	a6, a0, -1
ffe02c84:	1ce616        	beqz	a6, ffe02e56 <L1_TaskScheduleNoneData+0x752>
ffe02c87:	fec072        	addi	a7, a0, -2
ffe02c8a:	1bf716        	beqz	a7, ffe02e4d <L1_TaskScheduleNoneData+0x749>
ffe02c8d:	fdc082        	addi	a8, a0, -3
ffe02c90:	1a2816        	beqz	a8, ffe02e36 <L1_TaskScheduleNoneData+0x732>
ffe02c93:	fcc092        	addi	a9, a0, -4
ffe02c96:	1ce916        	beqz	a9, ffe02e68 <L1_TaskScheduleNoneData+0x764>
ffe02c99:	f9c0a2        	addi	a10, a0, -7
ffe02c9c:	1a8a16        	beqz	a10, ffe02e48 <L1_TaskScheduleNoneData+0x744>
            g_pSataIdentifyData[79] &= (~0x0010);
            break;

        default:
            berror = TRUE;
            break;
ffe02c9f:	100c      	movi.n	a0, 1
ffe02ca1:	fed1c6        	j	ffe027ec <L1_TaskScheduleNoneData+0xe8>

ffe02ca4 <L1_TaskScheduleNoneData+0x5a0>:
    U32  dma_mid;
    U32  dma_high;
    func_t ptr;

    /* get running addr */
    sector_cnt = rSDC_SECCNT;
ffe02ca4:	0020c0        	memw
ffe02ca7:	060cf2        	l8ui	a15, a12, 6
    dma_low = rSDC_LBALOW;
ffe02caa:	0020c0        	memw
ffe02cad:	070ce2        	l8ui	a14, a12, 7
    dma_mid = rSDC_LBAMID;
ffe02cb0:	0020c0        	memw
ffe02cb3:	080cd2        	l8ui	a13, a12, 8
    dma_high = rSDC_LBAHIGH;
ffe02cb6:	0020c0        	memw
    running_addr = (dma_high << 24) | (dma_mid << 16) | (dma_low << 8) | sector_cnt;
    DBG_Printf("running_addr = 0x%x\n", running_addr);
ffe02cb9:	11ee80        	slli	a14, a14, 8
ffe02cbc:	fb5e21        	l32r	a2, ffe01a34 <_bss_table_end+0xb8>
ffe02cbf:	20eef0        	or	a14, a14, a15

    /* get running addr */
    sector_cnt = rSDC_SECCNT;
    dma_low = rSDC_LBALOW;
    dma_mid = rSDC_LBAMID;
    dma_high = rSDC_LBAHIGH;
ffe02cc2:	090cf2        	l8ui	a15, a12, 9
    running_addr = (dma_high << 24) | (dma_mid << 16) | (dma_low << 8) | sector_cnt;
    DBG_Printf("running_addr = 0x%x\n", running_addr);
ffe02cc5:	11dd00        	slli	a13, a13, 16
ffe02cc8:	01ff80        	slli	a15, a15, 24
ffe02ccb:	20ddf0        	or	a13, a13, a15
ffe02cce:	20dde0        	or	a13, a13, a14
ffe02cd1:	0d3d      	mov.n	a3, a13
ffe02cd3:	021ec5        	call0	ffe04ec0 <dbg_printf>
    /*return OK status*/
    while( FALSE == HAL_SataIsFISXferAvailable() );
ffe02cd6:	00f445        	call0	ffe03c1c <HAL_SataIsFISXferAvailable>
ffe02cd9:	ff9216        	beqz	a2, ffe02cd6 <L1_TaskScheduleNoneData+0x5d2>
    HAL_SataSendSuccessStatus();
ffe02cdc:	ff1505        	call0	ffe01e30 <HAL_SataSendSuccessStatus>
    
    /* jump to addr */
    ptr = (func_t)running_addr;
    (*ptr)();
ffe02cdf:	000dc0        	callx0	a13
        case VD_WISHBONE_WRITE:
            satap_vd_wishbone_write();
            break; */
        case VD_FIRMWARE_RUN:
            satap_vd_firmware_run();
            break;
ffe02ce2:	fe9a46        	j	ffe0274f <L1_TaskScheduleNoneData+0x4b>

ffe02ce5 <L1_TaskScheduleNoneData+0x5e1>:
    U32  dma_low_exp;
    U32  dma_mid_exp;
    U32  dma_high_exp;

    /* get reg addr */
    sector_cnt = rSDC_SECCNT;
ffe02ce5:	0020c0        	memw
ffe02ce8:	060c02        	l8ui	a0, a12, 6
    dma_low = rSDC_LBALOW;
ffe02ceb:	0020c0        	memw
ffe02cee:	070c32        	l8ui	a3, a12, 7
    dma_mid = rSDC_LBAMID;
ffe02cf1:	0020c0        	memw
ffe02cf4:	080c52        	l8ui	a5, a12, 8
    dma_high = rSDC_LBAHIGH;
ffe02cf7:	0020c0        	memw
ffe02cfa:	090c42        	l8ui	a4, a12, 9
    reg_addr = (dma_high << 24) | (dma_mid << 16) | (dma_low << 8) | sector_cnt;

    /* get reg value */
    sector_cnt_exp = rSDC_EXP_SECCNT;
ffe02cfd:	0020c0        	memw
ffe02d00:	120cf2        	l8ui	a15, a12, 18
    dma_low_exp = rSDC_EXP_LBALOW;
ffe02d03:	0020c0        	memw
ffe02d06:	130c22        	l8ui	a2, a12, 19
    dma_mid_exp = rSDC_EXP_LBAMID;
ffe02d09:	0020c0        	memw
ffe02d0c:	140c62        	l8ui	a6, a12, 20
    dma_high_exp = rSDC_EXP_LBAHIGH;
ffe02d0f:	0020c0        	memw
    reg_value = (dma_high_exp << 24) | (dma_mid_exp << 16) | (dma_low_exp << 8) | sector_cnt_exp;

    /* write the register */
    *(U32 *)reg_addr = reg_value;
ffe02d12:	112280        	slli	a2, a2, 8
ffe02d15:	116600        	slli	a6, a6, 16
ffe02d18:	014480        	slli	a4, a4, 24
ffe02d1b:	113380        	slli	a3, a3, 8
ffe02d1e:	115500        	slli	a5, a5, 16
ffe02d21:	200050        	or	a0, a0, a5
ffe02d24:	203340        	or	a3, a3, a4
ffe02d27:	200030        	or	a0, a0, a3

    /* get reg value */
    sector_cnt_exp = rSDC_EXP_SECCNT;
    dma_low_exp = rSDC_EXP_LBALOW;
    dma_mid_exp = rSDC_EXP_LBAMID;
    dma_high_exp = rSDC_EXP_LBAHIGH;
ffe02d2a:	150c32        	l8ui	a3, a12, 21
    reg_value = (dma_high_exp << 24) | (dma_mid_exp << 16) | (dma_low_exp << 8) | sector_cnt_exp;

    /* write the register */
    *(U32 *)reg_addr = reg_value;
ffe02d2d:	20ff60        	or	a15, a15, a6
ffe02d30:	013380        	slli	a3, a3, 24
ffe02d33:	202230        	or	a2, a2, a3
ffe02d36:	20ff20        	or	a15, a15, a2
ffe02d39:	00f9      	s32i.n	a15, a0, 0
        
    /*return OK status*/
    while( FALSE == HAL_SataIsFISXferAvailable() );
ffe02d3b:	00ee05        	call0	ffe03c1c <HAL_SataIsFISXferAvailable>
ffe02d3e:	ff9216        	beqz	a2, ffe02d3b <L1_TaskScheduleNoneData+0x637>
    HAL_SataSendSuccessStatus();
ffe02d41:	ff0ec5        	call0	ffe01e30 <HAL_SataSendSuccessStatus>
        case VD_READ_REG:
            satap_vd_read_reg();
            break;
        case VD_WRITE_REG:
            satap_vd_write_reg();
            break;
ffe02d44:	fe81c6        	j	ffe0274f <L1_TaskScheduleNoneData+0x4b>

ffe02d47 <L1_TaskScheduleNoneData+0x643>:
        DBG_Printf("[set features]: disable write cache.\n");
        g_pSataIdentifyData[85] &= (~0x0020);    
        break;

    case SET_TRANSFER_MODE:
        trans_mode = rSDC_SECCNT;
ffe02d47:	0020c0        	memw
ffe02d4a:	060ce2        	l8ui	a14, a12, 6
        //TODO: transfer mode setup
        DBG_Printf("[set features]: set transfer mode to 0x%x.\n", trans_mode);
ffe02d4d:	fb3a21        	l32r	a2, ffe01a38 <_bss_table_end+0xbc>
ffe02d50:	0e3d      	mov.n	a3, a14
ffe02d52:	0216c5        	call0	ffe04ec0 <dbg_printf>
        switch( trans_mode & 0xF8 )
ffe02d55:	f8a072        	movi	a7, 248
ffe02d58:	100e70        	and	a0, a14, a7
ffe02d5b:	028e77        	bany	a14, a7, ffe02d61 <L1_TaskScheduleNoneData+0x65d>
ffe02d5e:	0033c6        	j	ffe02e31 <L1_TaskScheduleNoneData+0x72d>
ffe02d61:	f8c082        	addi	a8, a0, -8
ffe02d64:	144816        	beqz	a8, ffe02eac <L1_TaskScheduleNoneData+0x7a8>
ffe02d67:	fb3521        	l32r	a2, ffe01a3c <_bss_table_end+0xc0>
ffe02d6a:	e0c092        	addi	a9, a0, -32
ffe02d6d:	157916        	beqz	a9, ffe02ec8 <L1_TaskScheduleNoneData+0x7c4>
ffe02d70:	c0c0a2        	addi	a10, a0, -64
ffe02d73:	103a16        	beqz	a10, ffe02e7a <L1_TaskScheduleNoneData+0x776>
            g_pSataIdentifyData[88] &= 0x80FF;    //Clear any Ultra DMA mode field;
            g_pSataIdentifyData[88] |= (1 << (8 + trans_mode));    //Set identify device information field bit according to current Ultra DMA mode
            break;

        default:
            DBG_Printf("[set features]: target mode 0x%x is not support.\n", trans_mode);
ffe02d76:	0e3d      	mov.n	a3, a14
ffe02d78:	fb3221        	l32r	a2, ffe01a40 <_bss_table_end+0xc4>
ffe02d7b:	021445        	call0	ffe04ec0 <dbg_printf>
            berror = TRUE;
            break;
ffe02d7e:	100c      	movi.n	a0, 1
ffe02d80:	fe9a06        	j	ffe027ec <L1_TaskScheduleNoneData+0xe8>

ffe02d83 <L1_TaskScheduleNoneData+0x67f>:
    case DISABLE_APM:
        g_ulSataPowerMode = SATA_POWER_ACTIVE;
        break;

    case ENABLE_SATA_FEATURE:
        DBG_Printf("[set features]: enable sata features 0x%x.\n", rSDC_SECCNT);
ffe02d83:	fb3021        	l32r	a2, ffe01a44 <_bss_table_end+0xc8>
ffe02d86:	0020c0        	memw
ffe02d89:	060c32        	l8ui	a3, a12, 6
ffe02d8c:	021305        	call0	ffe04ec0 <dbg_printf>
        switch( rSDC_SECCNT )
ffe02d8f:	0020c0        	memw
ffe02d92:	060c02        	l8ui	a0, a12, 6
ffe02d95:	b00b      	addi.n	a11, a0, -1
ffe02d97:	0eeb16        	beqz	a11, ffe02e89 <L1_TaskScheduleNoneData+0x785>
ffe02d9a:	fec0e2        	addi	a14, a0, -2
ffe02d9d:	0f0e16        	beqz	a14, ffe02e91 <L1_TaskScheduleNoneData+0x78d>
ffe02da0:	fdc022        	addi	a2, a0, -3
ffe02da3:	116216        	beqz	a2, ffe02ebd <L1_TaskScheduleNoneData+0x7b9>
ffe02da6:	fcc032        	addi	a3, a0, -4
ffe02da9:	0ec316        	beqz	a3, ffe02e99 <L1_TaskScheduleNoneData+0x795>
ffe02dac:	f9c042        	addi	a4, a0, -7
ffe02daf:	124416        	beqz	a4, ffe02ed7 <L1_TaskScheduleNoneData+0x7d3>
            g_pSataIdentifyData[79] |= 0x0010;
            break;

        default:
            berror = TRUE;
            break;
ffe02db2:	100c      	movi.n	a0, 1
ffe02db4:	fe8d06        	j	ffe027ec <L1_TaskScheduleNoneData+0xe8>

ffe02db7 <L1_TaskScheduleNoneData+0x6b3>:
        DBG_Printf("[set features]: enable write cache.\n");
        g_pSataIdentifyData[85] |= 0x0020;        
        break;

    case DISABLE_WRITE_CACHE:
        DBG_Printf("[set features]: disable write cache.\n");
ffe02db7:	fb2421        	l32r	a2, ffe01a48 <_bss_table_end+0xcc>
ffe02dba:	021045        	call0	ffe04ec0 <dbg_printf>
        g_pSataIdentifyData[85] &= (~0x0020);    
ffe02dbd:	292d62        	l32i	a6, a13, 164
ffe02dc0:	fb2371        	l32r	a7, ffe01a4c <_bss_table_end+0xd0>
ffe02dc3:	551652        	l16ui	a5, a6, 170
ffe02dc6:	105570        	and	a5, a5, a7
ffe02dc9:	555652        	s16i	a5, a6, 170
ffe02dcc:	ff8c86        	j	ffe02c02 <L1_TaskScheduleNoneData+0x4fe>

ffe02dcf <L1_TaskScheduleNoneData+0x6cb>:
}

BOOL DRAM_ATTR satap_vd_read_status(void)
{

    DBG_Printf("[satap_vd_read_status]\n");
ffe02dcf:	fb2021        	l32r	a2, ffe01a50 <_bss_table_end+0xd4>
ffe02dd2:	020ec5        	call0	ffe04ec0 <dbg_printf>
    rSDC_SECCNT = sata_status.bSectorCountReg;
ffe02dd5:	e50de2        	l8ui	a14, a13, 229
ffe02dd8:	0020c0        	memw
ffe02ddb:	064ce2        	s8i	a14, a12, 6
    rSDC_LBALOW = sata_status.bLBALowReg;
ffe02dde:	e60db2        	l8ui	a11, a13, 230
ffe02de1:	0020c0        	memw
ffe02de4:	074cb2        	s8i	a11, a12, 7
    rSDC_LBAMID = sata_status.bLBAMidReg;
ffe02de7:	e70da2        	l8ui	a10, a13, 231
ffe02dea:	0020c0        	memw
ffe02ded:	084ca2        	s8i	a10, a12, 8
    rSDC_LBAHIGH = sata_status.bLBAHighReg;
ffe02df0:	e80d92        	l8ui	a9, a13, 232
ffe02df3:	0020c0        	memw
ffe02df6:	094c92        	s8i	a9, a12, 9
    rSDC_DEVICE_HEAD = sata_status.bDriveHeadReg;
ffe02df9:	e90d82        	l8ui	a8, a13, 233
ffe02dfc:	0020c0        	memw
ffe02dff:	0a4c82        	s8i	a8, a12, 10
    
    /*return OK status*/
    while( FALSE == HAL_SataIsFISXferAvailable() );
ffe02e02:	00e185        	call0	ffe03c1c <HAL_SataIsFISXferAvailable>
ffe02e05:	ff9216        	beqz	a2, ffe02e02 <L1_TaskScheduleNoneData+0x6fe>
    HAL_SataSendSuccessStatus();
ffe02e08:	ff0245        	call0	ffe01e30 <HAL_SataSendSuccessStatus>
        case VD_FIRMWARE_RUN:
            satap_vd_firmware_run();
            break;
        case VD_READ_STATUS:
            satap_vd_read_status();
            break;
ffe02e0b:	fe5006        	j	ffe0274f <L1_TaskScheduleNoneData+0x4b>

ffe02e0e <L1_TaskScheduleNoneData+0x70a>:
                DBG_Printf("[set features]: target mode 0x%x is not support.\n", trans_mode);
                berror = TRUE;    //Ultra DMA mode 6 is maximum supported mode
                break;
            }
            g_pSataIdentifyData[63] &= ~((1 << 8) | (1 << 9) | (1 << 10));    //Clear current Multiword DMA mode field
            g_pSataIdentifyData[88] &= 0x80FF;    //Clear any Ultra DMA mode field;
ffe02e0e:	fb1151        	l32r	a5, ffe01a54 <_bss_table_end+0xd8>
            {
                DBG_Printf("[set features]: target mode 0x%x is not support.\n", trans_mode);
                berror = TRUE;    //Ultra DMA mode 6 is maximum supported mode
                break;
            }
            g_pSataIdentifyData[63] &= ~((1 << 8) | (1 << 9) | (1 << 10));    //Clear current Multiword DMA mode field
ffe02e11:	292d62        	l32i	a6, a13, 164
            g_pSataIdentifyData[88] &= 0x80FF;    //Clear any Ultra DMA mode field;
            g_pSataIdentifyData[88] |= (1 << (8 + trans_mode));    //Set identify device information field bit according to current Ultra DMA mode
ffe02e14:	838b      	addi.n	a8, a3, 8
ffe02e16:	401800        	ssl	a8
            {
                DBG_Printf("[set features]: target mode 0x%x is not support.\n", trans_mode);
                berror = TRUE;    //Ultra DMA mode 6 is maximum supported mode
                break;
            }
            g_pSataIdentifyData[63] &= ~((1 << 8) | (1 << 9) | (1 << 10));    //Clear current Multiword DMA mode field
ffe02e19:	3f1672        	l16ui	a7, a6, 126
            g_pSataIdentifyData[88] &= 0x80FF;    //Clear any Ultra DMA mode field;
            g_pSataIdentifyData[88] |= (1 << (8 + trans_mode));    //Set identify device information field bit according to current Ultra DMA mode
ffe02e1c:	a14f00        	sll	a4, a15
            {
                DBG_Printf("[set features]: target mode 0x%x is not support.\n", trans_mode);
                berror = TRUE;    //Ultra DMA mode 6 is maximum supported mode
                break;
            }
            g_pSataIdentifyData[63] &= ~((1 << 8) | (1 << 9) | (1 << 10));    //Clear current Multiword DMA mode field
ffe02e1f:	107720        	and	a7, a7, a2
            g_pSataIdentifyData[88] &= 0x80FF;    //Clear any Ultra DMA mode field;
ffe02e22:	581622        	l16ui	a2, a6, 176
            {
                DBG_Printf("[set features]: target mode 0x%x is not support.\n", trans_mode);
                berror = TRUE;    //Ultra DMA mode 6 is maximum supported mode
                break;
            }
            g_pSataIdentifyData[63] &= ~((1 << 8) | (1 << 9) | (1 << 10));    //Clear current Multiword DMA mode field
ffe02e25:	3f5672        	s16i	a7, a6, 126
            g_pSataIdentifyData[88] &= 0x80FF;    //Clear any Ultra DMA mode field;
ffe02e28:	102250        	and	a2, a2, a5
            g_pSataIdentifyData[88] |= (1 << (8 + trans_mode));    //Set identify device information field bit according to current Ultra DMA mode
ffe02e2b:	202240        	or	a2, a2, a4
ffe02e2e:	585622        	s16i	a2, a6, 176
            break;
ffe02e31:	000c      	movi.n	a0, 0
ffe02e33:	fe6d46        	j	ffe027ec <L1_TaskScheduleNoneData+0xe8>

ffe02e36 <L1_TaskScheduleNoneData+0x732>:
            g_bSataFlagAutoActive = FALSE;
            g_pSataIdentifyData[79] &= (~0x0004);
            break;

        case SATA_FEATURE_DIPM:
            g_bSataFlagDipmEnabled = FALSE;
ffe02e36:	376de2        	s32i	a14, a13, 220
            g_pSataIdentifyData[79] &= ~(0x0008);
ffe02e39:	292d62        	l32i	a6, a13, 164
ffe02e3c:	fb0701        	l32r	a0, ffe01a58 <_bss_table_end+0xdc>
ffe02e3f:	4f1692        	l16ui	a9, a6, 158
ffe02e42:	109900        	and	a9, a9, a0
ffe02e45:	4f5692        	s16i	a9, a6, 158
            break;

        case SATA_FEATURE_DIAPTS:
            g_bSataFlagAPTS_Enabled = FALSE;
            break;
ffe02e48:	000c      	movi.n	a0, 0
ffe02e4a:	fe6786        	j	ffe027ec <L1_TaskScheduleNoneData+0xe8>

ffe02e4d <L1_TaskScheduleNoneData+0x749>:
            g_pSataIdentifyData[79] &= (~0x0002);
            break;

        case SATA_FEATURE_AUTO_ACTIVATE:
            g_bSataFlagAutoActive = FALSE;
            g_pSataIdentifyData[79] &= (~0x0004);
ffe02e4d:	292d62        	l32i	a6, a13, 164
ffe02e50:	fb0301        	l32r	a0, ffe01a5c <_bss_table_end+0xe0>
ffe02e53:	fffa06        	j	ffe02e3f <L1_TaskScheduleNoneData+0x73b>

ffe02e56 <L1_TaskScheduleNoneData+0x752>:
    case DISABLE_SATA_FEATURE:
        DBG_Printf("[set features]: disable sata features 0x%x.\n", rSDC_SECCNT);
        switch( rSDC_SECCNT )
        {
        case SATA_FEATURE_NONZERO_OFFSET:
            g_pSataIdentifyData[79] &= (~0x0002);
ffe02e56:	292db2        	l32i	a11, a13, 164
ffe02e59:	fb01e1        	l32r	a14, ffe01a60 <_bss_table_end+0xe4>
ffe02e5c:	4f1ba2        	l16ui	a10, a11, 158
ffe02e5f:	10aae0        	and	a10, a10, a14
ffe02e62:	4f5ba2        	s16i	a10, a11, 158
ffe02e65:	fff7c6        	j	ffe02e48 <L1_TaskScheduleNoneData+0x744>

ffe02e68 <L1_TaskScheduleNoneData+0x764>:
        case SATA_FEATURE_DIAPTS:
            g_bSataFlagAPTS_Enabled = FALSE;
            break;

        case SATA_FEATURE_GUARANTEED_INORDER:
            g_pSataIdentifyData[79] &= (~0x0010);
ffe02e68:	292d02        	l32i	a0, a13, 164
ffe02e6b:	fafe21        	l32r	a2, ffe01a64 <_bss_table_end+0xe8>
ffe02e6e:	4f10f2        	l16ui	a15, a0, 158
ffe02e71:	10ff20        	and	a15, a15, a2
ffe02e74:	4f50f2        	s16i	a15, a0, 158
ffe02e77:	fff346        	j	ffe02e48 <L1_TaskScheduleNoneData+0x744>

ffe02e7a <L1_TaskScheduleNoneData+0x776>:

        case    8 << 3:    //ultraDMA mode
            // YaoChen: bit 7:3 = 01000b 2008/12/13
            trans_mode &= 0x7;
            //check if target mode is supported or not
            if( trans_mode > 6 )    
ffe02e7a:	2430e0        	extui	a3, a14, 0, 3
ffe02e7d:	8d73b6        	bltui	a3, 7, ffe02e0e <L1_TaskScheduleNoneData+0x70a>
            {
                DBG_Printf("[set features]: target mode 0x%x is not support.\n", trans_mode);
ffe02e80:	faf021        	l32r	a2, ffe01a40 <_bss_table_end+0xc4>
ffe02e83:	0203c5        	call0	ffe04ec0 <dbg_printf>
ffe02e86:	ffbd06        	j	ffe02d7e <L1_TaskScheduleNoneData+0x67a>

ffe02e89 <L1_TaskScheduleNoneData+0x785>:
ffe02e89:	220c      	movi.n	a2, 2
    case ENABLE_SATA_FEATURE:
        DBG_Printf("[set features]: enable sata features 0x%x.\n", rSDC_SECCNT);
        switch( rSDC_SECCNT )
        {
        case SATA_FEATURE_NONZERO_OFFSET:                       
            g_pSataIdentifyData[79] |= 0x0002;
ffe02e8b:	292d62        	l32i	a6, a13, 164
ffe02e8e:	000306        	j	ffe02e9e <L1_TaskScheduleNoneData+0x79a>

ffe02e91 <L1_TaskScheduleNoneData+0x78d>:
            break;

        case SATA_FEATURE_AUTO_ACTIVATE:
            g_bSataFlagAutoActive = TRUE;
            g_pSataIdentifyData[79] |= 0x0004;
ffe02e91:	292d62        	l32i	a6, a13, 164
ffe02e94:	420c      	movi.n	a2, 4
ffe02e96:	000106        	j	ffe02e9e <L1_TaskScheduleNoneData+0x79a>

ffe02e99 <L1_TaskScheduleNoneData+0x795>:
            else
                berror = TRUE;
            break;

        case SATA_FEATURE_GUARANTEED_INORDER:
            g_pSataIdentifyData[79] |= 0x0010;
ffe02e99:	292d62        	l32i	a6, a13, 164
ffe02e9c:	021c      	movi.n	a2, 16
ffe02e9e:	4f1632        	l16ui	a3, a6, 158
            break;
ffe02ea1:	000c      	movi.n	a0, 0
            else
                berror = TRUE;
            break;

        case SATA_FEATURE_GUARANTEED_INORDER:
            g_pSataIdentifyData[79] |= 0x0010;
ffe02ea3:	203320        	or	a3, a3, a2
ffe02ea6:	4f5632        	s16i	a3, a6, 158
            break;
ffe02ea9:	fe4fc6        	j	ffe027ec <L1_TaskScheduleNoneData+0xe8>

ffe02eac <L1_TaskScheduleNoneData+0x7a8>:

        case    1 << 3:    //PIO transfer mode
            // YaoChen: PIO flow control transfer mode, bit 7:3 = 00001b  2008/12/13
            trans_mode &= 0x7;
            //check if target mode is supported or not
            if( trans_mode > 4 )
ffe02eac:	2430e0        	extui	a3, a14, 0, 3
ffe02eaf:	3153b6        	bltui	a3, 5, ffe02ee4 <L1_TaskScheduleNoneData+0x7e0>
            {
                DBG_Printf("[set features]: target mode 0x%x is not support.\n", trans_mode);
ffe02eb2:	fae321        	l32r	a2, ffe01a40 <_bss_table_end+0xc4>
ffe02eb5:	020085        	call0	ffe04ec0 <dbg_printf>
ffe02eb8:	100c      	movi.n	a0, 1
ffe02eba:	fe4b86        	j	ffe027ec <L1_TaskScheduleNoneData+0xe8>

ffe02ebd <L1_TaskScheduleNoneData+0x7b9>:
            g_bSataFlagAutoActive = TRUE;
            g_pSataIdentifyData[79] |= 0x0004;
            break;

        case SATA_FEATURE_DIPM:
            g_bSataFlagDipmEnabled = TRUE;
ffe02ebd:	376df2        	s32i	a15, a13, 220
            g_pSataIdentifyData[79] |= 0x0008;
ffe02ec0:	292d62        	l32i	a6, a13, 164
ffe02ec3:	820c      	movi.n	a2, 8
ffe02ec5:	fff546        	j	ffe02e9e <L1_TaskScheduleNoneData+0x79a>

ffe02ec8 <L1_TaskScheduleNoneData+0x7c4>:
        case    4 << 3:    //multiword DMA
            // YaoChen: bit 7:3 = 00100b 2008/12/13
            trans_mode &= 0x7;
            //set MultitWord DMA mode to mode (transMode & 0x7)
            //check if target mode is supported or not
            if( trans_mode > 2 )    
ffe02ec8:	2430e0        	extui	a3, a14, 0, 3
ffe02ecb:	1a33b6        	bltui	a3, 3, ffe02ee9 <L1_TaskScheduleNoneData+0x7e5>
            {
                DBG_Printf("[set features]: target mode 0x%x is not support.\n", trans_mode);
ffe02ece:	fadc21        	l32r	a2, ffe01a40 <_bss_table_end+0xc4>
ffe02ed1:	01fec5        	call0	ffe04ec0 <dbg_printf>
ffe02ed4:	ffa986        	j	ffe02d7e <L1_TaskScheduleNoneData+0x67a>

ffe02ed7 <L1_TaskScheduleNoneData+0x7d3>:
            g_bSataFlagDipmEnabled = TRUE;
            g_pSataIdentifyData[79] |= 0x0008;
            break;

        case SATA_FEATURE_DIAPTS:
            if ( TRUE == g_bSataFlagDipmEnabled )
ffe02ed7:	372d02        	l32i	a0, a13, 220
ffe02eda:	140c      	movi.n	a4, 1
ffe02edc:	000b      	addi.n	a0, a0, -1
ffe02ede:	930400        	movnez	a0, a4, a0
                g_bSataFlagAPTS_Enabled = TRUE;
            else
                berror = TRUE;
            break;
ffe02ee1:	fe41c6        	j	ffe027ec <L1_TaskScheduleNoneData+0xe8>

ffe02ee4 <L1_TaskScheduleNoneData+0x7e0>:
            // YaoChen: PIO flow control transfer mode, bit 7:3 = 00001b  2008/12/13
            trans_mode &= 0x7;
            //check if target mode is supported or not
            if( trans_mode > 4 )
            {
                DBG_Printf("[set features]: target mode 0x%x is not support.\n", trans_mode);
ffe02ee4:	000c      	movi.n	a0, 0
ffe02ee6:	fe4086        	j	ffe027ec <L1_TaskScheduleNoneData+0xe8>

ffe02ee9 <L1_TaskScheduleNoneData+0x7e5>:
            {
                DBG_Printf("[set features]: target mode 0x%x is not support.\n", trans_mode);
                berror = TRUE;    //Multiple word DMA mode 2 is maximum supported mode
                break;
            }
            g_pSataIdentifyData[63] &= ~((1 << 8) | (1 << 9) | (1 << 10));    //Clear current Multiword DMA mode field
ffe02ee9:	292d62        	l32i	a6, a13, 164
            g_pSataIdentifyData[63] |= (1 << (8 + trans_mode));    //Set identify device information field bit
ffe02eec:	738b      	addi.n	a7, a3, 8
ffe02eee:	401700        	ssl	a7
            {
                DBG_Printf("[set features]: target mode 0x%x is not support.\n", trans_mode);
                berror = TRUE;    //Multiple word DMA mode 2 is maximum supported mode
                break;
            }
            g_pSataIdentifyData[63] &= ~((1 << 8) | (1 << 9) | (1 << 10));    //Clear current Multiword DMA mode field
ffe02ef1:	3f1652        	l16ui	a5, a6, 126
            g_pSataIdentifyData[63] |= (1 << (8 + trans_mode));    //Set identify device information field bit
ffe02ef4:	a14f00        	sll	a4, a15
            {
                DBG_Printf("[set features]: target mode 0x%x is not support.\n", trans_mode);
                berror = TRUE;    //Multiple word DMA mode 2 is maximum supported mode
                break;
            }
            g_pSataIdentifyData[63] &= ~((1 << 8) | (1 << 9) | (1 << 10));    //Clear current Multiword DMA mode field
ffe02ef7:	102520        	and	a2, a5, a2
            g_pSataIdentifyData[63] |= (1 << (8 + trans_mode));    //Set identify device information field bit
ffe02efa:	202240        	or	a2, a2, a4
ffe02efd:	3f5622        	s16i	a2, a6, 126
            // according to current Multiword DMA mode
            g_pSataIdentifyData[88] &= 0xFF;    //Clear any Ultra DMA mode field;
ffe02f00:	b00622        	l8ui	a2, a6, 176
ffe02f03:	ffc9c6        	j	ffe02e2e <L1_TaskScheduleNoneData+0x72a>

ffe02f06 <L1_TaskScheduleNoneData+0x802>:
	...

ffe02f08 <L1_HostCMDSelect>:
Modification History:
20120209   Brooke Wang create detailed code
20120118   peterxiu   001 first create function
****************************************************************************/
HCMD * L1_HostCMDSelect()
{
ffe02f08:	fa9f51        	l32r	a5, ffe01984 <_bss_table_end+0x8>

 //   WRITE_DBG_LOG_INFO(g_DbgLogInfo,1,(LocalHCMDFIFOHead|(LocalHCMDFIFOTail<<8)),HostCmdSlot[ucCmdTag].ulCmdLba,HostCmdSlot[ucCmdTag].ulCmdSectorCnt,HostCmdSlot[ucCmdTag].ucCmdTag);
 //   FW_L1_LogInfo_Trace(LOG_TRACE_ALL,3,LOG_LVL_INFO,&g_DbgLogInfo);
 //   RecordFlag(0,3,1,"HCMD FIFO Current head = %d[23:16], Tail = %d[31:24],CmdLBA = %x[63:32], ulCmdSectorCnt=%d[95:64], ucCmdTag=%d[127:96]\n");

    LocalHCMDFIFOHead  =  ulNextHead;
ffe02f0b:	040c      	movi.n	a4, 0
    /*Pop a tag from FIFO */
    /* if no CMD is the FIFO, return */  
#ifdef SIM
    EnterCriticalSection(&g_CMDQueueCriticalSection);
#endif
    if(M_HCMDFIFO_EMPTY(LocalHCMDFIFOHead, LocalHCMDFIFOTail))
ffe02f0d:	2f2522        	l32i	a2, a5, 188
ffe02f10:	302532        	l32i	a3, a5, 192

 //   WRITE_DBG_LOG_INFO(g_DbgLogInfo,1,(LocalHCMDFIFOHead|(LocalHCMDFIFOTail<<8)),HostCmdSlot[ucCmdTag].ulCmdLba,HostCmdSlot[ucCmdTag].ulCmdSectorCnt,HostCmdSlot[ucCmdTag].ucCmdTag);
 //   FW_L1_LogInfo_Trace(LOG_TRACE_ALL,3,LOG_LVL_INFO,&g_DbgLogInfo);
 //   RecordFlag(0,3,1,"HCMD FIFO Current head = %d[23:16], Tail = %d[31:24],CmdLBA = %x[63:32], ulCmdSectorCnt=%d[95:64], ucCmdTag=%d[127:96]\n");

    LocalHCMDFIFOHead  =  ulNextHead;
ffe02f13:	e0c262        	addi	a6, a2, -32
    /*Pop a tag from FIFO */
    /* if no CMD is the FIFO, return */  
#ifdef SIM
    EnterCriticalSection(&g_CMDQueueCriticalSection);
#endif
    if(M_HCMDFIFO_EMPTY(LocalHCMDFIFOHead, LocalHCMDFIFOTail))
ffe02f16:	039327        	bne	a3, a2, ffe02f1d <L1_HostCMDSelect+0x15>
    {
        // CPU_EnableIntAck() ;
#ifdef SIM
        LeaveCriticalSection(&g_CMDQueueCriticalSection);
#endif
        return (NULL) ;
ffe02f19:	020c      	movi.n	a2, 0

#ifdef SIM
    LeaveCriticalSection(&g_CMDQueueCriticalSection);
#endif

    return (&HostCmdSlot[ucCmdTag]);
ffe02f1b:	f00d      	ret.n

ffe02f1d <L1_HostCMDSelect+0x15>:

 //   WRITE_DBG_LOG_INFO(g_DbgLogInfo,1,(LocalHCMDFIFOHead|(LocalHCMDFIFOTail<<8)),HostCmdSlot[ucCmdTag].ulCmdLba,HostCmdSlot[ucCmdTag].ulCmdSectorCnt,HostCmdSlot[ucCmdTag].ucCmdTag);
 //   FW_L1_LogInfo_Trace(LOG_TRACE_ALL,3,LOG_LVL_INFO,&g_DbgLogInfo);
 //   RecordFlag(0,3,1,"HCMD FIFO Current head = %d[23:16], Tail = %d[31:24],CmdLBA = %x[63:32], ulCmdSectorCnt=%d[95:64], ucCmdTag=%d[127:96]\n");

    LocalHCMDFIFOHead  =  ulNextHead;
ffe02f1d:	321b      	addi.n	a3, a2, 1
ffe02f1f:	833460        	moveqz	a3, a4, a6
    {
        ulNextHead =0 ;
    }
    //  CPU_EnableIntAck() ;

    ucCmdTag = LocalHCMDFIFO[LocalHCMDFIFOHead];
ffe02f22:	a02250        	addx4	a2, a2, a5
ffe02f25:	03d222        	addmi	a2, a2, 0x300
ffe02f28:	b00222        	l8ui	a2, a2, 176

 //   WRITE_DBG_LOG_INFO(g_DbgLogInfo,1,(LocalHCMDFIFOHead|(LocalHCMDFIFOTail<<8)),HostCmdSlot[ucCmdTag].ulCmdLba,HostCmdSlot[ucCmdTag].ulCmdSectorCnt,HostCmdSlot[ucCmdTag].ucCmdTag);
 //   FW_L1_LogInfo_Trace(LOG_TRACE_ALL,3,LOG_LVL_INFO,&g_DbgLogInfo);
 //   RecordFlag(0,3,1,"HCMD FIFO Current head = %d[23:16], Tail = %d[31:24],CmdLBA = %x[63:32], ulCmdSectorCnt=%d[95:64], ucCmdTag=%d[127:96]\n");

    LocalHCMDFIFOHead  =  ulNextHead;
ffe02f2b:	2f6532        	s32i	a3, a5, 188

#ifdef SIM
    LeaveCriticalSection(&g_CMDQueueCriticalSection);
#endif

    return (&HostCmdSlot[ucCmdTag]);
ffe02f2e:	a02220        	addx4	a2, a2, a2
ffe02f31:	a02250        	addx4	a2, a2, a5
ffe02f34:	01d222        	addmi	a2, a2, 0x100
ffe02f37:	30c222        	addi	a2, a2, 48
ffe02f3a:	f00d      	ret.n

ffe02f3c <L1_TaskEventHandle>:
Modify      :
****************************************************************************/
//extern U32 L1_DbgEventHandler(void);

U32 L1_TaskEventHandle(void)
{
ffe02f3c:	d0c112        	addi	a1, a1, -48
ffe02f3f:	71c9      	s32i.n	a12, a1, 28
ffe02f41:	81d9      	s32i.n	a13, a1, 32
ffe02f43:	012d      	mov.n	a2, a1
ffe02f45:	6109      	s32i.n	a0, a1, 24
ffe02f47:	001345        	call0	ffe0307c <CommCheckEvent>
ffe02f4a:	32cc      	bnez.n	a2, ffe02f51 <L1_TaskEventHandle+0x15>

    Ret = COMM_EVENT_STATUS_BLOCKING;

    if (COMM_EVENT_STATUS_SUCCESS_NOEVENT == CommCheckEvent(COMM_EVENT_OWNER_L1,&L1_Event))
    {
        return COMM_EVENT_STATUS_SUCCESS_NOEVENT;
ffe02f4c:	020c      	movi.n	a2, 0

    U32 Ret;

    Ret = COMM_EVENT_STATUS_BLOCKING;

    if (COMM_EVENT_STATUS_SUCCESS_NOEVENT == CommCheckEvent(COMM_EVENT_OWNER_L1,&L1_Event))
ffe02f4e:	004306        	j	ffe0305e <L1_TaskEventHandle+0x122>

ffe02f51 <L1_TaskEventHandle+0x15>:
    {
        return COMM_EVENT_STATUS_SUCCESS_NOEVENT;
    }

     if (L1_Event.EventInit)
ffe02f51:	0128      	l32i.n	a2, a1, 0
ffe02f53:	0c0c      	movi.n	a12, 0
ffe02f55:	043020        	extui	a3, a2, 0, 1
ffe02f58:	10d316        	beqz	a3, ffe03069 <L1_TaskEventHandle+0x12d>
        }
#endif        
#endif
    }

    for (ucNcqDepth = 0; ucNcqDepth < NCQ_DEPTH; ucNcqDepth++)
ffe02f5b:	fac341        	l32r	a4, ffe01a68 <_bss_table_end+0xec>
ffe02f5e:	0c2d      	mov.n	a2, a12
ffe02f60:	fa89d1        	l32r	a13, ffe01984 <_bss_table_end+0x8>
ffe02f63:	052c      	movi.n	a5, 32
    gPuToSelected = INVALID_2F;
      gNextPuToSelect = 0;
    g_ucL1HCmdAddCnt = 0;
    g_ucL1HCmdHandleCnt = 0;
#else
    LocalHCMDFIFOHead = 0;
ffe02f65:	2f6dc2        	s32i	a12, a13, 188
    LocalHCMDFIFOTail = 0;
ffe02f68:	306dc2        	s32i	a12, a13, 192
#endif

    gCurHCMD = NULL;
ffe02f6b:	316dc2        	s32i	a12, a13, 196
    gpCurSubCmd = NULL;
ffe02f6e:	326dc2        	s32i	a12, a13, 200
    gCurSubCmd = 0;
ffe02f71:	cc4dc2        	s8i	a12, a13, 204
    return COMM_EVENT_STATUS_GET_EVENTPEND;
}

void CommGetEventParameter(U8 EventOwner,COMM_EVENT_PARAMETER **pParamter)
{
    *pParamter = &(*ModuelEventParameter)[EventOwner];
ffe02f74:	262d72        	l32i	a7, a13, 152
ffe02f77:	3179      	s32i.n	a7, a1, 12
        //get parameter from comm event
        CommGetEventParameter(COMM_EVENT_OWNER_L1,&pParameter);

        //DWORD0 free dram address,DW1 free otfb sram address
        ulFreeDramBase = pParameter->EventParameterNormal[0];
        ulFreeOTFBBase = pParameter->EventParameterNormal[1];
ffe02f79:	2768      	l32i.n	a6, a7, 8
ffe02f7b:	5169      	s32i.n	a6, a1, 20
ffe02f7d:	2169      	s32i.n	a6, a1, 8
    {
        //get parameter from comm event
        CommGetEventParameter(COMM_EVENT_OWNER_L1,&pParameter);

        //DWORD0 free dram address,DW1 free otfb sram address
        ulFreeDramBase = pParameter->EventParameterNormal[0];
ffe02f7f:	1778      	l32i.n	a7, a7, 4
ffe02f81:	4179      	s32i.n	a7, a1, 16
ffe02f83:	1179      	s32i.n	a7, a1, 4
ffe02f85:	13a576        	loopgtz	a5, ffe02f9c <L1_TaskEventHandle+0x60>
#endif
    }

    for (ucNcqDepth = 0; ucNcqDepth < NCQ_DEPTH; ucNcqDepth++)
    {
        HostCmdSlot[ucNcqDepth].ulCmdRemSector = 0;
ffe02f88:	a03220        	addx4	a3, a2, a2
ffe02f8b:	a053d0        	addx4	a5, a3, a13
        }
#endif        
#endif
    }

    for (ucNcqDepth = 0; ucNcqDepth < NCQ_DEPTH; ucNcqDepth++)
ffe02f8e:	221b      	addi.n	a2, a2, 1
ffe02f90:	742020        	extui	a2, a2, 0, 8
    {
        HostCmdSlot[ucNcqDepth].ulCmdRemSector = 0;
ffe02f93:	4f65c2        	s32i	a12, a5, 0x13c
        HostCmdSlot[ucNcqDepth].ucCmdStatus    = HCMD_STATE_NONE;
ffe02f96:	a03340        	addx4	a3, a3, a4
ffe02f99:	7f43c2        	s8i	a12, a3, 127

ffe02f9c <L1_TaskEventHandle+0x60>:

void DRAM_ATTR L1_SataCmdInit(U32 *pFreeDramBase,U32 *pFreeOTFBBase)
{
    g_ulSyscfgMaxAccessableLba =  MAX_ACCESS_LBA ;
    g_bSataFlagAutoActive = FALSE;
    g_bSataFlagDipmEnabled = FALSE;
ffe02f9c:	376dc2        	s32i	a12, a13, 220
    g_bSataFlagAPTS_Enabled = FALSE;
    g_bMultipleDataOpen = FALSE;
ffe02f9f:	386dc2        	s32i	a12, a13, 224
    g_ulSataPowerMode = SATA_POWER_ACTIVEORIDLE;
    gPIOInfoBlock.pCommand = NULL;
ffe02fa2:	356dc2        	s32i	a12, a13, 212
    gPIOInfoBlock.ucCurrPIOState = SATA_PIO_NOCMD;
ffe02fa5:	d04dc2        	s8i	a12, a13, 208
    gPIOInfoBlock.ucCurrRemLenth = 0;
ffe02fa8:	d14dc2        	s8i	a12, a13, 209
    gPIOInfoBlock.ucRemReadPRD   = 0;
ffe02fab:	d34dc2        	s8i	a12, a13, 211
    gPIOInfoBlock.ucReadPRDCnt   = 0;
ffe02fae:	d24dc2        	s8i	a12, a13, 210
    g_ucPIOCurrDataFISLen = 0;
    g_ucPIOFirstReadPRD   = FALSE;

    //init identify data for cosim/fpga (otfb version)
    g_pSataIdentifyData = (U16*)OTFB_IDENTIFY_ADDR;
    HAL_MemCpy((U32 *)g_pSataIdentifyData, (U32 *)(&Default_Idfy_Data[0]), SEC_SZ/sizeof(U32));
ffe02fb1:	faaf31        	l32r	a3, ffe01a70 <_bss_table_end+0xf4>
ffe02fb4:	80a042        	movi	a4, 128
    gPIOInfoBlock.ucReadPRDCnt   = 0;
    g_ucPIOCurrDataFISLen = 0;
    g_ucPIOFirstReadPRD   = FALSE;

    //init identify data for cosim/fpga (otfb version)
    g_pSataIdentifyData = (U16*)OTFB_IDENTIFY_ADDR;
ffe02fb7:	faad21        	l32r	a2, ffe01a6c <_bss_table_end+0xf0>
ffe02fba:	296d22        	s32i	a2, a13, 164
    HAL_MemCpy((U32 *)g_pSataIdentifyData, (U32 *)(&Default_Idfy_Data[0]), SEC_SZ/sizeof(U32));
ffe02fbd:	020985        	call0	ffe05058 <HAL_MemCpy>
    /*L1_BufferInit(pFreeDramBase,pFreeOTFBBase) ;
    L1_DbgInit();*/
#ifdef L2_FORCE_VIRTUAL_STORAGE
    L2_VSSpaceAlloc(pFreeDramBase);
#endif
    gCurHCMD = NULL ;
ffe02fc0:	316dc2        	s32i	a12, a13, 196
    gpCurSubCmd = NULL;
ffe02fc3:	326dc2        	s32i	a12, a13, 200
    gCurSubCmd = 0;
ffe02fc6:	cc4dc2        	s8i	a12, a13, 204
void L1_TaskInit(U32 *pFreeDramBase,U32 *pFreeOTFBBase)
{
    L1_HostCMDProcInit(pFreeDramBase,pFreeOTFBBase);
    /*L1_CacheInit(pFreeDramBase,pFreeOTFBBase);
    L1_BufReqFifoInit(pFreeDramBase,pFreeOTFBBase);*/
    L1_SataCmdInit(pFreeDramBase,pFreeOTFBBase);
ffe02fc9:	fa7161        	l32r	a6, ffe01990 <_bss_table_end+0x14>
#endif
    gCurHCMD = NULL ;
    gpCurSubCmd = NULL;
    gCurSubCmd = 0;

    g_CurrUsedReadDSGID = INVALID_4F;
ffe02fcc:	5c5d62        	s16i	a6, a13, 184
    g_CurrUsedWriteDSGID = INVALID_4F; 
ffe02fcf:	5d5d62        	s16i	a6, a13, 186

void HAL_Init(U32 *pFreeDramBase,U32 *pFreeOTFBBase)
{
    //HAL_UartInit();
    
    HAL_SataInitialize();
ffe02fd2:	00c5c5        	call0	ffe03c30 <HAL_SataInitialize>
    any other sata DSG functions can be called after this function finished.
------------------------------------------------------------------------------*/
void HAL_SataDsgInit(void)
{
    //SIM_XTENSA
    l_pSataDsgReport1 = (pHSG_REPORT_MCU)&rHsgReportMcu1;//HSG_REPORT_MCU0R;
ffe02fd5:	faa7a1        	l32r	a10, ffe01a74 <_bss_table_end+0xf8>
    HAL_SataDsgInit();
ffe02fd8:	faa881        	l32r	a8, ffe01a78 <_bss_table_end+0xfc>
ffe02fdb:	fa69b1        	l32r	a11, ffe01980 <_bss_table_end+0x4>
ffe02fde:	faa751        	l32r	a5, ffe01a7c <_bss_table_end+0x100>
ffe02fe1:	0020c0        	memw
ffe02fe4:	276da2        	s32i	a10, a13, 156
    l_pSataDsgReport2 = (pHSG_REPORT_MCU)&rHsgReportMcu2;//HSG_REPORT_MCU1R;  
ffe02fe7:	faa691        	l32r	a9, ffe01a80 <_bss_table_end+0x104>
ffe02fea:	0020c0        	memw
ffe02fed:	286d92        	s32i	a9, a13, 160

    /* Set Sata mode enable */
    rSGESataMode |= 1;
ffe02ff0:	0020c0        	memw
ffe02ff3:	472872        	l32i	a7, a8, 0x11c
ffe02ff6:	130c      	movi.n	a3, 1
ffe02ff8:	207730        	or	a7, a7, a3
ffe02ffb:	0020c0        	memw
ffe02ffe:	476872        	s32i	a7, a8, 0x11c
    */
    
   // *(volatile U32 *)(0x1ff81f00 + 0x10) |= 0x2f30000;//(1<<25)|(1<<23)|(1<<22)|(1<<21)|(1<<20)|(1<<17)|(1<<16);

    // PMU_10[20] : SDCBLKDMACMD_EN
    *(volatile U32 *)(0x1ff81f00 + 0x10) |= 0x2e30000; //(1<<25)|(1<<23)|(1<<22)|(1<<21)         |(1<<17)|(1<<16);
ffe03001:	faa061        	l32r	a6, ffe01a84 <_bss_table_end+0x108>
ffe03004:	0020c0        	memw
ffe03007:	442542        	l32i	a4, a5, 0x110
ffe0300a:	204460        	or	a4, a4, a6
ffe0300d:	0020c0        	memw
ffe03010:	446542        	s32i	a4, a5, 0x110
    *(volatile U8 *)(SDC_BASE_ADDRESS + 0x11) |= 1;
ffe03013:	0020c0        	memw
ffe03016:	910b22        	l8ui	a2, a11, 145
ffe03019:	202230        	or	a2, a2, a3
ffe0301c:	0020c0        	memw
ffe0301f:	914b22        	s8i	a2, a11, 145
    *(volatile U8 *)(SDC_BASE_ADDRESS + 0x14) |= (1<<7);
ffe03022:	80a002        	movi	a0, 128
ffe03025:	0020c0        	memw
ffe03028:	940ba2        	l8ui	a10, a11, 148
ffe0302b:	20aa00        	or	a10, a10, a0
ffe0302e:	0020c0        	memw
ffe03031:	944ba2        	s8i	a10, a11, 148
    EventEN = 1 << EventID;

    while(!HalDualCoreGetSpinLock(HAL_SPINLOCK_EVENTBASE + EventOnwer))
        ;

    ModuleEvent[EventOnwer].Event &= ~EventEN;
ffe03034:	e97c      	movi.n	a9, -2
ffe03036:	482d82        	l32i	a8, a13, 0x120

        L1_TaskInit(&ulFreeDramBase,&ulFreeOTFBBase);
        HAL_Init(&ulFreeDramBase,&ulFreeOTFBBase);

        //update the free dram/sram address to parameter(status) buffer
        pParameter->EventParameterNormal[0] = ulFreeDramBase;
ffe03039:	4108      	l32i.n	a0, a1, 16
        pParameter->EventParameterNormal[1] = ulFreeOTFBBase;
ffe0303b:	3128      	l32i.n	a2, a1, 12
ffe0303d:	5138      	l32i.n	a3, a1, 20
ffe0303f:	2239      	s32i.n	a3, a2, 8

        L1_TaskInit(&ulFreeDramBase,&ulFreeOTFBBase);
        HAL_Init(&ulFreeDramBase,&ulFreeOTFBBase);

        //update the free dram/sram address to parameter(status) buffer
        pParameter->EventParameterNormal[0] = ulFreeDramBase;
ffe03041:	1209      	s32i.n	a0, a2, 4
ffe03043:	108890        	and	a8, a8, a9
ffe03046:	486d82        	s32i	a8, a13, 0x120
#endif
}

void HalDualCoreReleaseSpinLock(U8 LockId)
{
    *(volatile U32*)(SPINLOCK_BASE_ADDRESS + LockId*4) = 0;
ffe03049:	fa8f71        	l32r	a7, ffe01a88 <_bss_table_end+0x10c>
ffe0304c:	0020c0        	memw
ffe0304f:	07c9      	s32i.n	a12, a7, 0

    HalDualCoreReleaseSpinLock(HAL_SPINLOCK_EVENTBASE + EventOnwer);
ffe03051:	020c      	movi.n	a2, 0
ffe03053:	0001c6        	j	ffe0305e <L1_TaskEventHandle+0x122>

ffe03056 <L1_TaskEventHandle+0x11a>:
    }
    else if (L1_Event.EventReset)
    {

    }
    else if (L1_Event.EventShutDown)
ffe03056:	04b220        	extui	a11, a2, 2, 1
ffe03059:	320c      	movi.n	a2, 3
ffe0305b:	932cb0        	movnez	a2, a12, a11
    else
    {

    }

    return Ret;
ffe0305e:	71c8      	l32i.n	a12, a1, 28
ffe03060:	81d8      	l32i.n	a13, a1, 32
ffe03062:	6108      	l32i.n	a0, a1, 24
ffe03064:	30c112        	addi	a1, a1, 48
ffe03067:	f00d      	ret.n

ffe03069 <L1_TaskEventHandle+0x12d>:
        //clear event,init finished!
        CommClearEvent(COMM_EVENT_OWNER_L1,COMM_EVENT_OFFSET_INIT);

        Ret = COMM_EVENT_STATUS_SUCCESS_NOEVENT;
    }
    else if (L1_Event.EventErrorHandling)
ffe03069:	046247        	bbci	a2, 4, ffe03071 <L1_TaskEventHandle+0x135>
ffe0306c:	0c2d      	mov.n	a2, a12
ffe0306e:	fffb06        	j	ffe0305e <L1_TaskEventHandle+0x122>

ffe03071 <L1_TaskEventHandle+0x135>:
    {
      //  L1_ErrorHandling();

        Ret = COMM_EVENT_STATUS_SUCCESS_NOEVENT;
    }
    else if (L1_Event.EventLLF)
ffe03071:	02e217        	bbsi	a2, 1, ffe03077 <L1_TaskEventHandle+0x13b>
    {

    }
    else if (L1_Event.EventReset)
ffe03074:	de6237        	bbci	a2, 3, ffe03056 <L1_TaskEventHandle+0x11a>
    {
      //  L1_ErrorHandling();

        Ret = COMM_EVENT_STATUS_SUCCESS_NOEVENT;
    }
    else if (L1_Event.EventLLF)
ffe03077:	320c      	movi.n	a2, 3
ffe03079:	fff846        	j	ffe0305e <L1_TaskEventHandle+0x122>

ffe0307c <CommCheckEvent>:
}


U32 CommCheckEvent(U8 EventOnwer,COMMON_EVENT* EVENT)
{
    if (0 == ModuleEvent[EventOnwer].Event)
ffe0307c:	fa4241        	l32r	a4, ffe01984 <_bss_table_end+0x8>
ffe0307f:	482442        	l32i	a4, a4, 0x120
ffe03082:	54cc      	bnez.n	a4, ffe0308b <CommCheckEvent+0xf>
    {
        EVENT->Event = 0;
ffe03084:	040c      	movi.n	a4, 0
ffe03086:	0249      	s32i.n	a4, a2, 0
}


U32 CommCheckEvent(U8 EventOnwer,COMMON_EVENT* EVENT)
{
    if (0 == ModuleEvent[EventOnwer].Event)
ffe03088:	0000c6        	j	ffe0308f <CommCheckEvent+0x13>

ffe0308b <CommCheckEvent+0xf>:
    {
        EVENT->Event = 0;
        return COMM_EVENT_STATUS_SUCCESS_NOEVENT;
    }

    EVENT->Event = ModuleEvent[EventOnwer].Event;
ffe0308b:	0249      	s32i.n	a4, a2, 0

    return COMM_EVENT_STATUS_GET_EVENTPEND;
ffe0308d:	240c      	movi.n	a4, 2
ffe0308f:	042d      	mov.n	a2, a4
ffe03091:	f00d      	ret.n

ffe03093 <CommCheckEvent+0x17>:
	...

ffe03094 <L1_TaskSchedule>:
Description :L1 task schedule.
Others      :
Modify      :
****************************************************************************/
U8 L1_TaskSchedule(void)
{
ffe03094:	f0c112        	addi	a1, a1, -16
ffe03097:	11c9      	s32i.n	a12, a1, 4
ffe03099:	0109      	s32i.n	a0, a1, 0
    if(COMM_EVENT_STATUS_BLOCKING == L1_TaskEventHandle())
ffe0309b:	ffea05        	call0	ffe02f3c <L1_TaskEventHandle>
ffe0309e:	fa39c1        	l32r	a12, ffe01984 <_bss_table_end+0x8>
ffe030a1:	fdc202        	addi	a0, a2, -3
ffe030a4:	0ad016        	beqz	a0, ffe03155 <L1_TaskSchedule+0xc1>
        return g_ucL1returnflag;

    if(NULL == gCurHCMD)
ffe030a7:	312c22        	l32i	a2, a12, 196
ffe030aa:	42cc      	bnez.n	a2, ffe030b2 <L1_TaskSchedule+0x1e>
    {
        gCurHCMD = L1_HostCMDSelect();
ffe030ac:	ffe585        	call0	ffe02f08 <L1_HostCMDSelect>
ffe030af:	316c22        	s32i	a2, a12, 196

ffe030b2 <L1_TaskSchedule+0x1e>:
ffe030b2:	140c      	movi.n	a4, 1
ffe030b4:	000c      	movi.n	a0, 0
    }

    if(NULL != gCurHCMD)
ffe030b6:	082216        	beqz	a2, ffe0313c <L1_TaskSchedule+0xa8>
    {
        g_ucL1returnflag = 0;
ffe030b9:	d84c02        	s8i	a0, a12, 216
        HAL_HCmdProcessing(gCurHCMD->ucCmdTag);
        
        if(HCMD_TYPE_NONDATA == gCurHCMD->ucCmdType)
ffe030bc:	100232        	l8ui	a3, a2, 16
    }

    if(NULL != gCurHCMD)
    {
        g_ucL1returnflag = 0;
        HAL_HCmdProcessing(gCurHCMD->ucCmdTag);
ffe030bf:	250c      	movi.n	a5, 2
ffe030c1:	050262        	l8ui	a6, a2, 5
ffe030c4:	fa6971        	l32r	a7, ffe01a68 <_bss_table_end+0xec>
ffe030c7:	a06660        	addx4	a6, a6, a6
ffe030ca:	a06670        	addx4	a6, a6, a7
ffe030cd:	7f4652        	s8i	a5, a6, 127
        
        if(HCMD_TYPE_NONDATA == gCurHCMD->ucCmdType)
ffe030d0:	3b1366        	bnei	a3, 1, ffe0310f <L1_TaskSchedule+0x7b>
        {
            if ( TRUE == L1_TaskScheduleNoneData(gCurHCMD) )
ffe030d3:	ff6305        	call0	ffe02704 <L1_TaskScheduleNoneData>
ffe030d6:	241266        	bnei	a2, 1, ffe030fe <L1_TaskSchedule+0x6a>
ffe030d9:	312cb2        	l32i	a11, a12, 196
            {
#ifndef FW_CTRL_ALL_SDBFISREADY
                HAL_SetSendSDBFISReady(gCurHCMD->ucCmdTag);
ffe030dc:	fa5391        	l32r	a9, ffe01a28 <_bss_table_end+0xac>
ffe030df:	050bb2        	l8ui	a11, a11, 5
ffe030e2:	1a0c      	movi.n	a10, 1
ffe030e4:	401b00        	ssl	a11
ffe030e7:	a1aa00        	sll	a10, a10
ffe030ea:	0020c0        	memw
ffe030ed:	952982        	l32i	a8, a9, 0x254
ffe030f0:	2088a0        	or	a8, a8, a10
ffe030f3:	0020c0        	memw
ffe030f6:	956982        	s32i	a8, a9, 0x254
#endif
                gCurHCMD = NULL;
ffe030f9:	070c      	movi.n	a7, 0
ffe030fb:	316c72        	s32i	a7, a12, 196
            }

            if(gpCurSubCmd != NULL)
ffe030fe:	322c02        	l32i	a0, a12, 200
ffe03101:	a0bc      	beqz.n	a0, ffe0313f <L1_TaskSchedule+0xab>
            {
                DBG_Printf("HCmdType NONDATA gpCurSubCmd != NULL ERROR!!\n");
ffe03103:	fa6221        	l32r	a2, ffe01a8c <_bss_table_end+0x110>
ffe03106:	01db85        	call0	ffe04ec0 <dbg_printf>
                DBG_Getch();
ffe03109:	01adc5        	call0	ffe04be8 <DBG_Getch>
ffe0310c:	000bc6        	j	ffe0313f <L1_TaskSchedule+0xab>

ffe0310f <L1_TaskSchedule+0x7b>:
            }
        }
        else
        {
            /* Check multiple DRQ enable status for READ MULTIPLE and similar command */
            if ( FAIL == L1_SataCheckPIOMultipleEnable(gCurHCMD) ) {
ffe0310f:	ff5cc5        	call0	ffe026dc <L1_SataCheckPIOMultipleEnable>
ffe03112:	82cc      	bnez.n	a2, ffe0311e <L1_TaskSchedule+0x8a>
                gCurHCMD->ulCmdRemSector = 0;
ffe03114:	312c32        	l32i	a3, a12, 196
ffe03117:	020c      	movi.n	a2, 0
ffe03119:	3329      	s32i.n	a2, a3, 12
                HAL_SataSendAbortStatus();
ffe0311b:	ff5445        	call0	ffe02660 <HAL_SataSendAbortStatus>
            }

            if (gpCurSubCmd == NULL)
ffe0311e:	322c42        	l32i	a4, a12, 200
ffe03121:	a4dc      	bnez.n	a4, ffe0313f <L1_TaskSchedule+0xab>
            {
                /* Split a SubCmd */
                gpCurSubCmd = L1_SplitHCMD(gCurHCMD);
ffe03123:	312c22        	l32i	a2, a12, 196
ffe03126:	ff4605        	call0	ffe02588 <L1_SplitHCMD>

                if (0 == gCurHCMD->ulCmdRemSector)
ffe03129:	312c52        	l32i	a5, a12, 196
            }

            if (gpCurSubCmd == NULL)
            {
                /* Split a SubCmd */
                gpCurSubCmd = L1_SplitHCMD(gCurHCMD);
ffe0312c:	326c22        	s32i	a2, a12, 200

                if (0 == gCurHCMD->ulCmdRemSector)
ffe0312f:	3578      	l32i.n	a7, a5, 12
ffe03131:	060c      	movi.n	a6, 0
ffe03133:	835670        	moveqz	a5, a6, a7
ffe03136:	316c52        	s32i	a5, a12, 196
ffe03139:	000086        	j	ffe0313f <L1_TaskSchedule+0xab>

ffe0313c <L1_TaskSchedule+0xa8>:
            }
        }
    }
    else 
    {
        g_ucL1returnflag = 1;
ffe0313c:	d84c42        	s8i	a4, a12, 216
    }

    L1_TaskSataIO(gpCurSubCmd);
ffe0313f:	322c22        	l32i	a2, a12, 200
ffe03142:	fef1c5        	call0	ffe02060 <L1_TaskSataIO>

    if (NULL != gpCurSubCmd && SUBCMD_STAGE_SATAIO == gpCurSubCmd->SubCmdStage)
ffe03145:	322c02        	l32i	a0, a12, 200
ffe03148:	908c      	beqz.n	a0, ffe03155 <L1_TaskSchedule+0xc1>
ffe0314a:	170082        	l8ui	a8, a0, 23
ffe0314d:	044866        	bnei	a8, 4, ffe03155 <L1_TaskSchedule+0xc1>
    {
        gpCurSubCmd = NULL;
ffe03150:	090c      	movi.n	a9, 0
ffe03152:	326c92        	s32i	a9, a12, 200
Modify      :
****************************************************************************/
U8 L1_TaskSchedule(void)
{
    if(COMM_EVENT_STATUS_BLOCKING == L1_TaskEventHandle())
        return g_ucL1returnflag;
ffe03155:	d80c22        	l8ui	a2, a12, 216
    {
        gpCurSubCmd = NULL;
    }


    return g_ucL1returnflag;
ffe03158:	0108      	l32i.n	a0, a1, 0
ffe0315a:	11c8      	l32i.n	a12, a1, 4
ffe0315c:	10c112        	addi	a1, a1, 16
ffe0315f:	f00d      	ret.n

ffe03161 <L1_TaskSchedule+0xcd>:
ffe03161:	000000                                        ...

ffe03164 <BootUp>:
    U8 i;
    U8 p;

    ModuelEventParameter = (COMM_EVENT_PARAMETER(*)[COMM_EVENT_OWNER_COUNT])STATIC_PARAMETER_COMMON_EVENT_RESULT;

    for (i = 0 ; i < COMM_EVENT_OWNER_COUNT;i++)
ffe03164:	060c      	movi.n	a6, 0
ffe03166:	fa4a21        	l32r	a2, ffe01a90 <_bss_table_end+0x114>
ffe03169:	050c      	movi.n	a5, 0
ffe0316b:	730c      	movi.n	a3, 7

}


U32 DRAM_ATTR BootUp()
{
ffe0316d:	fa0571        	l32r	a7, ffe01984 <_bss_table_end+0x8>
ffe03170:	fa4981        	l32r	a8, ffe01a94 <_bss_table_end+0x118>
ffe03173:	f0c112        	addi	a1, a1, -16
ffe03176:	1109      	s32i.n	a0, a1, 4
void CommEventInit()
{
    U8 i;
    U8 p;

    ModuelEventParameter = (COMM_EVENT_PARAMETER(*)[COMM_EVENT_OWNER_COUNT])STATIC_PARAMETER_COMMON_EVENT_RESULT;
ffe03178:	266782        	s32i	a8, a7, 152

    for (i = 0 ; i < COMM_EVENT_OWNER_COUNT;i++)
    {
        ModuleEvent[i].Event = 0;

        for (p = 0 ; p < sizeof(COMM_EVENT_PARAMETER)/sizeof(U32);p++)
ffe0317b:	000c      	movi.n	a0, 0

ffe0317d <BootUp+0x19>:

    ModuelEventParameter = (COMM_EVENT_PARAMETER(*)[COMM_EVENT_OWNER_COUNT])STATIC_PARAMETER_COMMON_EVENT_RESULT;

    for (i = 0 ; i < COMM_EVENT_OWNER_COUNT;i++)
    {
        ModuleEvent[i].Event = 0;
ffe0317d:	a04670        	addx4	a4, a6, a7
ffe03180:	486452        	s32i	a5, a4, 0x120

        for (p = 0 ; p < sizeof(COMM_EVENT_PARAMETER)/sizeof(U32);p++)
ffe03183:	f04660        	subx8	a4, a6, a6
    U8 i;
    U8 p;

    ModuelEventParameter = (COMM_EVENT_PARAMETER(*)[COMM_EVENT_OWNER_COUNT])STATIC_PARAMETER_COMMON_EVENT_RESULT;

    for (i = 0 ; i < COMM_EVENT_OWNER_COUNT;i++)
ffe03186:	661b      	addi.n	a6, a6, 1
ffe03188:	746060        	extui	a6, a6, 0, 8
ffe0318b:	0ca376        	loopgtz	a3, ffe0319b <BootUp+0x37>
    {
        ModuleEvent[i].Event = 0;

        for (p = 0 ; p < sizeof(COMM_EVENT_PARAMETER)/sizeof(U32);p++)
        {
            *((U32*)&(*ModuelEventParameter)[i] + p) = 0;
ffe0318e:	340a      	add.n	a3, a4, a0

    for (i = 0 ; i < COMM_EVENT_OWNER_COUNT;i++)
    {
        ModuleEvent[i].Event = 0;

        for (p = 0 ; p < sizeof(COMM_EVENT_PARAMETER)/sizeof(U32);p++)
ffe03190:	001b      	addi.n	a0, a0, 1
        {
            *((U32*)&(*ModuelEventParameter)[i] + p) = 0;
ffe03192:	a03320        	addx4	a3, a3, a2
ffe03195:	7f6352        	s32i	a5, a3, 0x1fc

    for (i = 0 ; i < COMM_EVENT_OWNER_COUNT;i++)
    {
        ModuleEvent[i].Event = 0;

        for (p = 0 ; p < sizeof(COMM_EVENT_PARAMETER)/sizeof(U32);p++)
ffe03198:	740000        	extui	a0, a0, 0, 8

ffe0319b <BootUp+0x37>:
ffe0319b:	000c      	movi.n	a0, 0
ffe0319d:	730c      	movi.n	a3, 7
    U8 i;
    U8 p;

    ModuelEventParameter = (COMM_EVENT_PARAMETER(*)[COMM_EVENT_OWNER_COUNT])STATIC_PARAMETER_COMMON_EVENT_RESULT;

    for (i = 0 ; i < COMM_EVENT_OWNER_COUNT;i++)
ffe0319f:	da3666        	bnei	a6, 3, ffe0317d <BootUp+0x19>
void DRAM_ATTR BootUpInit()
{
#ifndef OTFB_VERSION
    pBootMethodSeletor = (U32*)STATIC_PARAMETER_BOOT_SELECTOR_FLAG;
#endif
    CommEventInit();
ffe031a2:	120c      	movi.n	a2, 1
{
    U32 EventEN;

    EventEN = 1 << EventID;

    if (0 != (ModuleEvent[EventOnwer].Event & EventEN))
ffe031a4:	482702        	l32i	a0, a7, 0x120
    CommGetEventParameter(COMM_EVENT_OWNER_L1,&pParameter);

    //DWORD0 free dram address,DW1 free otfb sram address
    pParameter->EventParameterNormal[0] = ulFreeDramBase;
    pParameter->EventParameterNormal[1] = ulFreeOTFBBase;
    pParameter->EventParameterNormal[2] = ulSaveDramBase;
ffe031a7:	fa3e91        	l32r	a9, ffe01aa0 <_bss_table_end+0x124>
    //get parameter from comm event
    CommGetEventParameter(COMM_EVENT_OWNER_L1,&pParameter);

    //DWORD0 free dram address,DW1 free otfb sram address
    pParameter->EventParameterNormal[0] = ulFreeDramBase;
    pParameter->EventParameterNormal[1] = ulFreeOTFBBase;
ffe031aa:	fa3ca1        	l32r	a10, ffe01a9c <_bss_table_end+0x120>

    //get parameter from comm event
    CommGetEventParameter(COMM_EVENT_OWNER_L1,&pParameter);

    //DWORD0 free dram address,DW1 free otfb sram address
    pParameter->EventParameterNormal[0] = ulFreeDramBase;
ffe031ad:	fa3ab1        	l32r	a11, ffe01a98 <_bss_table_end+0x11c>
ffe031b0:	18b9      	s32i.n	a11, a8, 4
    pParameter->EventParameterNormal[1] = ulFreeOTFBBase;
ffe031b2:	28a9      	s32i.n	a10, a8, 8
    pParameter->EventParameterNormal[2] = ulSaveDramBase;
ffe031b4:	3899      	s32i.n	a9, a8, 12
ffe031b6:	0de007        	bbsi	a0, 0, ffe031c7 <BootUp+0x63>
        return COMM_EVENT_STATUS_SEND_BUSY;

    while(!HalDualCoreGetSpinLock(HAL_SPINLOCK_EVENTBASE + EventOnwer))
        ;

    ModuleEvent[EventOnwer].Event |= EventEN;
ffe031b9:	204020        	or	a4, a0, a2
ffe031bc:	486742        	s32i	a4, a7, 0x120
ffe031bf:	fa3231        	l32r	a3, ffe01a88 <_bss_table_end+0x10c>
ffe031c2:	0020c0        	memw
ffe031c5:	0359      	s32i.n	a5, a3, 0

ffe031c7 <BootUp+0x63>:

    //L1_TaskSchedule();

    do 
    { 
        L1_TaskSchedule();
ffe031c7:	ffecc5        	call0	ffe03094 <L1_TaskSchedule>
ffe031ca:	012d      	mov.n	a2, a1
ffe031cc:	ffeac5        	call0	ffe0307c <CommCheckEvent>
        CommCheckEvent(COMM_EVENT_OWNER_L1,&Event);
    } while (Event.EventInit);
ffe031cf:	0158      	l32i.n	a5, a1, 0
ffe031d1:	f2e507        	bbsi	a5, 0, ffe031c7 <BootUp+0x63>
    BootUpInit();

    //step 1:init
    BootUpInitL1(&ulFreeDramBase, &ulFreeOTFBBase, &ulSaveDramBase);

    return BOOTUP_OK;
ffe031d4:	020c      	movi.n	a2, 0
ffe031d6:	1108      	l32i.n	a0, a1, 4
ffe031d8:	10c112        	addi	a1, a1, 16
ffe031db:	f00d      	ret.n

ffe031dd <BootUp+0x79>:
ffe031dd:	000000                                        ...

ffe031e0 <HAL_MpSataMain>:
#ifndef SIM


//int cmain(void)
void HAL_MpSataMain (void)
{
ffe031e0:	f0c112        	addi	a1, a1, -16
    U32 boot_param;
    DBG_TRACE(TRACE_SATA_MP);
ffe031e3:	fa3001        	l32r	a0, ffe01aa4 <_bss_table_end+0x128>
ffe031e6:	fa3021        	l32r	a2, ffe01aa8 <_bss_table_end+0x12c>
ffe031e9:	0020c0        	memw
ffe031ec:	a06202        	s32i	a0, a2, 0x280
    DBG_Printf("Enter sata mp...\n");
ffe031ef:	fa2f21        	l32r	a2, ffe01aac <_bss_table_end+0x130>
ffe031f2:	01ccc5        	call0	ffe04ec0 <dbg_printf>
U32 g_BootUpOk = 0;/* add by henryluo for normal bootup test */

U32 FirmwareMain(U32 FirwmareParameter)
{

    if (BOOTUP_OK == BootUp())
ffe031f5:	fff6c5        	call0	ffe03164 <BootUp>
ffe031f8:	f2cc      	bnez.n	a2, ffe0320b <HAL_MpSataMain+0x2b>
    20141028    Gavin   add "INLINE" attribute
------------------------------------------------------------------------------*/
INLINE void HAL_DisableMCUIntAck(void)
{
#ifndef SIM
    XT_RSIL(15);
ffe031fa:	006f30        	rsil	a3, 15
#endif

#ifndef SIM

        HAL_DisableMCUIntAck();
        HAL_InitInterrupt(TOP_INTSRC_SDC,BIT_ORINT_SDC);
ffe031fd:	024c      	movi.n	a2, 64
ffe031ff:	00a232        	movi	a3, 0x200
ffe03202:	007c05        	call0	ffe039c4 <HAL_InitInterrupt>
    20141028    Gavin   add "INLINE" attribute
------------------------------------------------------------------------------*/
INLINE void HAL_EnableMCUIntAck(void)
{
#ifndef SIM
    XT_RSIL(0);
ffe03205:	006040        	rsil	a4, 0
        HAL_EnableMCUIntAck();
ffe03208:	000086        	j	ffe0320e <HAL_MpSataMain+0x2e>

ffe0320b <HAL_MpSataMain+0x2b>:
#endif
        //   MCUTaskMain();
    }
    else
    {
        DBG_Getch();
ffe0320b:	019dc5        	call0	ffe04be8 <DBG_Getch>
    }

    DBG_Printf("boot up ok !\n");
ffe0320e:	fa2821        	l32r	a2, ffe01ab0 <_bss_table_end+0x134>
ffe03211:	01cac5        	call0	ffe04ec0 <dbg_printf>
    #endif

#ifndef SIM
    while(1) 
    {           
        HAL_UartDBG();
ffe03214:	0080c5        	call0	ffe03a24 <HAL_UartDBG>

}

void MCU0TaskSchedule()
{
    L1_TaskSchedule();
ffe03217:	ffe7c5        	call0	ffe03094 <L1_TaskSchedule>
        MCU0TaskSchedule();
    }
ffe0321a:	fffd86        	j	ffe03214 <HAL_MpSataMain+0x34>

ffe0321d <HAL_MpSataMain+0x3d>:
ffe0321d:	000000                                        ...

ffe03220 <HAL_UartProcDMAWrData>:
    }
    SET_NEXT_STATE(UART_STATE_PROC_RECYCLE);
}

void HAL_UartProcDMAWrData(void)
{
ffe03220:	f9d951        	l32r	a5, ffe01984 <_bss_table_end+0x8>
    U32 i;
    if(UART_SUCC == l_tTxPack.ucStatus)
ffe03223:	6d0522        	l8ui	a2, a5, 109
    {
        for (i=0;i<l_tRxPack.ucCNT;i++,l_tMgr.ulDmaWrAddr+=4)
ffe03226:	7d0562        	l8ui	a6, a5, 125
ffe03229:	c2dc      	bnez.n	a2, ffe03249 <HAL_UartProcDMAWrData+0x29>
ffe0322b:	569c      	beqz.n	a6, ffe03244 <HAL_UartProcDMAWrData+0x24>
ffe0322d:	232532        	l32i	a3, a5, 140
ffe03230:	054d      	mov.n	a4, a5
ffe03232:	0b9676        	loopnez	a6, ffe03241 <HAL_UartProcDMAWrData+0x21>
        {
            //DBG_Printf("ADDR:%x , DATA:%x\n",l_tMgr.ulDmaWrAddr,l_tRxPack.ulDWord[i]);
            *((volatile U32*)(l_tMgr.ulDmaWrAddr)) = l_tRxPack.ulDWord[i];
ffe03235:	1c2462        	l32i	a6, a4, 112
ffe03238:	0020c0        	memw
ffe0323b:	0369      	s32i.n	a6, a3, 0
void HAL_UartProcDMAWrData(void)
{
    U32 i;
    if(UART_SUCC == l_tTxPack.ucStatus)
    {
        for (i=0;i<l_tRxPack.ucCNT;i++,l_tMgr.ulDmaWrAddr+=4)
ffe0323d:	444b      	addi.n	a4, a4, 4
ffe0323f:	334b      	addi.n	a3, a3, 4

ffe03241 <HAL_UartProcDMAWrData+0x21>:
ffe03241:	236532        	s32i	a3, a5, 140

ffe03244 <HAL_UartProcDMAWrData+0x24>:
        {
            //DBG_Printf("ADDR:%x , DATA:%x\n",l_tMgr.ulDmaWrAddr,l_tRxPack.ulDWord[i]);
            *((volatile U32*)(l_tMgr.ulDmaWrAddr)) = l_tRxPack.ulDWord[i];
        }      
        l_tTxPack.ucOpcode = UART_VENDER_CMD_OPCODE_DMA_WR_DATA;
ffe03244:	670c      	movi.n	a7, 6
ffe03246:	6c4572        	s8i	a7, a5, 108
    }
    SET_NEXT_STATE(UART_STATE_PROC_RECYCLE);
ffe03249:	780c      	movi.n	a8, 7
ffe0324b:	216582        	s32i	a8, a5, 132
}
ffe0324e:	f00d      	ret.n

ffe03250 <HAL_UartProcDMAWrOp>:
{
    SET_NEXT_STATE(UART_STATE_RX);
}

void HAL_UartProcDMAWrOp(void)
{
ffe03250:	f9cd31        	l32r	a3, ffe01984 <_bss_table_end+0x8>
    if(UART_SUCC == l_tTxPack.ucStatus)
    {
        l_tMgr.ulDmaWrAddr = l_tRxPack.tData.ulAddr;
        l_tTxPack.ucOpcode = UART_VENDER_CMD_OPCODE_DMA_WR_OP;
    }
    SET_NEXT_STATE(UART_STATE_PROC_RECYCLE);
ffe03253:	760c      	movi.n	a6, 7
}

void HAL_UartProcDMAWrOp(void)
{
    TX_PACKET tTxPack;
    if(UART_SUCC == l_tTxPack.ucStatus)
ffe03255:	6d0322        	l8ui	a2, a3, 109
    {
        l_tMgr.ulDmaWrAddr = l_tRxPack.tData.ulAddr;
        l_tTxPack.ucOpcode = UART_VENDER_CMD_OPCODE_DMA_WR_OP;
    }
    SET_NEXT_STATE(UART_STATE_PROC_RECYCLE);
ffe03258:	216362        	s32i	a6, a3, 132
ffe0325b:	92cc      	bnez.n	a2, ffe03268 <HAL_UartProcDMAWrOp+0x18>
{
    TX_PACKET tTxPack;
    if(UART_SUCC == l_tTxPack.ucStatus)
    {
        l_tMgr.ulDmaWrAddr = l_tRxPack.tData.ulAddr;
        l_tTxPack.ucOpcode = UART_VENDER_CMD_OPCODE_DMA_WR_OP;
ffe0325d:	540c      	movi.n	a4, 5
void HAL_UartProcDMAWrOp(void)
{
    TX_PACKET tTxPack;
    if(UART_SUCC == l_tTxPack.ucStatus)
    {
        l_tMgr.ulDmaWrAddr = l_tRxPack.tData.ulAddr;
ffe0325f:	1c2352        	l32i	a5, a3, 112
ffe03262:	236352        	s32i	a5, a3, 140
        l_tTxPack.ucOpcode = UART_VENDER_CMD_OPCODE_DMA_WR_OP;
ffe03265:	6c4342        	s8i	a4, a3, 108

ffe03268 <HAL_UartProcDMAWrOp+0x18>:
    }
    SET_NEXT_STATE(UART_STATE_PROC_RECYCLE);
}
ffe03268:	f00d      	ret.n

ffe0326a <HAL_UartProcDMAWrOp+0x1a>:
	...

ffe0326c <HAL_UartProcFinish>:

*************************************************************************/

void HAL_UartProcFinish(void)
{
    SET_NEXT_STATE(UART_STATE_RX);
ffe0326c:	f9c631        	l32r	a3, ffe01984 <_bss_table_end+0x8>
ffe0326f:	020c      	movi.n	a2, 0
ffe03271:	216322        	s32i	a2, a3, 132
}
ffe03274:	f00d      	ret.n

ffe03276 <HAL_UartProcFinish+0xa>:
	...

ffe03278 <HAL_UartProcRecycle>:

*************************************************************************/

void HAL_UartProcRecycle(void)
{
    DBG_Printf("Enter RECYCLE\n");
ffe03278:	fa0f21        	l32r	a2, ffe01ab4 <_bss_table_end+0x138>
    2015/4/16   Victor Zhang  First create

*************************************************************************/

void HAL_UartProcRecycle(void)
{
ffe0327b:	f0c112        	addi	a1, a1, -16
ffe0327e:	0109      	s32i.n	a0, a1, 0
    DBG_Printf("Enter RECYCLE\n");
ffe03280:	01c3c5        	call0	ffe04ec0 <dbg_printf>
    l_tMgr.ulRevDataLen = 0;
ffe03283:	f9c021        	l32r	a2, ffe01984 <_bss_table_end+0x8>
ffe03286:	030c      	movi.n	a3, 0
ffe03288:	226232        	s32i	a3, a2, 136
    HAL_MemZero((U32*)&l_tRxPack,UART_PACKET_SIZE);
ffe0328b:	430c      	movi.n	a3, 4
ffe0328d:	70c222        	addi	a2, a2, 112
ffe03290:	016705        	call0	ffe04904 <HAL_MemZero>
    SET_NEXT_STATE(UART_STATE_FINISH);
ffe03293:	f9bc51        	l32r	a5, ffe01984 <_bss_table_end+0x8>
ffe03296:	840c      	movi.n	a4, 8
}
ffe03298:	0108      	l32i.n	a0, a1, 0
ffe0329a:	10c112        	addi	a1, a1, 16
void HAL_UartProcRecycle(void)
{
    DBG_Printf("Enter RECYCLE\n");
    l_tMgr.ulRevDataLen = 0;
    HAL_MemZero((U32*)&l_tRxPack,UART_PACKET_SIZE);
    SET_NEXT_STATE(UART_STATE_FINISH);
ffe0329d:	216542        	s32i	a4, a5, 132
}
ffe032a0:	f00d      	ret.n

ffe032a2 <HAL_UartProcRecycle+0x2a>:
	...

ffe032a4 <HAL_UartProcWrite>:
*************************************************************************/
void HAL_UartProcWrite(void)
{
    U32 i;
    U32 *pDst = (U32*)l_tRxPack.tData.ulAddr;
    DBG_Printf("Enter WRITE\n");
ffe032a4:	fa0521        	l32r	a2, ffe01ab8 <_bss_table_end+0x13c>
History:
    2015/4/16   Victor Zhang  First create

*************************************************************************/
void HAL_UartProcWrite(void)
{
ffe032a7:	f0c112        	addi	a1, a1, -16
ffe032aa:	21d9      	s32i.n	a13, a1, 8
ffe032ac:	11c9      	s32i.n	a12, a1, 4
ffe032ae:	f9b5d1        	l32r	a13, ffe01984 <_bss_table_end+0x8>
ffe032b1:	0109      	s32i.n	a0, a1, 0
    U32 i;
    U32 *pDst = (U32*)l_tRxPack.tData.ulAddr;
ffe032b3:	1c2dc2        	l32i	a12, a13, 112
    DBG_Printf("Enter WRITE\n");
ffe032b6:	01c085        	call0	ffe04ec0 <dbg_printf>

    if(UART_SUCC == l_tTxPack.ucStatus)
ffe032b9:	6d0d02        	l8ui	a0, a13, 109
        {
            *pDst++ = l_tRxPack.tData.ulData[i];
        }      
        l_tTxPack.ucOpcode = UART_VENDER_CMD_OPCODE_WRITE;
    }
    SET_NEXT_STATE(UART_STATE_PROC_RECYCLE); 
ffe032bc:	770c      	movi.n	a7, 7
ffe032be:	d0dc      	bnez.n	a0, ffe032df <HAL_UartProcWrite+0x3b>
    U32 *pDst = (U32*)l_tRxPack.tData.ulAddr;
    DBG_Printf("Enter WRITE\n");

    if(UART_SUCC == l_tTxPack.ucStatus)
    {
        for (i=0;i<l_tRxPack.ucCNT;i++)
ffe032c0:	7d0d22        	l8ui	a2, a13, 125
        {
            *pDst++ = l_tRxPack.tData.ulData[i];
        }      
        l_tTxPack.ucOpcode = UART_VENDER_CMD_OPCODE_WRITE;
ffe032c3:	160c      	movi.n	a6, 1
ffe032c5:	329c      	beqz.n	a2, ffe032dc <HAL_UartProcWrite+0x38>
    U32 *pDst = (U32*)l_tRxPack.tData.ulAddr;
    DBG_Printf("Enter WRITE\n");

    if(UART_SUCC == l_tTxPack.ucStatus)
    {
        for (i=0;i<l_tRxPack.ucCNT;i++)
ffe032c7:	000c      	movi.n	a0, 0
ffe032c9:	0d4d      	mov.n	a4, a13

ffe032cb <HAL_UartProcWrite+0x27>:
ffe032cb:	001b      	addi.n	a0, a0, 1
        {
            *pDst++ = l_tRxPack.tData.ulData[i];
ffe032cd:	1d2452        	l32i	a5, a4, 116
    U32 *pDst = (U32*)l_tRxPack.tData.ulAddr;
    DBG_Printf("Enter WRITE\n");

    if(UART_SUCC == l_tTxPack.ucStatus)
    {
        for (i=0;i<l_tRxPack.ucCNT;i++)
ffe032d0:	444b      	addi.n	a4, a4, 4
        {
            *pDst++ = l_tRxPack.tData.ulData[i];
ffe032d2:	0c59      	s32i.n	a5, a12, 0
    U32 *pDst = (U32*)l_tRxPack.tData.ulAddr;
    DBG_Printf("Enter WRITE\n");

    if(UART_SUCC == l_tTxPack.ucStatus)
    {
        for (i=0;i<l_tRxPack.ucCNT;i++)
ffe032d4:	7d0d32        	l8ui	a3, a13, 125
        {
            *pDst++ = l_tRxPack.tData.ulData[i];
ffe032d7:	cc4b      	addi.n	a12, a12, 4
    U32 *pDst = (U32*)l_tRxPack.tData.ulAddr;
    DBG_Printf("Enter WRITE\n");

    if(UART_SUCC == l_tTxPack.ucStatus)
    {
        for (i=0;i<l_tRxPack.ucCNT;i++)
ffe032d9:	ee3037        	bltu	a0, a3, ffe032cb <HAL_UartProcWrite+0x27>
        {
            *pDst++ = l_tRxPack.tData.ulData[i];
        }      
        l_tTxPack.ucOpcode = UART_VENDER_CMD_OPCODE_WRITE;
ffe032dc:	6c4d62        	s8i	a6, a13, 108
    }
    SET_NEXT_STATE(UART_STATE_PROC_RECYCLE); 
}
ffe032df:	0108      	l32i.n	a0, a1, 0
        {
            *pDst++ = l_tRxPack.tData.ulData[i];
        }      
        l_tTxPack.ucOpcode = UART_VENDER_CMD_OPCODE_WRITE;
    }
    SET_NEXT_STATE(UART_STATE_PROC_RECYCLE); 
ffe032e1:	216d72        	s32i	a7, a13, 132
}
ffe032e4:	11c8      	l32i.n	a12, a1, 4
ffe032e6:	21d8      	l32i.n	a13, a1, 8
ffe032e8:	10c112        	addi	a1, a1, 16
ffe032eb:	f00d      	ret.n

ffe032ed <HAL_UartProcWrite+0x49>:
ffe032ed:	000000                                        ...

ffe032f0 <HAL_UartProcRead>:
*************************************************************************/
void HAL_UartProcRead(void)
{
    U32 i;
    U32 *pSrc = (U32*)l_tRxPack.tData.ulAddr;
    DBG_Printf("Enter READ\n");
ffe032f0:	f9f321        	l32r	a2, ffe01abc <_bss_table_end+0x140>
History:
    2015/4/16   Victor Zhang  First create

*************************************************************************/
void HAL_UartProcRead(void)
{
ffe032f3:	f0c112        	addi	a1, a1, -16
ffe032f6:	21d9      	s32i.n	a13, a1, 8
ffe032f8:	11c9      	s32i.n	a12, a1, 4
ffe032fa:	f9a2d1        	l32r	a13, ffe01984 <_bss_table_end+0x8>
ffe032fd:	0109      	s32i.n	a0, a1, 0
    U32 i;
    U32 *pSrc = (U32*)l_tRxPack.tData.ulAddr;
ffe032ff:	1c2dc2        	l32i	a12, a13, 112
    DBG_Printf("Enter READ\n");
ffe03302:	01bbc5        	call0	ffe04ec0 <dbg_printf>
    if(UART_SUCC == l_tTxPack.ucStatus)
ffe03305:	6d0d02        	l8ui	a0, a13, 109
        {
            l_tTxPack.tData.ulData[i] = *pSrc++;
        }
        l_tTxPack.ucOpcode = UART_VENDER_CMD_OPCODE_READ;
    }
    SET_NEXT_STATE(UART_STATE_PROC_RECYCLE);
ffe03308:	750c      	movi.n	a5, 7
ffe0330a:	40dc      	bnez.n	a0, ffe03322 <HAL_UartProcRead+0x32>
    U32 i;
    U32 *pSrc = (U32*)l_tRxPack.tData.ulAddr;
    DBG_Printf("Enter READ\n");
    if(UART_SUCC == l_tTxPack.ucStatus)
    {
        for (i=0;i<l_tRxPack.ucCNT;i++)
ffe0330c:	7d0d22        	l8ui	a2, a13, 125
ffe0330f:	0d0d      	mov.n	a0, a13
ffe03311:	089276        	loopnez	a2, ffe0331d <HAL_UartProcRead+0x2d>
        {
            l_tTxPack.tData.ulData[i] = *pSrc++;
ffe03314:	0c38      	l32i.n	a3, a12, 0
ffe03316:	186032        	s32i	a3, a0, 96
ffe03319:	cc4b      	addi.n	a12, a12, 4
    U32 i;
    U32 *pSrc = (U32*)l_tRxPack.tData.ulAddr;
    DBG_Printf("Enter READ\n");
    if(UART_SUCC == l_tTxPack.ucStatus)
    {
        for (i=0;i<l_tRxPack.ucCNT;i++)
ffe0331b:	004b      	addi.n	a0, a0, 4

ffe0331d <HAL_UartProcRead+0x2d>:
        {
            l_tTxPack.tData.ulData[i] = *pSrc++;
        }
        l_tTxPack.ucOpcode = UART_VENDER_CMD_OPCODE_READ;
ffe0331d:	040c      	movi.n	a4, 0
ffe0331f:	6c4d42        	s8i	a4, a13, 108

ffe03322 <HAL_UartProcRead+0x32>:
    }
    SET_NEXT_STATE(UART_STATE_PROC_RECYCLE);
}
ffe03322:	0108      	l32i.n	a0, a1, 0
        {
            l_tTxPack.tData.ulData[i] = *pSrc++;
        }
        l_tTxPack.ucOpcode = UART_VENDER_CMD_OPCODE_READ;
    }
    SET_NEXT_STATE(UART_STATE_PROC_RECYCLE);
ffe03324:	216d52        	s32i	a5, a13, 132
}
ffe03327:	11c8      	l32i.n	a12, a1, 4
ffe03329:	21d8      	l32i.n	a13, a1, 8
ffe0332b:	10c112        	addi	a1, a1, 16
ffe0332e:	f00d      	ret.n

ffe03330 <HAL_UartProcJump>:

*************************************************************************/

void HAL_UartProcJump(void)
{
    DBG_Printf("Enter JUMP\n");
ffe03330:	f9e421        	l32r	a2, ffe01ac0 <_bss_table_end+0x144>
    2015/4/16   Victor Zhang  First create

*************************************************************************/

void HAL_UartProcJump(void)
{
ffe03333:	f0c112        	addi	a1, a1, -16
ffe03336:	0109      	s32i.n	a0, a1, 0
    DBG_Printf("Enter JUMP\n");
ffe03338:	01b845        	call0	ffe04ec0 <dbg_printf>
    if(UART_SUCC == l_tTxPack.ucStatus)
ffe0333b:	f99201        	l32r	a0, ffe01984 <_bss_table_end+0x8>
ffe0333e:	6d0022        	l8ui	a2, a0, 109
ffe03341:	e2cc      	bnez.n	a2, ffe03353 <HAL_UartProcJump+0x23>
    {
        l_tTxPack.ucOpcode = UART_VENDER_CMD_OPCODE_JUMP;
ffe03343:	220c      	movi.n	a2, 2
ffe03345:	003d      	mov.n	a3, a0
        ((PFUNC)l_tRxPack.tData.ulAddr)();
ffe03347:	1c2302        	l32i	a0, a3, 112
void HAL_UartProcJump(void)
{
    DBG_Printf("Enter JUMP\n");
    if(UART_SUCC == l_tTxPack.ucStatus)
    {
        l_tTxPack.ucOpcode = UART_VENDER_CMD_OPCODE_JUMP;
ffe0334a:	6c4322        	s8i	a2, a3, 108
        ((PFUNC)l_tRxPack.tData.ulAddr)();
ffe0334d:	0000c0        	callx0	a0
ffe03350:	f98d01        	l32r	a0, ffe01984 <_bss_table_end+0x8>

ffe03353 <HAL_UartProcJump+0x23>:
    }
    SET_NEXT_STATE(UART_STATE_PROC_RECYCLE);
ffe03353:	740c      	movi.n	a4, 7
ffe03355:	216042        	s32i	a4, a0, 132
}
ffe03358:	0108      	l32i.n	a0, a1, 0
ffe0335a:	10c112        	addi	a1, a1, 16
ffe0335d:	f00d      	ret.n

ffe0335f <HAL_UartProcJump+0x2f>:
	...

ffe03360 <HAL_UartPreProcPack>:

*************************************************************************/

void HAL_UartPreProcPack(void)
{
    DBG_Printf("Enter Pre Proc\n");
ffe03360:	f9d921        	l32r	a2, ffe01ac4 <_bss_table_end+0x148>
    2015/4/16   Victor Zhang  First create

*************************************************************************/

void HAL_UartPreProcPack(void)
{
ffe03363:	f0c112        	addi	a1, a1, -16
ffe03366:	0109      	s32i.n	a0, a1, 0
    DBG_Printf("Enter Pre Proc\n");
ffe03368:	01b545        	call0	ffe04ec0 <dbg_printf>
     
    if(RX_UNKNOWN())
ffe0336b:	f98601        	l32r	a0, ffe01984 <_bss_table_end+0x8>
ffe0336e:	7c0032        	l8ui	a3, a0, 124
        DBG_Printf("Pre Proc : UNKNOW\n");
        SET_NEXT_STATE(UART_STATE_PROC_ERROR);            
    }
    else
    {
        SET_NEXT_STATE(l_aUartPreProcCmdState[l_tRxPack.ucOpcode]);
ffe03371:	f9d641        	l32r	a4, ffe01acc <_bss_table_end+0x150>

void HAL_UartPreProcPack(void)
{
    DBG_Printf("Enter Pre Proc\n");
     
    if(RX_UNKNOWN())
ffe03374:	1473b6        	bltui	a3, 7, ffe0338c <HAL_UartPreProcPack+0x2c>
    {
        DBG_Printf("Pre Proc : UNKNOW\n");
ffe03377:	f9d421        	l32r	a2, ffe01ac8 <_bss_table_end+0x14c>
ffe0337a:	01b445        	call0	ffe04ec0 <dbg_printf>
ffe0337d:	f98101        	l32r	a0, ffe01984 <_bss_table_end+0x8>
        SET_NEXT_STATE(UART_STATE_PROC_ERROR);            
ffe03380:	930c      	movi.n	a3, 9

ffe03382 <HAL_UartPreProcPack+0x22>:
ffe03382:	216032        	s32i	a3, a0, 132
    }
    else
    {
        SET_NEXT_STATE(l_aUartPreProcCmdState[l_tRxPack.ucOpcode]);
    }
}
ffe03385:	0108      	l32i.n	a0, a1, 0
ffe03387:	10c112        	addi	a1, a1, 16
ffe0338a:	f00d      	ret.n

ffe0338c <HAL_UartPreProcPack+0x2c>:
        DBG_Printf("Pre Proc : UNKNOW\n");
        SET_NEXT_STATE(UART_STATE_PROC_ERROR);            
    }
    else
    {
        SET_NEXT_STATE(l_aUartPreProcCmdState[l_tRxPack.ucOpcode]);
ffe0338c:	a03340        	addx4	a3, a3, a4
ffe0338f:	9c2332        	l32i	a3, a3, 0x270
ffe03392:	fffb06        	j	ffe03382 <HAL_UartPreProcPack+0x22>

ffe03395 <HAL_UartPreProcPack+0x35>:
ffe03395:	000000                                        ...

ffe03398 <HAL_UartProcSig>:
    2015/4/16   Victor Zhang  First create

*************************************************************************/

void HAL_UartProcSig(void)
{
ffe03398:	453c      	movi.n	a5, 52
ffe0339a:	f0c112        	addi	a1, a1, -16
ffe0339d:	0109      	s32i.n	a0, a1, 0
ffe0339f:	f97901        	l32r	a0, ffe01984 <_bss_table_end+0x8>
ffe033a2:	392c      	movi.n	a9, 35
    U8 ucRxData; 
    ucRxData = (U8)l_tRxPack.ulDWord[0];

    switch(ucRxData)
ffe033a4:	700032        	l8ui	a3, a0, 112
    2015/4/16   Victor Zhang  First create

*************************************************************************/

void HAL_UartProcSig(void)
{
ffe033a7:	083c      	movi.n	a8, 48
    U8 ucRxData; 
    ucRxData = (U8)l_tRxPack.ulDWord[0];

    switch(ucRxData)
ffe033a9:	431387        	beq	a3, a8, ffe033f0 <HAL_UartProcSig+0x58>
ffe033ac:	563c      	movi.n	a6, 53
ffe033ae:	183c      	movi.n	a8, 49
ffe033b0:	551387        	beq	a3, a8, ffe03409 <HAL_UartProcSig+0x71>
ffe033b3:	373c      	movi.n	a7, 51
ffe033b5:	cdc322        	addi	a2, a3, -51
ffe033b8:	0ed216        	beqz	a2, ffe034a9 <HAL_UartProcSig+0x111>
ffe033bb:	641357        	beq	a3, a5, ffe03423 <HAL_UartProcSig+0x8b>
ffe033be:	169367        	bne	a3, a6, ffe033d8 <HAL_UartProcSig+0x40>
                l_ucSig = '#';
            }
        }break;

        case '5':{
            if('3'==l_ucSig)
ffe033c1:	900042        	l8ui	a4, a0, 144
ffe033c4:	229477        	bne	a4, a7, ffe033ea <HAL_UartProcSig+0x52>
            {
                l_ucSig = '5'; 
                DBG_Printf("%x",ucRxData);
ffe033c7:	f9c221        	l32r	a2, ffe01ad0 <_bss_table_end+0x154>
ffe033ca:	005d      	mov.n	a5, a0
        }break;

        case '5':{
            if('3'==l_ucSig)
            {
                l_ucSig = '5'; 
ffe033cc:	904562        	s8i	a6, a5, 144
                DBG_Printf("%x",ucRxData);
ffe033cf:	01af05        	call0	ffe04ec0 <dbg_printf>
ffe033d2:	000146        	j	ffe033db <HAL_UartProcSig+0x43>

ffe033d5 <HAL_UartProcSig+0x3d>:
                l_ucSig = '0';
                l_ucSig0 = 1;
                DBG_Printf("%x",ucRxData);

            }
            else if ('0' == l_ucSig)
ffe033d5:	691787        	beq	a7, a8, ffe03442 <HAL_UartProcSig+0xaa>
            {
                l_ucSig = '#';
            }
            break;
        default:{
           l_ucSig = '#';
ffe033d8:	904092        	s8i	a9, a0, 144
        }
    }
    
    SET_NEXT_STATE(UART_STATE_PROC_RECYCLE);
ffe033db:	f96a71        	l32r	a7, ffe01984 <_bss_table_end+0x8>
ffe033de:	760c      	movi.n	a6, 7

}
ffe033e0:	0108      	l32i.n	a0, a1, 0
ffe033e2:	10c112        	addi	a1, a1, 16
        default:{
           l_ucSig = '#';
        }
    }
    
    SET_NEXT_STATE(UART_STATE_PROC_RECYCLE);
ffe033e5:	216762        	s32i	a6, a7, 132

}
ffe033e8:	f00d      	ret.n

ffe033ea <HAL_UartProcSig+0x52>:
                l_ucSig = '5'; 
                DBG_Printf("%x",ucRxData);
            }
            else
            {
                l_ucSig = '#';
ffe033ea:	904092        	s8i	a9, a0, 144
ffe033ed:	fffa86        	j	ffe033db <HAL_UartProcSig+0x43>

ffe033f0 <HAL_UartProcSig+0x58>:
            }
        }break;

        case '0':
            if('4' == l_ucSig)
ffe033f0:	900072        	l8ui	a7, a0, 144
ffe033f3:	de9757        	bne	a7, a5, ffe033d5 <HAL_UartProcSig+0x3d>
ffe033f6:	009d      	mov.n	a9, a0
            {
                l_ucSig = '0';
                l_ucSig0 = 1;
                DBG_Printf("%x",ucRxData);
ffe033f8:	f9b621        	l32r	a2, ffe01ad0 <_bss_table_end+0x154>
        }break;

        case '0':
            if('4' == l_ucSig)
            {
                l_ucSig = '0';
ffe033fb:	904982        	s8i	a8, a9, 144
                l_ucSig0 = 1;
ffe033fe:	180c      	movi.n	a8, 1
ffe03400:	914982        	s8i	a8, a9, 145
                DBG_Printf("%x",ucRxData);
ffe03403:	01abc5        	call0	ffe04ec0 <dbg_printf>
ffe03406:	fff446        	j	ffe033db <HAL_UartProcSig+0x43>

ffe03409 <HAL_UartProcSig+0x71>:
    ucRxData = (U8)l_tRxPack.ulDWord[0];

    switch(ucRxData)
    {
        case '1':{
            if('5'==l_ucSig)
ffe03409:	9000a2        	l8ui	a10, a0, 144
ffe0340c:	0d9a67        	bne	a10, a6, ffe0341d <HAL_UartProcSig+0x85>
            {
                l_ucSig = '1';
                DBG_Printf("%x",ucRxData);
ffe0340f:	f9b021        	l32r	a2, ffe01ad0 <_bss_table_end+0x154>
ffe03412:	00bd      	mov.n	a11, a0
    switch(ucRxData)
    {
        case '1':{
            if('5'==l_ucSig)
            {
                l_ucSig = '1';
ffe03414:	904b82        	s8i	a8, a11, 144
                DBG_Printf("%x",ucRxData);
ffe03417:	01aa85        	call0	ffe04ec0 <dbg_printf>
ffe0341a:	ffef46        	j	ffe033db <HAL_UartProcSig+0x43>

ffe0341d <HAL_UartProcSig+0x85>:
            }
            else
            {
                l_ucSig = '#';
ffe0341d:	904092        	s8i	a9, a0, 144
ffe03420:	ffedc6        	j	ffe033db <HAL_UartProcSig+0x43>

ffe03423 <HAL_UartProcSig+0x8b>:
            l_ucSig= '3';
            DBG_Printf("%x",ucRxData);
        }break;
        
        case '4':{
            if('1'==l_ucSig)
ffe03423:	900022        	l8ui	a2, a0, 144
ffe03426:	129287        	bne	a2, a8, ffe0343c <HAL_UartProcSig+0xa4>
            {
                l_ucSig = '4';
                l_ucSig0 = 0;
                DBG_Printf("%x",ucRxData);
ffe03429:	f9a921        	l32r	a2, ffe01ad0 <_bss_table_end+0x154>
        
        case '4':{
            if('1'==l_ucSig)
            {
                l_ucSig = '4';
                l_ucSig0 = 0;
ffe0342c:	040c      	movi.n	a4, 0
ffe0342e:	006d      	mov.n	a6, a0
        }break;
        
        case '4':{
            if('1'==l_ucSig)
            {
                l_ucSig = '4';
ffe03430:	904652        	s8i	a5, a6, 144
                l_ucSig0 = 0;
ffe03433:	914642        	s8i	a4, a6, 145
                DBG_Printf("%x",ucRxData);
ffe03436:	01a885        	call0	ffe04ec0 <dbg_printf>
ffe03439:	ffe786        	j	ffe033db <HAL_UartProcSig+0x43>

ffe0343c <HAL_UartProcSig+0xa4>:

            }
            else
            {
                l_ucSig = '#';
ffe0343c:	904092        	s8i	a9, a0, 144
ffe0343f:	ffe606        	j	ffe033db <HAL_UartProcSig+0x43>

ffe03442 <HAL_UartProcSig+0xaa>:
                DBG_Printf("%x",ucRxData);

            }
            else if ('0' == l_ucSig)
            {
                DBG_Printf("%x",ucRxData);
ffe03442:	f9a321        	l32r	a2, ffe01ad0 <_bss_table_end+0x154>
ffe03445:	01a785        	call0	ffe04ec0 <dbg_printf>
                if (12 == ++l_ucSig0)
ffe03448:	f94f81        	l32r	a8, ffe01984 <_bss_table_end+0x8>
ffe0344b:	910872        	l8ui	a7, a8, 145
ffe0344e:	771b      	addi.n	a7, a7, 1
ffe03450:	747070        	extui	a7, a7, 0, 8
ffe03453:	914872        	s8i	a7, a8, 145
ffe03456:	81a766        	bnei	a7, 12, ffe033db <HAL_UartProcSig+0x43>
LOCAL volatile UART_LCR_REG * const l_pUartLcrReg = (volatile UART_LCR_REG *)&rUART_LCR;


void HAL_UartByteMode(BOOL bEnable)
{
    l_pUartLcrReg->READ_BYTE_MODE = bEnable;
ffe03459:	ffab42        	movi	a4, 0xfffffbff
ffe0345c:	f99c01        	l32r	a0, ffe01acc <_bss_table_end+0x150>
            else if ('0' == l_ucSig)
            {
                DBG_Printf("%x",ucRxData);
                if (12 == ++l_ucSig0)
                {
                    HAL_UartByteMode(FALSE);
ffe0345f:	f99d91        	l32r	a9, ffe01ad4 <_bss_table_end+0x158>
LOCAL volatile UART_LCR_REG * const l_pUartLcrReg = (volatile UART_LCR_REG *)&rUART_LCR;


void HAL_UartByteMode(BOOL bEnable)
{
    l_pUartLcrReg->READ_BYTE_MODE = bEnable;
ffe03462:	4008      	l32i.n	a0, a0, 16
ffe03464:	0020c0        	memw
ffe03467:	0038      	l32i.n	a3, a0, 0
ffe03469:	080c      	movi.n	a8, 0
ffe0346b:	103340        	and	a3, a3, a4
ffe0346e:	0020c0        	memw
ffe03471:	0039      	s32i.n	a3, a0, 0
    l_pUartLcrReg->READ_TRIG_MODE = bEnable;
ffe03473:	ffad22        	movi	a2, 0xfffffdff
ffe03476:	0020c0        	memw
ffe03479:	00b8      	l32i.n	a11, a0, 0
ffe0347b:	10bb20        	and	a11, a11, a2
ffe0347e:	0020c0        	memw
ffe03481:	00b9      	s32i.n	a11, a0, 0
            {
                DBG_Printf("%x",ucRxData);
                if (12 == ++l_ucSig0)
                {
                    HAL_UartByteMode(FALSE);
                    l_tMgr.ulMpEn = TRUE;
ffe03483:	f94031        	l32r	a3, ffe01984 <_bss_table_end+0x8>
ffe03486:	120c      	movi.n	a2, 1
ffe03488:	206322        	s32i	a2, a3, 128
                    rUART_TXR_DW = UART_SIGNATURE;         
ffe0348b:	f993a1        	l32r	a10, ffe01ad8 <_bss_table_end+0x15c>
ffe0348e:	0020c0        	memw
ffe03491:	8169a2        	s32i	a10, a9, 0x204
                    rUART_TXR_DW = 0;
ffe03494:	0020c0        	memw
ffe03497:	816982        	s32i	a8, a9, 0x204
                    rUART_TXR_DW = 0;
ffe0349a:	0020c0        	memw
ffe0349d:	816982        	s32i	a8, a9, 0x204
                    rUART_TXR_DW = 0;
ffe034a0:	0020c0        	memw
ffe034a3:	816982        	s32i	a8, a9, 0x204
ffe034a6:	ffcc46        	j	ffe033db <HAL_UartProcSig+0x43>

ffe034a9 <HAL_UartProcSig+0x111>:
ffe034a9:	002d      	mov.n	a2, a0
                l_ucSig = '#';
            }
        }break;

        case '3':{
            l_ucSig= '3';
ffe034ab:	904272        	s8i	a7, a2, 144
            DBG_Printf("%x",ucRxData);
ffe034ae:	f98821        	l32r	a2, ffe01ad0 <_bss_table_end+0x154>
ffe034b1:	01a0c5        	call0	ffe04ec0 <dbg_printf>
        }break;
ffe034b4:	ffc8c6        	j	ffe033db <HAL_UartProcSig+0x43>

ffe034b7 <HAL_UartProcSig+0x11f>:
	...

ffe034b8 <HAL_UartTxPack>:
*************************************************************************/
void HAL_UartTxPack(void)
{
    U32 i;

    DBG_Printf("Enter TX\n");
ffe034b8:	f98921        	l32r	a2, ffe01adc <_bss_table_end+0x160>
History:
    2015/4/16   Victor Zhang  First create

*************************************************************************/
void HAL_UartTxPack(void)
{
ffe034bb:	f0c112        	addi	a1, a1, -16
ffe034be:	0109      	s32i.n	a0, a1, 0
    U32 i;

    DBG_Printf("Enter TX\n");
ffe034c0:	019fc5        	call0	ffe04ec0 <dbg_printf>
*************************************************************************/

U16 HAL_UartCalcCRC(void)
{    
    U16 i,sum;
    for (i=0,sum=0;i<((UART_PACKET_SIZE<<1)-1);i++)
ffe034c3:	000c      	movi.n	a0, 0
ffe034c5:	030c      	movi.n	a3, 0
ffe034c7:	f92f41        	l32r	a4, ffe01984 <_bss_table_end+0x8>
ffe034ca:	07a022        	movi	a2, 7
ffe034cd:	0da276        	loopgtz	a2, ffe034de <HAL_UartTxPack+0x26>
ffe034d0:	631b      	addi.n	a6, a3, 1
    {
        sum ^= l_tTxPack.usWord[i];
ffe034d2:	905340        	addx2	a5, a3, a4
ffe034d5:	301552        	l16ui	a5, a5, 96
*************************************************************************/

U16 HAL_UartCalcCRC(void)
{    
    U16 i,sum;
    for (i=0,sum=0;i<((UART_PACKET_SIZE<<1)-1);i++)
ffe034d8:	f43060        	extui	a3, a6, 0, 16
    {
        sum ^= l_tTxPack.usWord[i];
ffe034db:	300500        	xor	a0, a5, a0

ffe034de <HAL_UartTxPack+0x26>:
{
    U32 i;

    DBG_Printf("Enter TX\n");
    l_tTxPack.usCRC = HAL_UartCalcCRC();
    for (i=0;i<UART_PACKET_SIZE;i++)
ffe034de:	f97d31        	l32r	a3, ffe01ad4 <_bss_table_end+0x158>
void HAL_UartTxPack(void)
{
    U32 i;

    DBG_Printf("Enter TX\n");
    l_tTxPack.usCRC = HAL_UartCalcCRC();
ffe034e1:	375402        	s16i	a0, a4, 110
ffe034e4:	460c      	movi.n	a6, 4
    for (i=0;i<UART_PACKET_SIZE;i++)
ffe034e6:	200440        	or	a0, a4, a4
ffe034e9:	0aa676        	loopgtz	a6, ffe034f7 <HAL_UartTxPack+0x3f>
    {
        rUART_TXR_DW = l_tTxPack.ulDWord[i];
ffe034ec:	182072        	l32i	a7, a0, 96
ffe034ef:	0020c0        	memw
ffe034f2:	816372        	s32i	a7, a3, 0x204
{
    U32 i;

    DBG_Printf("Enter TX\n");
    l_tTxPack.usCRC = HAL_UartCalcCRC();
    for (i=0;i<UART_PACKET_SIZE;i++)
ffe034f5:	004b      	addi.n	a0, a0, 4
    {
        rUART_TXR_DW = l_tTxPack.ulDWord[i];
    }

    SET_NEXT_STATE(UART_STATE_PROC_RECYCLE);
}
ffe034f7:	0108      	l32i.n	a0, a1, 0
    for (i=0;i<UART_PACKET_SIZE;i++)
    {
        rUART_TXR_DW = l_tTxPack.ulDWord[i];
    }

    SET_NEXT_STATE(UART_STATE_PROC_RECYCLE);
ffe034f9:	780c      	movi.n	a8, 7
ffe034fb:	216482        	s32i	a8, a4, 132
}
ffe034fe:	10c112        	addi	a1, a1, 16
ffe03501:	f00d      	ret.n

ffe03503 <HAL_UartTxPack+0x4b>:
	...

ffe03504 <HAL_UartRxPack>:
    2015/4/16   Victor Zhang  First create

*************************************************************************/

void HAL_UartRxPack(void)
{
ffe03504:	f0c112        	addi	a1, a1, -16
ffe03507:	11c9      	s32i.n	a12, a1, 4
ffe03509:	f91ec1        	l32r	a12, ffe01984 <_bss_table_end+0x8>
ffe0350c:	0109      	s32i.n	a0, a1, 0

    if(UART_PACKET_SIZE == l_tMgr.ulRevDataLen)
ffe0350e:	222c02        	l32i	a0, a12, 136
            SET_NEXT_STATE(UART_STATE_PROC_ERROR);
        }
        return;
    }
    
    if(UART_RXDATA_VALID())
ffe03511:	f97041        	l32r	a4, ffe01ad4 <_bss_table_end+0x158>
*************************************************************************/

void HAL_UartRxPack(void)
{

    if(UART_PACKET_SIZE == l_tMgr.ulRevDataLen)
ffe03514:	2b4066        	bnei	a0, 4, ffe03543 <HAL_UartRxPack+0x3f>
{
    U16 i,sum;

    // Calculate by WORD , double number of DWORD

    for (i=0,sum=0;i<(UART_PACKET_SIZE<<1);i++)
ffe03517:	030c      	movi.n	a3, 0
ffe03519:	000c      	movi.n	a0, 0
ffe0351b:	820c      	movi.n	a2, 8
ffe0351d:	10a276        	loopgtz	a2, ffe03531 <HAL_UartRxPack+0x2d>
ffe03520:	431b      	addi.n	a4, a3, 1
    {
        sum ^= l_tRxPack.usWord[i];
ffe03522:	9023c0        	addx2	a2, a3, a12
ffe03525:	381222        	l16ui	a2, a2, 112
{
    U16 i,sum;

    // Calculate by WORD , double number of DWORD

    for (i=0,sum=0;i<(UART_PACKET_SIZE<<1);i++)
ffe03528:	f43040        	extui	a3, a4, 0, 16
    {
        sum ^= l_tRxPack.usWord[i];
ffe0352b:	300200        	xor	a0, a2, a0
ffe0352e:	f40000        	extui	a0, a0, 0, 16

ffe03531 <HAL_UartRxPack+0x2d>:
void HAL_UartRxPack(void)
{

    if(UART_PACKET_SIZE == l_tMgr.ulRevDataLen)
    {
        if(HAL_UartCheckCRC()||UART_MP_DISALBED())
ffe03531:	b0bc      	beqz.n	a0, ffe03570 <HAL_UartRxPack+0x6c>
ffe03533:	202c32        	l32i	a3, a12, 128
ffe03536:	63bc      	beqz.n	a3, ffe03570 <HAL_UartRxPack+0x6c>
            DBG_Printf("RX:PRE PROC\n");
            SET_NEXT_STATE(UART_STATE_PREPROC);
        }
        else
        {
            DBG_Printf("RX:ERROR\n");
ffe03538:	f96a21        	l32r	a2, ffe01ae0 <_bss_table_end+0x164>
ffe0353b:	019845        	call0	ffe04ec0 <dbg_printf>
            SET_NEXT_STATE(UART_STATE_PROC_ERROR);
ffe0353e:	900c      	movi.n	a0, 9
ffe03540:	000d06        	j	ffe03578 <HAL_UartRxPack+0x74>

ffe03543 <HAL_UartRxPack+0x3f>:
        }
        return;
    }
    
    if(UART_RXDATA_VALID())
ffe03543:	0020c0        	memw
ffe03546:	842442        	l32i	a4, a4, 0x210
        }
        CLEAR_UART_RXDATA_VALID();                
    }
    else
    {
        SET_NEXT_STATE(UART_STATE_FINISH);
ffe03549:	890c      	movi.n	a9, 8
            SET_NEXT_STATE(UART_STATE_PROC_ERROR);
        }
        return;
    }
    
    if(UART_RXDATA_VALID())
ffe0354b:	2f74b7        	bbci	a4, 27, ffe0357e <HAL_UartRxPack+0x7a>
    {
        DBG_Printf("RX:RX\n");
ffe0354e:	f96521        	l32r	a2, ffe01ae4 <_bss_table_end+0x168>
ffe03551:	0196c5        	call0	ffe04ec0 <dbg_printf>
        if (UART_MP_DISALBED())
ffe03554:	202c62        	l32i	a6, a12, 128
            l_tRxPack.ulDWord[0] = rUART_RXR;
            SET_NEXT_STATE(UART_STATE_PROC_SIG);
        }
        else
        {
            l_tRxPack.ulDWord[l_tMgr.ulRevDataLen++] = rUART_RXR_DW;
ffe03557:	222c02        	l32i	a0, a12, 136
ffe0355a:	c6ec      	bnez.n	a6, ffe0358a <HAL_UartRxPack+0x86>
    if(UART_RXDATA_VALID())
    {
        DBG_Printf("RX:RX\n");
        if (UART_MP_DISALBED())
        {
            l_tRxPack.ulDWord[0] = rUART_RXR;
ffe0355c:	f96381        	l32r	a8, ffe01ae8 <_bss_table_end+0x16c>
ffe0355f:	0020c0        	memw
            SET_NEXT_STATE(UART_STATE_PROC_SIG);
ffe03562:	a70c      	movi.n	a7, 10
    if(UART_RXDATA_VALID())
    {
        DBG_Printf("RX:RX\n");
        if (UART_MP_DISALBED())
        {
            l_tRxPack.ulDWord[0] = rUART_RXR;
ffe03564:	880882        	l8ui	a8, a8, 136
ffe03567:	1c6c82        	s32i	a8, a12, 112
            SET_NEXT_STATE(UART_STATE_PROC_SIG);
ffe0356a:	216c72        	s32i	a7, a12, 132
ffe0356d:	000b46        	j	ffe0359e <HAL_UartRxPack+0x9a>

ffe03570 <HAL_UartRxPack+0x6c>:

    if(UART_PACKET_SIZE == l_tMgr.ulRevDataLen)
    {
        if(HAL_UartCheckCRC()||UART_MP_DISALBED())
        {
            DBG_Printf("RX:PRE PROC\n");
ffe03570:	f95f21        	l32r	a2, ffe01aec <_bss_table_end+0x170>
ffe03573:	0194c5        	call0	ffe04ec0 <dbg_printf>
            SET_NEXT_STATE(UART_STATE_PREPROC);
ffe03576:	300c      	movi.n	a0, 3
ffe03578:	216c02        	s32i	a0, a12, 132
ffe0357b:	000086        	j	ffe03581 <HAL_UartRxPack+0x7d>

ffe0357e <HAL_UartRxPack+0x7a>:
        }
        CLEAR_UART_RXDATA_VALID();                
    }
    else
    {
        SET_NEXT_STATE(UART_STATE_FINISH);
ffe0357e:	216c92        	s32i	a9, a12, 132
    }

}
ffe03581:	11c8      	l32i.n	a12, a1, 4
ffe03583:	0108      	l32i.n	a0, a1, 0
ffe03585:	10c112        	addi	a1, a1, 16
ffe03588:	f00d      	ret.n

ffe0358a <HAL_UartRxPack+0x86>:
            l_tRxPack.ulDWord[0] = rUART_RXR;
            SET_NEXT_STATE(UART_STATE_PROC_SIG);
        }
        else
        {
            l_tRxPack.ulDWord[l_tMgr.ulRevDataLen++] = rUART_RXR_DW;
ffe0358a:	a0b0c0        	addx4	a11, a0, a12
ffe0358d:	0020c0        	memw
ffe03590:	001b      	addi.n	a0, a0, 1
ffe03592:	f950a1        	l32r	a10, ffe01ad4 <_bss_table_end+0x158>
ffe03595:	226c02        	s32i	a0, a12, 136
ffe03598:	822aa2        	l32i	a10, a10, 0x208
ffe0359b:	1c6ba2        	s32i	a10, a11, 112
        }
        CLEAR_UART_RXDATA_VALID();                
ffe0359e:	0020c0        	memw
ffe035a1:	f94c31        	l32r	a3, ffe01ad4 <_bss_table_end+0x158>
ffe035a4:	f95321        	l32r	a2, ffe01af0 <_bss_table_end+0x174>
ffe035a7:	846322        	s32i	a2, a3, 0x210
ffe035aa:	fff4c6        	j	ffe03581 <HAL_UartRxPack+0x7d>

ffe035ad <HAL_UartRxPack+0xa9>:
ffe035ad:	000000                                        ...

ffe035b0 <HAL_UartProcClearTxBuf>:

*************************************************************************/

void HAL_UartProcClearTxBuf(void)
{
    HAL_MemZero((U32*)&l_tTxPack,UART_PACKET_SIZE);
ffe035b0:	f95121        	l32r	a2, ffe01af4 <_bss_table_end+0x178>
ffe035b3:	430c      	movi.n	a3, 4
    2015/4/16   Victor Zhang  First create

*************************************************************************/

void HAL_UartProcClearTxBuf(void)
{
ffe035b5:	f0c112        	addi	a1, a1, -16
ffe035b8:	0109      	s32i.n	a0, a1, 0
    HAL_MemZero((U32*)&l_tTxPack,UART_PACKET_SIZE);
ffe035ba:	013485        	call0	ffe04904 <HAL_MemZero>
    l_tTxPack.ucOpcode = UART_VENDER_CMD_OPCODE_CLRTXBUF;    
    SET_NEXT_STATE(UART_STATE_TX);
ffe035bd:	100c      	movi.n	a0, 1
*************************************************************************/

void HAL_UartProcClearTxBuf(void)
{
    HAL_MemZero((U32*)&l_tTxPack,UART_PACKET_SIZE);
    l_tTxPack.ucOpcode = UART_VENDER_CMD_OPCODE_CLRTXBUF;    
ffe035bf:	f8f121        	l32r	a2, ffe01984 <_bss_table_end+0x8>
ffe035c2:	430c      	movi.n	a3, 4
ffe035c4:	6c4232        	s8i	a3, a2, 108
    SET_NEXT_STATE(UART_STATE_TX);
ffe035c7:	216202        	s32i	a0, a2, 132
}
ffe035ca:	0108      	l32i.n	a0, a1, 0
ffe035cc:	10c112        	addi	a1, a1, 16
ffe035cf:	f00d      	ret.n

ffe035d1 <HAL_UartProcClearTxBuf+0x21>:
ffe035d1:	000000                                        ...

ffe035d4 <HAL_UartProcError>:
*************************************************************************/

void HAL_UartProcError(void)
{
    l_tTxPack.ucStatus = UART_FAIL;
    SET_NEXT_STATE(UART_STATE_PROC_RECYCLE);
ffe035d4:	720c      	movi.n	a2, 7
    2015/4/16   Victor Zhang  First create

*************************************************************************/

void HAL_UartProcError(void)
{
ffe035d6:	f8eb31        	l32r	a3, ffe01984 <_bss_table_end+0x8>
    l_tTxPack.ucStatus = UART_FAIL;
ffe035d9:	140c      	movi.n	a4, 1
ffe035db:	6d4342        	s8i	a4, a3, 109
    SET_NEXT_STATE(UART_STATE_PROC_RECYCLE);
ffe035de:	216322        	s32i	a2, a3, 132
}
ffe035e1:	f00d      	ret.n

ffe035e3 <HAL_UartProcError+0xf>:
	...

ffe035e4 <HAL_SpiExit4B..KB_1429880325>:
    2014/11/17 Victor Zhang  reconstruct

*******************************************************************************/

LOCAL void HAL_SpiExit4B(void)
{
ffe035e4:	f0c112        	addi	a1, a1, -16
ffe035e7:	1109      	s32i.n	a0, a1, 4
    if (l_pSpiRegSet->bsAddrMode != SPI_ADDR_3B)
ffe035e9:	f93801        	l32r	a0, ffe01acc <_bss_table_end+0x150>
ffe035ec:	3008      	l32i.n	a0, a0, 12
ffe035ee:	0109      	s32i.n	a0, a1, 0
ffe035f0:	f94221        	l32r	a2, ffe01af8 <_bss_table_end+0x17c>
ffe035f3:	0020c0        	memw
ffe035f6:	0008      	l32i.n	a0, a0, 0
ffe035f8:	100020        	and	a0, a0, a2
ffe035fb:	450b00        	extui	a0, a0, 27, 5
ffe035fe:	609c      	beqz.n	a0, ffe03618 <HAL_SpiExit4B..KB_1429880325+0x34>
ffe03600:	e9a022        	movi	a2, 233
ffe03603:	017f45        	call0	ffe04df8 <HAL_SpiSendCCmd..GB_1429880325>
    {
        HAL_SpiSendCCmd(SPI_CMD_EX4B,0,0);
        l_pSpiRegSet->bsAddrMode = SPI_ADDR_3B; 
ffe03606:	f93d41        	l32r	a4, ffe01afc <_bss_table_end+0x180>
ffe03609:	0020c0        	memw
ffe0360c:	0138      	l32i.n	a3, a1, 0
ffe0360e:	0328      	l32i.n	a2, a3, 0
ffe03610:	102240        	and	a2, a2, a4
ffe03613:	0020c0        	memw
ffe03616:	0329      	s32i.n	a2, a3, 0

ffe03618 <HAL_SpiExit4B..KB_1429880325+0x34>:
    }
}
ffe03618:	1108      	l32i.n	a0, a1, 4
ffe0361a:	10c112        	addi	a1, a1, 16
ffe0361d:	f00d      	ret.n

ffe0361f <HAL_SpiExit4B..KB_1429880325+0x3b>:
	...

ffe03620 <HAL_SpiEnter4B..JB_1429880325>:
    2014/11/17 Victor Zhang  reconstruct

*******************************************************************************/

LOCAL void HAL_SpiEnter4B(void)
{
ffe03620:	f0c112        	addi	a1, a1, -16
ffe03623:	1109      	s32i.n	a0, a1, 4
    if (l_pSpiRegSet->bsAddrMode != SPI_ADDR_4B)
ffe03625:	f92901        	l32r	a0, ffe01acc <_bss_table_end+0x150>
ffe03628:	3008      	l32i.n	a0, a0, 12
ffe0362a:	0109      	s32i.n	a0, a1, 0
ffe0362c:	f93321        	l32r	a2, ffe01af8 <_bss_table_end+0x17c>
ffe0362f:	0020c0        	memw
ffe03632:	0008      	l32i.n	a0, a0, 0
ffe03634:	100020        	and	a0, a0, a2
ffe03637:	450b00        	extui	a0, a0, 27, 5
ffe0363a:	1d1026        	beqi	a0, 1, ffe0365b <HAL_SpiEnter4B..JB_1429880325+0x3b>
ffe0363d:	b7a022        	movi	a2, 183
ffe03640:	017b45        	call0	ffe04df8 <HAL_SpiSendCCmd..GB_1429880325>
    {
        HAL_SpiSendCCmd(SPI_CMD_EN4B,0,0);
        l_pSpiRegSet->bsAddrMode = SPI_ADDR_4B;
ffe03643:	f92e51        	l32r	a5, ffe01afc <_bss_table_end+0x180>
ffe03646:	f92a41        	l32r	a4, ffe01af0 <_bss_table_end+0x174>
ffe03649:	0020c0        	memw
ffe0364c:	0138      	l32i.n	a3, a1, 0
ffe0364e:	0328      	l32i.n	a2, a3, 0
ffe03650:	102250        	and	a2, a2, a5
ffe03653:	202240        	or	a2, a2, a4
ffe03656:	0020c0        	memw
ffe03659:	0329      	s32i.n	a2, a3, 0

ffe0365b <HAL_SpiEnter4B..JB_1429880325+0x3b>:
    }
}
ffe0365b:	1108      	l32i.n	a0, a1, 4
ffe0365d:	10c112        	addi	a1, a1, 16
ffe03660:	f00d      	ret.n

ffe03662 <HAL_SpiEnter4B..JB_1429880325+0x42>:
	...

ffe03664 <HAL_SpiEnterSPI..IB_1429880325>:
    2014/11/17 Victor Zhang  reconstruct

*******************************************************************************/

LOCAL void HAL_SpiEnterSPI(void)
{
ffe03664:	f0c112        	addi	a1, a1, -16
ffe03667:	0109      	s32i.n	a0, a1, 0
ffe03669:	f8c601        	l32r	a0, ffe01984 <_bss_table_end+0x8>
    if (QPI_MODE == l_ulCurrSpiMode)
ffe0366c:	172002        	l32i	a0, a0, 92
ffe0366f:	321066        	bnei	a0, 1, ffe036a5 <HAL_SpiEnterSPI..IB_1429880325+0x41>
ffe03672:	ffa022        	movi	a2, 255
ffe03675:	017805        	call0	ffe04df8 <HAL_SpiSendCCmd..GB_1429880325>
    {
        HAL_SpiSendCCmd(SPI_CMD_EXQIO,0,0);
        l_pSpiRegSet->bsCIOMode = SPI_CMDIO_1BIT;
ffe03678:	020c      	movi.n	a2, 0
ffe0367a:	f91451        	l32r	a5, ffe01acc <_bss_table_end+0x150>
ffe0367d:	f92081        	l32r	a8, ffe01b00 <_bss_table_end+0x184>
ffe03680:	3558      	l32i.n	a5, a5, 12
ffe03682:	0020c0        	memw
ffe03685:	2578      	l32i.n	a7, a5, 8
ffe03687:	107780        	and	a7, a7, a8
ffe0368a:	0020c0        	memw
ffe0368d:	2579      	s32i.n	a7, a5, 8
        l_pSpiRegSet->bsCSpiGen = SPI_DATAIO_1BIT;
ffe0368f:	f91d61        	l32r	a6, ffe01b04 <_bss_table_end+0x188>
ffe03692:	0020c0        	memw
ffe03695:	2548      	l32i.n	a4, a5, 8
ffe03697:	104460        	and	a4, a4, a6
ffe0369a:	0020c0        	memw
        l_ulCurrSpiMode = SPI_MODE;
ffe0369d:	f8b931        	l32r	a3, ffe01984 <_bss_table_end+0x8>
{
    if (QPI_MODE == l_ulCurrSpiMode)
    {
        HAL_SpiSendCCmd(SPI_CMD_EXQIO,0,0);
        l_pSpiRegSet->bsCIOMode = SPI_CMDIO_1BIT;
        l_pSpiRegSet->bsCSpiGen = SPI_DATAIO_1BIT;
ffe036a0:	2549      	s32i.n	a4, a5, 8
        l_ulCurrSpiMode = SPI_MODE;
ffe036a2:	176322        	s32i	a2, a3, 92

ffe036a5 <HAL_SpiEnterSPI..IB_1429880325+0x41>:
    }     
}
ffe036a5:	0108      	l32i.n	a0, a1, 0
ffe036a7:	10c112        	addi	a1, a1, 16
ffe036aa:	f00d      	ret.n

ffe036ac <HAL_SpiEnterQPI..HB_1429880325>:
    2014/11/17 Victor Zhang  reconstruct

*******************************************************************************/

LOCAL void HAL_SpiEnterQPI(void)
{
ffe036ac:	f0c112        	addi	a1, a1, -16
ffe036af:	0109      	s32i.n	a0, a1, 0
ffe036b1:	f8b401        	l32r	a0, ffe01984 <_bss_table_end+0x8>
    if (SPI_MODE == l_ulCurrSpiMode)
ffe036b4:	172002        	l32i	a0, a0, 92
ffe036b7:	c0fc      	bnez.n	a0, ffe036f7 <HAL_SpiEnterQPI..HB_1429880325+0x4b>
ffe036b9:	823c      	movi.n	a2, 56
ffe036bb:	0173c5        	call0	ffe04df8 <HAL_SpiSendCCmd..GB_1429880325>
    {
        HAL_SpiSendCCmd(SPI_CMD_EQIO,0,0);
        l_pSpiRegSet->bsCIOMode = SPI_CMDIO_4BIT;
ffe036be:	f91291        	l32r	a9, ffe01b08 <_bss_table_end+0x18c>
ffe036c1:	f90251        	l32r	a5, ffe01acc <_bss_table_end+0x150>
ffe036c4:	f90fa1        	l32r	a10, ffe01b00 <_bss_table_end+0x184>
ffe036c7:	3558      	l32i.n	a5, a5, 12
ffe036c9:	0020c0        	memw
ffe036cc:	2588      	l32i.n	a8, a5, 8
ffe036ce:	1088a0        	and	a8, a8, a10
ffe036d1:	208890        	or	a8, a8, a9
ffe036d4:	0020c0        	memw
ffe036d7:	2589      	s32i.n	a8, a5, 8
        l_pSpiRegSet->bsCSpiGen = SPI_DATAIO_4BIT;
ffe036d9:	f90c61        	l32r	a6, ffe01b0c <_bss_table_end+0x190>
ffe036dc:	f90a71        	l32r	a7, ffe01b04 <_bss_table_end+0x188>
ffe036df:	0020c0        	memw
ffe036e2:	2548      	l32i.n	a4, a5, 8
ffe036e4:	104470        	and	a4, a4, a7
ffe036e7:	204460        	or	a4, a4, a6
ffe036ea:	0020c0        	memw
ffe036ed:	2549      	s32i.n	a4, a5, 8
        l_ulCurrSpiMode = QPI_MODE;
ffe036ef:	f8a531        	l32r	a3, ffe01984 <_bss_table_end+0x8>
ffe036f2:	120c      	movi.n	a2, 1
ffe036f4:	176322        	s32i	a2, a3, 92

ffe036f7 <HAL_SpiEnterQPI..HB_1429880325+0x4b>:
    }    
}
ffe036f7:	0108      	l32i.n	a0, a1, 0
ffe036f9:	10c112        	addi	a1, a1, 16
ffe036fc:	f00d      	ret.n

ffe036fe <HAL_SpiEnterQPI..HB_1429880325+0x52>:
	...

ffe03700 <HAL_StrapGetReadPRCQ>:
*************************************************/

U8 HAL_StrapGetReadPRCQ(U8* pQeTable)
{
    U8 i;
    for (i=0;i<4;i++)
ffe03700:	050c      	movi.n	a5, 0
ffe03702:	ffa082        	movi	a8, 255
ffe03705:	f89f71        	l32r	a7, ffe01984 <_bss_table_end+0x8>
ffe03708:	430c      	movi.n	a3, 4
ffe0370a:	0c2772        	l32i	a7, a7, 48
ffe0370d:	1aa376        	loopgtz	a3, ffe0372b <HAL_StrapGetReadPRCQ+0x2b>
    {
        if (0xff == l_pEfuseFile->ucQE[i])
ffe03710:	675a      	add.n	a6, a7, a5
ffe03712:	0020c0        	memw
ffe03715:	040692        	l8ui	a9, a6, 4
        {
            break;
        }
        else
        {
            pQeTable[i] = l_pEfuseFile->ucQE[i];
ffe03718:	a25a      	add.n	a10, a2, a5
U8 HAL_StrapGetReadPRCQ(U8* pQeTable)
{
    U8 i;
    for (i=0;i<4;i++)
    {
        if (0xff == l_pEfuseFile->ucQE[i])
ffe0371a:	0d1987        	beq	a9, a8, ffe0372b <HAL_StrapGetReadPRCQ+0x2b>
        {
            break;
        }
        else
        {
            pQeTable[i] = l_pEfuseFile->ucQE[i];
ffe0371d:	0020c0        	memw
*************************************************/

U8 HAL_StrapGetReadPRCQ(U8* pQeTable)
{
    U8 i;
    for (i=0;i<4;i++)
ffe03720:	551b      	addi.n	a5, a5, 1
        {
            break;
        }
        else
        {
            pQeTable[i] = l_pEfuseFile->ucQE[i];
ffe03722:	040692        	l8ui	a9, a6, 4
ffe03725:	004a92        	s8i	a9, a10, 0
*************************************************/

U8 HAL_StrapGetReadPRCQ(U8* pQeTable)
{
    U8 i;
    for (i=0;i<4;i++)
ffe03728:	745050        	extui	a5, a5, 0, 8

ffe0372b <HAL_StrapGetReadPRCQ+0x2b>:
        else
        {
            pQeTable[i] = l_pEfuseFile->ucQE[i];
        }
    }
    return i;
ffe0372b:	052d      	mov.n	a2, a5
ffe0372d:	f00d      	ret.n

ffe0372f <HAL_StrapGetReadPRCQ+0x2f>:
	...

ffe03730 <HAL_CheckSignature..FB_1429880325>:
    return bRet;
}

LOCAL BOOL HAL_CheckSignature(U8 ulPu)
{
    if ((BOOT_LOADER_MAGIC_NUM_DW0 != *(U32*)BOOT_LOADER_BASE)
ffe03730:	f8f921        	l32r	a2, ffe01b14 <_bss_table_end+0x198>
    }  
    return bRet;
}

LOCAL BOOL HAL_CheckSignature(U8 ulPu)
{
ffe03733:	f0c112        	addi	a1, a1, -16
ffe03736:	21d9      	s32i.n	a13, a1, 8
ffe03738:	11c9      	s32i.n	a12, a1, 4
ffe0373a:	f8f5c1        	l32r	a12, ffe01b10 <_bss_table_end+0x194>
ffe0373d:	0109      	s32i.n	a0, a1, 0
    if ((BOOT_LOADER_MAGIC_NUM_DW0 != *(U32*)BOOT_LOADER_BASE)
ffe0373f:	802c02        	l32i	a0, a12, 0x200
    }  
    return bRet;
}

LOCAL BOOL HAL_CheckSignature(U8 ulPu)
{
ffe03742:	f8d9d1        	l32r	a13, ffe01aa8 <_bss_table_end+0x12c>
    if ((BOOT_LOADER_MAGIC_NUM_DW0 != *(U32*)BOOT_LOADER_BASE)
ffe03745:	0b9027        	bne	a0, a2, ffe03754 <HAL_CheckSignature..FB_1429880325+0x24>
ffe03748:	f8f441        	l32r	a4, ffe01b18 <_bss_table_end+0x19c>
ffe0374b:	812c32        	l32i	a3, a12, 0x204
        DBG_TRACE(TRACE_FAIL);
        DBG_TRACE(*((U32*)OTFB_START_ADDRESS));
        DBG_TRACE(*((U32*)(OTFB_START_ADDRESS + 4)));        
        return FAIL;
    } 
    DBG_TRACE(TRACE_SUCCESS);
ffe0374e:	f89ca1        	l32r	a10, ffe019c0 <_bss_table_end+0x44>
    return bRet;
}

LOCAL BOOL HAL_CheckSignature(U8 ulPu)
{
    if ((BOOT_LOADER_MAGIC_NUM_DW0 != *(U32*)BOOT_LOADER_BASE)
ffe03751:	3d1347        	beq	a3, a4, ffe03792 <HAL_CheckSignature..FB_1429880325+0x62>

ffe03754 <HAL_CheckSignature..FB_1429880325+0x24>:
      ||(BOOT_LOADER_MAGIC_NUM_DW1 != *(U32*)(BOOT_LOADER_BASE+4)))
    {
        DBG_Printf("FLASH BOOT:\n");
ffe03754:	f8f221        	l32r	a2, ffe01b1c <_bss_table_end+0x1a0>
ffe03757:	017685        	call0	ffe04ec0 <dbg_printf>
        DBG_Printf("SIG DWORD 0:0x%x ,EXP :0x%x\n",*(U32*)BOOT_LOADER_BASE,BOOT_LOADER_MAGIC_NUM_DW0);
ffe0375a:	f8f121        	l32r	a2, ffe01b20 <_bss_table_end+0x1a4>
ffe0375d:	802c32        	l32i	a3, a12, 0x200
ffe03760:	f8ed41        	l32r	a4, ffe01b14 <_bss_table_end+0x198>
ffe03763:	0175c5        	call0	ffe04ec0 <dbg_printf>
        DBG_Printf("SIG DWORD 1:0x%x ,EXP :0x%x\n",*(U32*)(BOOT_LOADER_BASE+4),BOOT_LOADER_MAGIC_NUM_DW1);
ffe03766:	f8ef21        	l32r	a2, ffe01b24 <_bss_table_end+0x1a8>
ffe03769:	812c32        	l32i	a3, a12, 0x204
ffe0376c:	f8eb41        	l32r	a4, ffe01b18 <_bss_table_end+0x19c>
ffe0376f:	017505        	call0	ffe04ec0 <dbg_printf>
        DBG_TRACE(TRACE_FAIL);
ffe03772:	f8ed71        	l32r	a7, ffe01b28 <_bss_table_end+0x1ac>
ffe03775:	0020c0        	memw
ffe03778:	a06d72        	s32i	a7, a13, 0x280
        DBG_TRACE(*((U32*)OTFB_START_ADDRESS));
ffe0377b:	802c62        	l32i	a6, a12, 0x200
ffe0377e:	0020c0        	memw
ffe03781:	a06d62        	s32i	a6, a13, 0x280
        DBG_TRACE(*((U32*)(OTFB_START_ADDRESS + 4)));        
ffe03784:	812c52        	l32i	a5, a12, 0x204
ffe03787:	0020c0        	memw
ffe0378a:	a06d52        	s32i	a5, a13, 0x280
        return FAIL;
ffe0378d:	020c      	movi.n	a2, 0
    if ((BOOT_LOADER_MAGIC_NUM_DW0 != *(U32*)BOOT_LOADER_BASE)
      ||(BOOT_LOADER_MAGIC_NUM_DW1 != *(U32*)(BOOT_LOADER_BASE+4)))
    {
        DBG_Printf("FLASH BOOT:\n");
        DBG_Printf("SIG DWORD 0:0x%x ,EXP :0x%x\n",*(U32*)BOOT_LOADER_BASE,BOOT_LOADER_MAGIC_NUM_DW0);
        DBG_Printf("SIG DWORD 1:0x%x ,EXP :0x%x\n",*(U32*)(BOOT_LOADER_BASE+4),BOOT_LOADER_MAGIC_NUM_DW1);
ffe0378f:	000646        	j	ffe037ac <HAL_CheckSignature..FB_1429880325+0x7c>

ffe03792 <HAL_CheckSignature..FB_1429880325+0x62>:
        DBG_TRACE(TRACE_FAIL);
        DBG_TRACE(*((U32*)OTFB_START_ADDRESS));
        DBG_TRACE(*((U32*)(OTFB_START_ADDRESS + 4)));        
        return FAIL;
    } 
    DBG_TRACE(TRACE_SUCCESS);
ffe03792:	0020c0        	memw
ffe03795:	a06da2        	s32i	a10, a13, 0x280
    DBG_TRACE(*((U32*)OTFB_START_ADDRESS));
ffe03798:	802c92        	l32i	a9, a12, 0x200
ffe0379b:	0020c0        	memw
ffe0379e:	a06d92        	s32i	a9, a13, 0x280
    DBG_TRACE(*((U32*)(OTFB_START_ADDRESS + 4))); 
ffe037a1:	812c82        	l32i	a8, a12, 0x204
ffe037a4:	0020c0        	memw
ffe037a7:	a06d82        	s32i	a8, a13, 0x280
    return SUCCESS;
ffe037aa:	120c      	movi.n	a2, 1
ffe037ac:	11c8      	l32i.n	a12, a1, 4
ffe037ae:	21d8      	l32i.n	a13, a1, 8
ffe037b0:	0108      	l32i.n	a0, a1, 0
ffe037b2:	10c112        	addi	a1, a1, 16
ffe037b5:	f00d      	ret.n

ffe037b7 <HAL_CheckSignature..FB_1429880325+0x87>:
	...

ffe037b8 <HAL_GetNormalDsgAddr>:
    if get one DSG by HAL_GetNormalDsg function, call this function to get its address.
History:
    201409011    Tobey   uniform coding style
------------------------------------------------------------------------------*/
U32 HAL_GetNormalDsgAddr(U16 usDsgId)
{
ffe037b8:	f0c112        	addi	a1, a1, -16
ffe037bb:	0109      	s32i.n	a0, a1, 0
    if(usDsgId >= NORMAL_DSG_NUM)
ffe037bd:	ffa102        	movi	a0, 0x1ff
ffe037c0:	07b027        	bgeu	a0, a2, ffe037cb <HAL_GetNormalDsgAddr+0x13>
    {
        DBG_Getch();
ffe037c3:	014245        	call0	ffe04be8 <DBG_Getch>
        return 0;
ffe037c6:	020c      	movi.n	a2, 0
------------------------------------------------------------------------------*/
U32 HAL_GetNormalDsgAddr(U16 usDsgId)
{
    if(usDsgId >= NORMAL_DSG_NUM)
    {
        DBG_Getch();
ffe037c8:	0001c6        	j	ffe037d3 <HAL_GetNormalDsgAddr+0x1b>

ffe037cb <HAL_GetNormalDsgAddr+0x13>:
        return 0;
    }
    else
    {
        return (U32)(usDsgId*sizeof(NORMAL_DSG_ENTRY) + NORMAL_DSG_BASE);
ffe037cb:	f8d831        	l32r	a3, ffe01b2c <_bss_table_end+0x1b0>
ffe037ce:	1122c0        	slli	a2, a2, 4
ffe037d1:	223a      	add.n	a2, a2, a3
ffe037d3:	0108      	l32i.n	a0, a1, 0
ffe037d5:	10c112        	addi	a1, a1, 16
ffe037d8:	f00d      	ret.n

ffe037da <HAL_GetNormalDsgAddr+0x22>:
	...

ffe037dc <HAL_GetNormalDsg>:
    when build Flash DSG chain for CQ entry, call this function to get normal DSG.
History:
    201409011    Tobey   uniform coding style
------------------------------------------------------------------------------*/
BOOL HAL_GetNormalDsg(U16 *pDsgId)
{
ffe037dc:	f86a71        	l32r	a7, ffe01984 <_bss_table_end+0x8>
    201409011    Tobey   uniform coding style
------------------------------------------------------------------------------*/
BOOL HAL_GetCurNormalDsg(U16 *pDsgId)
{
    BOOL bStsFlag;
    if (TRUE == l_pDsgReport->bsDsgValidEn)
ffe037df:	0020c0        	memw
ffe037e2:	b738      	l32i.n	a3, a7, 44
    {
        *pDsgId = l_pDsgReport->bsDsgId;
ffe037e4:	f86c61        	l32r	a6, ffe01994 <_bss_table_end+0x18>
    201409011    Tobey   uniform coding style
------------------------------------------------------------------------------*/
BOOL HAL_GetCurNormalDsg(U16 *pDsgId)
{
    BOOL bStsFlag;
    if (TRUE == l_pDsgReport->bsDsgValidEn)
ffe037e7:	0338      	l32i.n	a3, a3, 0
        bStsFlag = TRUE;
    }
    else
    {
        *pDsgId = INVALID_4F;
        bStsFlag = FALSE;
ffe037e9:	040c      	movi.n	a4, 0
    201409011    Tobey   uniform coding style
------------------------------------------------------------------------------*/
BOOL HAL_GetCurNormalDsg(U16 *pDsgId)
{
    BOOL bStsFlag;
    if (TRUE == l_pDsgReport->bsDsgValidEn)
ffe037eb:	1473f7        	bbci	a3, 31, ffe03803 <HAL_GetNormalDsg+0x27>
    {
        *pDsgId = l_pDsgReport->bsDsgId;
ffe037ee:	0020c0        	memw
ffe037f1:	b758      	l32i.n	a5, a7, 44
ffe037f3:	0558      	l32i.n	a5, a5, 0
ffe037f5:	140c      	movi.n	a4, 1
ffe037f7:	105560        	and	a5, a5, a6
ffe037fa:	a55550        	extui	a5, a5, 21, 11
ffe037fd:	005252        	s16i	a5, a2, 0
ffe03800:	000146        	j	ffe03809 <HAL_GetNormalDsg+0x2d>

ffe03803 <HAL_GetNormalDsg+0x27>:
        bStsFlag = TRUE;
    }
    else
    {
        *pDsgId = INVALID_4F;
ffe03803:	f86361        	l32r	a6, ffe01990 <_bss_table_end+0x14>
ffe03806:	005262        	s16i	a6, a2, 0
{
    BOOL bStsFlag;
    bStsFlag = HAL_GetCurNormalDsg(pDsgId);

    HAL_TriggerNormalDsg();
    return bStsFlag;
ffe03809:	042d      	mov.n	a2, a4
void HAL_TriggerNormalDsg(void)
{
#ifdef SIM
    DSG_AllocateNormalDsg(l_ulMcuID);
#else
    l_pDsgReport->bsDsgTrigger = TRUE;
ffe0380b:	0020c0        	memw
ffe0380e:	f85fb1        	l32r	a11, ffe0198c <_bss_table_end+0x10>
ffe03811:	f85da1        	l32r	a10, ffe01988 <_bss_table_end+0xc>
ffe03814:	b798      	l32i.n	a9, a7, 44
ffe03816:	0020c0        	memw
ffe03819:	b788      	l32i.n	a8, a7, 44
ffe0381b:	0888      	l32i.n	a8, a8, 0
ffe0381d:	1088b0        	and	a8, a8, a11
ffe03820:	2088a0        	or	a8, a8, a10
ffe03823:	0989      	s32i.n	a8, a9, 0
{
    BOOL bStsFlag;
    bStsFlag = HAL_GetCurNormalDsg(pDsgId);

    HAL_TriggerNormalDsg();
    return bStsFlag;
ffe03825:	f00d      	ret.n

ffe03827 <HAL_GetNormalDsg+0x4b>:
	...

ffe03828 <HAL_NfcReadBootloader>:
DES :   Read 8K data from the Page 0 in Block 0 of <Pu> into OTFB,
        by issuing the single plane read,      
*/

GLOBAL BOOL HAL_NfcReadBootloader(U8 ucLogPu)
{
ffe03828:	e0c112        	addi	a1, a1, -32
ffe0382b:	41d9      	s32i.n	a13, a1, 16
ffe0382d:	51e9      	s32i.n	a14, a1, 20
ffe0382f:	61f9      	s32i.n	a15, a1, 24
ffe03831:	31c9      	s32i.n	a12, a1, 12
ffe03833:	2109      	s32i.n	a0, a1, 8
ffe03835:	02cd      	mov.n	a12, a2
    volatile NFCQ_ENTRY*       pNfcqEntry;
    volatile NORMAL_DSG_ENTRY* pDsgAddr;
    U8 ucPhyPu = HAL_NfcGetPhyPu(ucLogPu);
ffe03837:	00ac85        	call0	ffe04300 <HAL_NfcGetPhyPu>
ffe0383a:	02dd      	mov.n	a13, a2
    U8 ucCeSel = HAL_NfcGetCeSel(ucLogPu); 
ffe0383c:	0c2d      	mov.n	a2, a12
ffe0383e:	00aac5        	call0	ffe042ec <HAL_NfcGetCeSel>
    U16 usCurDsgId;    
    U32 ulDataLen = HAL_StrapGetPageSize();
ffe03841:	110de0        	slli	a0, a13, 2
ffe03844:	130c      	movi.n	a3, 1
GLOBAL BOOL HAL_NfcReadBootloader(U8 ucLogPu)
{
    volatile NFCQ_ENTRY*       pNfcqEntry;
    volatile NORMAL_DSG_ENTRY* pDsgAddr;
    U8 ucPhyPu = HAL_NfcGetPhyPu(ucLogPu);
    U8 ucCeSel = HAL_NfcGetCeSel(ucLogPu); 
ffe03846:	1129      	s32i.n	a2, a1, 4
    U16 usCurDsgId;    
    U32 ulDataLen = HAL_StrapGetPageSize();
ffe03848:	f84f61        	l32r	a6, ffe01984 <_bss_table_end+0x8>
ffe0384b:	f8b971        	l32r	a7, ffe01b30 <_bss_table_end+0x1b4>
ffe0384e:	4668      	l32i.n	a6, a6, 16
ffe03850:	0728      	l32i.n	a2, a7, 0
ffe03852:	a06d60        	addx4	a6, a13, a6
ffe03855:	142020        	extui	a2, a2, 0, 2
ffe03858:	22cb      	addi.n	a2, a2, 12
ffe0385a:	401200        	ssl	a2
ffe0385d:	a1f300        	sll	a15, a3

ffe03860 <HAL_NfcReadBootloader+0x38>:
    while (FALSE == HalNfcGetPuEmpty(ucPhyPu))
ffe03860:	0020c0        	memw
ffe03863:	000682        	l8ui	a8, a6, 0
ffe03866:	f66827        	bbci	a8, 2, ffe03860 <HAL_NfcReadBootloader+0x38>
    return the available NFCQ entry of target PU
*************************************************/

LOCAL NFCQ_ENTRY* HalNfcGetNfcqEntry(U8 Pu)
{
    U8 Wp = HalNfcGetWp(Pu);
ffe03869:	0020c0        	memw
*************************************************/

LOCAL void HalNfcClearNfcq(NFCQ_ENTRY* pNfcq)
{
    U32 i;
    for (i=0;i<NFCQ_ENTRY_SIZE_DW;i++)
ffe0386c:	0c0c      	movi.n	a12, 0
    {
        ;
    }

    pNfcqEntry = (NFCQ_ENTRY*)HalNfcGetNfcqEntry(ucPhyPu);
    HalNfcClearNfcq((NFCQ_ENTRY* )pNfcqEntry);
ffe0386e:	f84a41        	l32r	a4, ffe01998 <_bss_table_end+0x1c>

    //pNfcqEntry->bsPuEnpMsk = TRUE;

#ifdef VT3514_C0
    pNfcqEntry->bsOtfbBypass = TRUE;
ffe03871:	f86a81        	l32r	a8, ffe01a1c <_bss_table_end+0xa0>
    {
        ;
    }

    pNfcqEntry = (NFCQ_ENTRY*)HalNfcGetNfcqEntry(ucPhyPu);
    HalNfcClearNfcq((NFCQ_ENTRY* )pNfcqEntry);
ffe03874:	e77c      	movi.n	a7, -2
ffe03876:	091c      	movi.n	a9, 16
    return the available NFCQ entry of target PU
*************************************************/

LOCAL NFCQ_ENTRY* HalNfcGetNfcqEntry(U8 Pu)
{
    U8 Wp = HalNfcGetWp(Pu);
ffe03878:	000622        	l8ui	a2, a6, 0
    while (FALSE == HalNfcGetPuEmpty(ucPhyPu))
    {
        ;
    }

    pNfcqEntry = (NFCQ_ENTRY*)HalNfcGetNfcqEntry(ucPhyPu);
ffe0387b:	f842e1        	l32r	a14, ffe01984 <_bss_table_end+0x8>
    return the available NFCQ entry of target PU
*************************************************/

LOCAL NFCQ_ENTRY* HalNfcGetNfcqEntry(U8 Pu)
{
    U8 Wp = HalNfcGetWp(Pu);
ffe0387e:	412620        	srli	a2, a2, 6
    while (FALSE == HalNfcGetPuEmpty(ucPhyPu))
    {
        ;
    }

    pNfcqEntry = (NFCQ_ENTRY*)HalNfcGetNfcqEntry(ucPhyPu);
ffe03881:	6ee8      	l32i.n	a14, a14, 24
ffe03883:	020a      	add.n	a0, a2, a0
    HalNfcClearNfcq((NFCQ_ENTRY* )pNfcqEntry);
ffe03885:	f84521        	l32r	a2, ffe0199c <_bss_table_end+0x20>
    while (FALSE == HalNfcGetPuEmpty(ucPhyPu))
    {
        ;
    }

    pNfcqEntry = (NFCQ_ENTRY*)HalNfcGetNfcqEntry(ucPhyPu);
ffe03888:	1100a0        	slli	a0, a0, 6
ffe0388b:	ee0a      	add.n	a14, a14, a0
*************************************************/

LOCAL void HalNfcClearNfcq(NFCQ_ENTRY* pNfcq)
{
    U32 i;
    for (i=0;i<NFCQ_ENTRY_SIZE_DW;i++)
ffe0388d:	0e0d      	mov.n	a0, a14
ffe0388f:	03a976        	loopgtz	a9, ffe03896 <HAL_NfcReadBootloader+0x6e>
    {
        *(((U32*)pNfcq) + i)  = 0;
ffe03892:	00c9      	s32i.n	a12, a0, 0
*************************************************/

LOCAL void HalNfcClearNfcq(NFCQ_ENTRY* pNfcq)
{
    U32 i;
    for (i=0;i<NFCQ_ENTRY_SIZE_DW;i++)
ffe03894:	004b      	addi.n	a0, a0, 4

ffe03896 <HAL_NfcReadBootloader+0x6e>:
    HalNfcClearNfcq((NFCQ_ENTRY* )pNfcqEntry);

    //pNfcqEntry->bsPuEnpMsk = TRUE;

#ifdef VT3514_C0
    pNfcqEntry->bsOtfbBypass = TRUE;
ffe03896:	0020c0        	memw
ffe03899:	3e98      	l32i.n	a9, a14, 12
ffe0389b:	e20984        	insbits	a8, a9, 0, 30
ffe0389e:	0020c0        	memw
ffe038a1:	3e89      	s32i.n	a8, a14, 12
#else
    pNfcqEntry->bsTrigOmEn = TRUE;
#endif
    pNfcqEntry->bsOntfEn = TRUE;
ffe038a3:	0020c0        	memw
ffe038a6:	0e68      	l32i.n	a6, a14, 0
ffe038a8:	106670        	and	a6, a6, a7
ffe038ab:	206630        	or	a6, a6, a3
ffe038ae:	0020c0        	memw
ffe038b1:	0e69      	s32i.n	a6, a14, 0

    pNfcqEntry->aSecAddr[0].bsSecStart = 0;
ffe038b3:	0020c0        	memw
ffe038b6:	054ec2        	s8i	a12, a14, 5
    pNfcqEntry->aSecAddr[0].bsSecLength = ulDataLen >> SEC_SZ_BITS;
ffe038b9:	4159f0        	srli	a5, a15, 9
ffe038bc:	0020c0        	memw
ffe038bf:	044e52        	s8i	a5, a14, 4
    pNfcqEntry->bsDmaTotalLength = ulDataLen >> SEC_SZ_BITS;
ffe038c2:	0020c0        	memw
ffe038c5:	0c4e52        	s8i	a5, a14, 12
    pNfcqEntry->bsDsgEn = TRUE;
ffe038c8:	0020c0        	memw
ffe038cb:	0e08      	l32i.n	a0, a14, 0
ffe038cd:	100040        	and	a0, a0, a4
ffe038d0:	200020        	or	a0, a0, a2
ffe038d3:	0020c0        	memw
ffe038d6:	0e09      	s32i.n	a0, a14, 0

ffe038d8 <HAL_NfcReadBootloader+0xb0>:
ffe038d8:	012d      	mov.n	a2, a1
    while (FALSE == HAL_GetNormalDsg(&usCurDsgId))
ffe038da:	fff005        	call0	ffe037dc <HAL_GetNormalDsg>
ffe038dd:	ff7216        	beqz	a2, ffe038d8 <HAL_NfcReadBootloader+0xb0>
    {
        ;
    }
    
    pDsgAddr = (NORMAL_DSG_ENTRY *)HAL_GetNormalDsgAddr(usCurDsgId);
ffe038e0:	001122        	l16ui	a2, a1, 0
ffe038e3:	ffed45        	call0	ffe037b8 <HAL_GetNormalDsgAddr>
ffe038e6:	f82d31        	l32r	a3, ffe0199c <_bss_table_end+0x20>
ffe038e9:	f82b61        	l32r	a6, ffe01998 <_bss_table_end+0x1c>
ffe038ec:	170c      	movi.n	a7, 1
ffe038ee:	e87c      	movi.n	a8, -2
    COM_MemZero((U32*)pDsgAddr,sizeof(NORMAL_DSG_ENTRY));
ffe038f0:	020d      	mov.n	a0, a2
ffe038f2:	10a0a2        	movi	a10, 16
ffe038f5:	03aa76        	loopgtz	a10, ffe038fc <HAL_NfcReadBootloader+0xd4>
{
    U32 i;

    for (i = 0 ; i < LengthDW; i++)
    {
        *TargetAddr++ = 0;
ffe038f8:	00c9      	s32i.n	a12, a0, 0
ffe038fa:	004b      	addi.n	a0, a0, 4

ffe038fc <HAL_NfcReadBootloader+0xd4>:
    pDsgAddr->ulDramAddr = 0x0;
ffe038fc:	0020c0        	memw
ffe038ff:	12c9      	s32i.n	a12, a2, 4
    pDsgAddr->bsXferByteLen = ulDataLen;
ffe03901:	0020c0        	memw
ffe03904:	02a8      	l32i.n	a10, a2, 0
ffe03906:	e3efa4        	insbits	a10, a15, 14, 31
ffe03909:	0020c0        	memw
ffe0390c:	02a9      	s32i.n	a10, a2, 0
    pDsgAddr->bsLast = TRUE;
ffe0390e:	ffad92        	movi	a9, 0xfffffdff
ffe03911:	00a252        	movi	a5, 0x200
ffe03914:	0020c0        	memw
ffe03917:	0248      	l32i.n	a4, a2, 0
ffe03919:	104490        	and	a4, a4, a9
ffe0391c:	204450        	or	a4, a4, a5
ffe0391f:	0020c0        	memw
ffe03922:	0249      	s32i.n	a4, a2, 0
    20141028    Gavin   add "INLINE" attribute
------------------------------------------------------------------------------*/
INLINE void HAL_MemoryWait(void)
{
#ifndef SIM
    XT_MEMW();
ffe03924:	0020c0        	memw
    HAL_MemoryWait();
    pNfcqEntry->bsFstDsgPtr = usCurDsgId;
ffe03927:	001192        	l16ui	a9, a1, 0
ffe0392a:	0020c0        	memw
ffe0392d:	0e08      	l32i.n	a0, a14, 0
ffe0392f:	f37904        	insbits	a0, a9, 23, 31
ffe03932:	0020c0        	memw
ffe03935:	0e09      	s32i.n	a0, a14, 0
    else
    {
        DBG_Getch();
    }
#else
    l_pDsgReport->bsDsgValue = ucStsValue;
ffe03937:	0020c0        	memw
ffe0393a:	f81221        	l32r	a2, ffe01984 <_bss_table_end+0x8>
ffe0393d:	b2a8      	l32i.n	a10, a2, 44
ffe0393f:	0020c0        	memw
ffe03942:	b2b8      	l32i.n	a11, a2, 44
ffe03944:	0bb8      	l32i.n	a11, a11, 0
ffe03946:	108b80        	and	a8, a11, a8
ffe03949:	208870        	or	a8, a8, a7
ffe0394c:	0a89      	s32i.n	a8, a10, 0
    l_pDsgReport->bsDsgWrIndex = usDsgId;
ffe0394e:	0020c0        	memw
ffe03951:	b288      	l32i.n	a8, a2, 44
ffe03953:	0020c0        	memw
ffe03956:	b278      	l32i.n	a7, a2, 44
ffe03958:	0778      	l32i.n	a7, a7, 0
ffe0395a:	421974        	insbits	a7, a9, 1, 10
ffe0395d:	0879      	s32i.n	a7, a8, 0
    l_pDsgReport->bsDsgWrEn = TRUE;
ffe0395f:	0020c0        	memw
ffe03962:	b248      	l32i.n	a4, a2, 44
ffe03964:	0020c0        	memw
ffe03967:	b258      	l32i.n	a5, a2, 44
ffe03969:	0558      	l32i.n	a5, a5, 0
ffe0396b:	105560        	and	a5, a5, a6
ffe0396e:	203530        	or	a3, a5, a3
ffe03971:	0439      	s32i.n	a3, a4, 0
ffe03973:	0020c0        	memw
    HAL_MemoryWait();
    HAL_SetNormalDsgSts(usCurDsgId,TRUE);
    HAL_MemoryWait();

    HalSetPrcq(gPageReadCmdIndex,ucPhyPu);
ffe03976:	140222        	l8ui	a2, a2, 20
ffe03979:	0d3d      	mov.n	a3, a13
ffe0397b:	008d45        	call0	ffe04250 <HalSetPrcq..CB_1429880325>
    HalSetTrigger(gPageReadCmdIndex,ucPhyPu,ucCeSel);
ffe0397e:	0d3d      	mov.n	a3, a13
ffe03980:	f80121        	l32r	a2, ffe01984 <_bss_table_end+0x8>
ffe03983:	1148      	l32i.n	a4, a1, 4
ffe03985:	140222        	l8ui	a2, a2, 20
ffe03988:	008605        	call0	ffe041ec <HalSetTrigger..EB_1429880325>
ffe0398b:	0020c0        	memw
    HAL_MemoryWait();

    if (FAIL == HalNfcSinglePuStatus(ucPhyPu))
ffe0398e:	0d2d      	mov.n	a2, a13
ffe03990:	007f85        	call0	ffe0418c <HalNfcSinglePuStatus..O_1429880325>
ffe03993:	f84501        	l32r	a0, ffe01aa8 <_bss_table_end+0x12c>
ffe03996:	c2cc      	bnez.n	a2, ffe039a6 <HAL_NfcReadBootloader+0x17e>
    {   
        DBG_TRACE(TRACE_FAIL);
ffe03998:	f86431        	l32r	a3, ffe01b28 <_bss_table_end+0x1ac>
ffe0399b:	0020c0        	memw
ffe0399e:	a06032        	s32i	a3, a0, 0x280
        return FAIL;
ffe039a1:	020c      	movi.n	a2, 0

    HalSetPrcq(gPageReadCmdIndex,ucPhyPu);
    HalSetTrigger(gPageReadCmdIndex,ucPhyPu,ucCeSel);
    HAL_MemoryWait();

    if (FAIL == HalNfcSinglePuStatus(ucPhyPu))
ffe039a3:	000346        	j	ffe039b4 <HAL_NfcReadBootloader+0x18c>

ffe039a6 <HAL_NfcReadBootloader+0x17e>:
        return FAIL;
    }
    else
    {
        DBG_TRACE(TRACE_SUCCESS);
        return HAL_CheckSignature(ucPhyPu);
ffe039a6:	0d2d      	mov.n	a2, a13
        DBG_TRACE(TRACE_FAIL);
        return FAIL;
    }
    else
    {
        DBG_TRACE(TRACE_SUCCESS);
ffe039a8:	f80641        	l32r	a4, ffe019c0 <_bss_table_end+0x44>
ffe039ab:	0020c0        	memw
ffe039ae:	a06042        	s32i	a4, a0, 0x280
        return HAL_CheckSignature(ucPhyPu);
ffe039b1:	ffd7c5        	call0	ffe03730 <HAL_CheckSignature..FB_1429880325>
ffe039b4:	31c8      	l32i.n	a12, a1, 12
ffe039b6:	41d8      	l32i.n	a13, a1, 16
ffe039b8:	51e8      	l32i.n	a14, a1, 20
ffe039ba:	61f8      	l32i.n	a15, a1, 24
ffe039bc:	2108      	l32i.n	a0, a1, 8
ffe039be:	20c112        	addi	a1, a1, 32
ffe039c1:	f00d      	ret.n

ffe039c3 <HAL_NfcReadBootloader+0x19b>:
	...

ffe039c4 <HAL_InitInterrupt>:
    20141028    Gavin   change attribute to "INLINE"
------------------------------------------------------------------------------*/
INLINE U32 HAL_GetMcuId(void)
{
    U32 ulMcuId;
    ulMcuId = XT_RSR_PRID();
ffe039c4:	03eb50        	rsr.prid	a5
    20141028    Gavin   add "INLINE" attribute
------------------------------------------------------------------------------*/
INLINE void HAL_DisableMCUIntAck(void)
{
#ifndef SIM
    XT_RSIL(15);
ffe039c7:	006f40        	rsil	a4, 15
ffe039ca:	f77c      	movi.n	a7, -1
ffe039cc:	f85a61        	l32r	a6, ffe01b34 <_bss_table_end+0x1b8>
Modify History:
    20140905    Victor Zhang Create
------------------------------------------------------------------------------*/
void HAL_ClearHwIntMask(U32 ulCPUID, U32 ulIntSrc)
{
    if ( MCU0_ID == ulCPUID )
ffe039cf:	141566        	bnei	a5, 1, ffe039e7 <HAL_InitInterrupt+0x23>
    {
        rGLB_58 &= (U16)(~ulIntSrc);
ffe039d2:	308270        	xor	a8, a2, a7
ffe039d5:	0020c0        	memw
ffe039d8:	ac1652        	l16ui	a5, a6, 0x158
ffe039db:	105580        	and	a5, a5, a8
ffe039de:	0020c0        	memw
ffe039e1:	ac5652        	s16i	a5, a6, 0x158
ffe039e4:	000b06        	j	ffe03a14 <HAL_InitInterrupt+0x50>

ffe039e7 <HAL_InitInterrupt+0x23>:
    }
    else if ( MCU1_ID == ulCPUID )
ffe039e7:	142566        	bnei	a5, 2, ffe039ff <HAL_InitInterrupt+0x3b>
    {
        rGLB_5A &= (U16)(~ulIntSrc);
ffe039ea:	30a270        	xor	a10, a2, a7
ffe039ed:	0020c0        	memw
ffe039f0:	ad1692        	l16ui	a9, a6, 0x15a
ffe039f3:	1099a0        	and	a9, a9, a10
ffe039f6:	0020c0        	memw
ffe039f9:	ad5692        	s16i	a9, a6, 0x15a
ffe039fc:	000506        	j	ffe03a14 <HAL_InitInterrupt+0x50>

ffe039ff <HAL_InitInterrupt+0x3b>:
    }
    else if (MCU2_ID == ulCPUID)
ffe039ff:	113566        	bnei	a5, 3, ffe03a14 <HAL_InitInterrupt+0x50>
    {
        rGLB_5C &= (U16)(~ulIntSrc);
ffe03a02:	304270        	xor	a4, a2, a7
ffe03a05:	0020c0        	memw
ffe03a08:	ae16b2        	l16ui	a11, a6, 0x15c
ffe03a0b:	10bb40        	and	a11, a11, a4
ffe03a0e:	0020c0        	memw
ffe03a11:	ae56b2        	s16i	a11, a6, 0x15c
    20141028    Gavin   add "INLINE" attribute
------------------------------------------------------------------------------*/
INLINE void HAL_EnableMCUIntSrc(U32 ulEnableMap)
{
#ifndef SIM
    U32 ulNewIntEn = (XT_RSR_INTENABLE() | ulEnableMap);
ffe03a14:	03e460        	rsr.intenable	a6

    XT_WSR_INTENABLE(ulNewIntEn);
ffe03a17:	206630        	or	a6, a6, a3
ffe03a1a:	13e460        	wsr.intenable	a6
    20141028    Gavin   add "INLINE" attribute
------------------------------------------------------------------------------*/
INLINE void HAL_EnableMCUIntAck(void)
{
#ifndef SIM
    XT_RSIL(0);
ffe03a1d:	006050        	rsil	a5, 0
    HAL_DisableMCUIntAck();
    HAL_ClearHwIntMask(ulMCUID, ulHwIntMask);
    HAL_EnableMCUIntSrc(ulMcuIntSrc);
    HAL_EnableMCUIntAck();

    return;
ffe03a20:	f00d      	ret.n

ffe03a22 <HAL_InitInterrupt+0x5e>:
	...

ffe03a24 <HAL_UartDBG>:
History:
    2015/4/16   Victor Zhang  First create

*************************************************************************/
void HAL_UartDBG(void)
{   
ffe03a24:	f0c112        	addi	a1, a1, -16
ffe03a27:	0109      	s32i.n	a0, a1, 0
ffe03a29:	21d9      	s32i.n	a13, a1, 8
ffe03a2b:	11c9      	s32i.n	a12, a1, 4
ffe03a2d:	f7d5c1        	l32r	a12, ffe01984 <_bss_table_end+0x8>
ffe03a30:	f827d1        	l32r	a13, ffe01acc <_bss_table_end+0x150>

ffe03a33 <HAL_UartDBG+0xf>:
    while(1)
    {
        l_aUartFunc[l_tMgr.ulCurrState]();
ffe03a33:	212c02        	l32i	a0, a12, 132
ffe03a36:	a000d0        	addx4	a0, a0, a13
ffe03a39:	a42002        	l32i	a0, a0, 0x290
ffe03a3c:	0000c0        	callx0	a0
        if(UART_MP_DISALBED())
ffe03a3f:	202c22        	l32i	a2, a12, 128
ffe03a42:	fed256        	bnez	a2, ffe03a33 <HAL_UartDBG+0xf>
        {
            return;
ffe03a45:	11c8      	l32i.n	a12, a1, 4
ffe03a47:	21d8      	l32i.n	a13, a1, 8
ffe03a49:	0108      	l32i.n	a0, a1, 0
ffe03a4b:	10c112        	addi	a1, a1, 16
ffe03a4e:	f00d      	ret.n

ffe03a50 <HAL_MpPcieMain>:
    HAL_MpGlbSetting();
    HAL_MpForceGen1();
}

void HAL_MpPcieMain(void)
{
ffe03a50:	e0c112        	addi	a1, a1, -32
ffe03a53:	000c      	movi.n	a0, 0
ffe03a55:	f808d1        	l32r	a13, ffe01a78 <_bss_table_end+0xfc>
ffe03a58:	f7cbe1        	l32r	a14, ffe01984 <_bss_table_end+0x8>
    U32 ulCurrRegValue,ulPreRegValue;
    DBG_TRACE(TRACE_PCIE_MP);
ffe03a5b:	f83791        	l32r	a9, ffe01b38 <_bss_table_end+0x1bc>
    HAL_MpGlbSetting();
    HAL_MpForceGen1();
}

void HAL_MpPcieMain(void)
{
ffe03a5e:	f812c1        	l32r	a12, ffe01aa8 <_bss_table_end+0x12c>
    U32 ulCurrRegValue,ulPreRegValue;
    DBG_TRACE(TRACE_PCIE_MP);
ffe03a61:	0020c0        	memw
ffe03a64:	a06c92        	s32i	a9, a12, 0x280
    rGLB(0x18) &= ~0x20000000; // enable pcie [29]    
}

void HAL_MpModeSel(void)
{
    if (FALSE == HAL_StrapNfcIsNVMe())
ffe03a67:	0020c0        	memw
ffe03a6a:	f83471        	l32r	a7, ffe01b3c <_bss_table_end+0x1c0>
ffe03a6d:	ee88      	l32i.n	a8, a14, 56
ffe03a6f:	f83461        	l32r	a6, ffe01b40 <_bss_table_end+0x1c4>
ffe03a72:	048780        	extui	a8, a8, 7, 1
ffe03a75:	836780        	moveqz	a6, a7, a8
ffe03a78:	2e69      	s32i.n	a6, a14, 8
#endif
}

void HAL_MpInitInt(void)
{
    rHostIntSrcReg = BIT_MP_INT;   // clear int
ffe03a7a:	00a152        	movi	a5, 0x100
ffe03a7d:	0020c0        	memw
ffe03a80:	4d59      	s32i.n	a5, a13, 16
    rHostIntSrcReg = BIT_HR_INT;
ffe03a82:	f83041        	l32r	a4, ffe01b44 <_bss_table_end+0x1c8>
ffe03a85:	0020c0        	memw
ffe03a88:	4d49      	s32i.n	a4, a13, 16
    l_pHostIntMskReg->bsIntMGhcHrSet = FALSE;   
ffe03a8a:	f81031        	l32r	a3, ffe01acc <_bss_table_end+0x150>
ffe03a8d:	f7cb61        	l32r	a6, ffe019bc <_bss_table_end+0x40>
ffe03a90:	0338      	l32i.n	a3, a3, 0
ffe03a92:	0020c0        	memw
ffe03a95:	0358      	l32i.n	a5, a3, 0
ffe03a97:	105560        	and	a5, a5, a6
ffe03a9a:	0020c0        	memw
ffe03a9d:	0359      	s32i.n	a5, a3, 0
    l_pHostIntMskReg->bsIntMMptTrig  = FALSE;
ffe03a9f:	ffae42        	movi	a4, 0xfffffeff
ffe03aa2:	0020c0        	memw
ffe03aa5:	0328      	l32i.n	a2, a3, 0
ffe03aa7:	102240        	and	a2, a2, a4
ffe03aaa:	0020c0        	memw
ffe03aad:	0329      	s32i.n	a2, a3, 0
    l_ulRevMpInt = FALSE;
ffe03aaf:	0020c0        	memw
    HAL_InitInterrupt(TOP_INTSRC_HOSTC,BIT_ORINT_HOSTC);    
ffe03ab2:	00a222        	movi	a2, 0x200
ffe03ab5:	f82431        	l32r	a3, ffe01b48 <_bss_table_end+0x1cc>
{
    rHostIntSrcReg = BIT_MP_INT;   // clear int
    rHostIntSrcReg = BIT_HR_INT;
    l_pHostIntMskReg->bsIntMGhcHrSet = FALSE;   
    l_pHostIntMskReg->bsIntMMptTrig  = FALSE;
    l_ulRevMpInt = FALSE;
ffe03ab8:	3e09      	s32i.n	a0, a14, 12
    HAL_InitInterrupt(TOP_INTSRC_HOSTC,BIT_ORINT_HOSTC);    
ffe03aba:	fff085        	call0	ffe039c4 <HAL_InitInterrupt>
}

void HAL_MpGlbSetting(void)
{
    rGLB(0x3a38) = 0;          // disable opt rom
ffe03abd:	0020c0        	memw
ffe03ac0:	0f0c      	movi.n	a15, 0
ffe03ac2:	edf9      	s32i.n	a15, a13, 56
    rGLB(0x18) |= 0x20000000;  //disable pcie 
ffe03ac4:	f7bcb1        	l32r	a11, ffe019b4 <_bss_table_end+0x38>
ffe03ac7:	0020c0        	memw
ffe03aca:	862ca2        	l32i	a10, a12, 0x218
ffe03acd:	20aab0        	or	a10, a10, a11
ffe03ad0:	0020c0        	memw
ffe03ad3:	866ca2        	s32i	a10, a12, 0x218
    HAL_DelayCycle(2);         //wait for reset completed
ffe03ad6:	220c      	movi.n	a2, 2
ffe03ad8:	013105        	call0	ffe04dec <HAL_DelayCycle>
    rGLB(0x18) &= ~0x20000000; // enable pcie [29]    
ffe03adb:	f7bb41        	l32r	a4, ffe019c8 <_bss_table_end+0x4c>
ffe03ade:	f81b21        	l32r	a2, ffe01b4c <_bss_table_end+0x1d0>
ffe03ae1:	077c      	movi.n	a7, -16
ffe03ae3:	150c      	movi.n	a5, 1
ffe03ae5:	0020c0        	memw
ffe03ae8:	862c32        	l32i	a3, a12, 0x218
ffe03aeb:	103340        	and	a3, a3, a4
ffe03aee:	0020c0        	memw
ffe03af1:	866c32        	s32i	a3, a12, 0x218
void HAL_MpForceGen1(void)
{
#ifndef FPGA
    // Cfg to Gen1
    // Enable RW
    *(volatile U32 *)(0x1ff837A4) |= (0x1<<28);
ffe03af4:	f81701        	l32r	a0, ffe01b50 <_bss_table_end+0x1d4>
ffe03af7:	0020c0        	memw
ffe03afa:	6922f2        	l32i	a15, a2, 0x1a4
ffe03afd:	20ff00        	or	a15, a15, a0
ffe03b00:	0020c0        	memw
ffe03b03:	6962f2        	s32i	a15, a2, 0x1a4
    // Set LKMAXLS
    *(volatile U32 *)(0x1ff836D0) &= ~(0xF);
ffe03b06:	0020c0        	memw
ffe03b09:	3422d2        	l32i	a13, a2, 208
ffe03b0c:	10dd70        	and	a13, a13, a7
ffe03b0f:	0020c0        	memw
ffe03b12:	3462d2        	s32i	a13, a2, 208
    *(volatile U32 *)(0x1ff836D0) |= (0x1);
ffe03b15:	0020c0        	memw
ffe03b18:	3422b2        	l32i	a11, a2, 208
ffe03b1b:	20bb50        	or	a11, a11, a5
ffe03b1e:	0020c0        	memw
ffe03b21:	3462b2        	s32i	a11, a2, 208
    // Set LKMLS
    *(volatile U32 *)(0x1ff836F0) &= ~(0xF);
ffe03b24:	0020c0        	memw
ffe03b27:	3c22a2        	l32i	a10, a2, 240
ffe03b2a:	10aa70        	and	a10, a10, a7
ffe03b2d:	0020c0        	memw
ffe03b30:	3c62a2        	s32i	a10, a2, 240
    *(volatile U32 *)(0x1ff836F0) |= (0x2);
ffe03b33:	290c      	movi.n	a9, 2
ffe03b35:	0020c0        	memw
ffe03b38:	3c2282        	l32i	a8, a2, 240
ffe03b3b:	208890        	or	a8, a8, a9
ffe03b3e:	0020c0        	memw
ffe03b41:	3c6282        	s32i	a8, a2, 240
    // Set LKTGLS
    *(volatile U32 *)(0x1ff836F4) &= ~(0xF);
ffe03b44:	0020c0        	memw
ffe03b47:	3d2262        	l32i	a6, a2, 244
ffe03b4a:	106670        	and	a6, a6, a7
ffe03b4d:	0020c0        	memw
ffe03b50:	3d6262        	s32i	a6, a2, 244
    *(volatile U32 *)(0x1ff836F4) |= (0x1);
ffe03b53:	0020c0        	memw
ffe03b56:	3d2242        	l32i	a4, a2, 244
ffe03b59:	204450        	or	a4, a4, a5
ffe03b5c:	0020c0        	memw
ffe03b5f:	3d6242        	s32i	a4, a2, 244
    // Disable RW
    *(volatile U32 *)(0x1ff837A4) &= ~(0x1<<28);
ffe03b62:	f79b31        	l32r	a3, ffe019d0 <_bss_table_end+0x54>
ffe03b65:	0020c0        	memw
ffe03b68:	692202        	l32i	a0, a2, 0x1a4
ffe03b6b:	100030        	and	a0, a0, a3
ffe03b6e:	0020c0        	memw
ffe03b71:	696202        	s32i	a0, a2, 0x1a4
void HAL_MpPcieMain(void)
{
    U32 ulCurrRegValue,ulPreRegValue;
    DBG_TRACE(TRACE_PCIE_MP);
    HAL_MpInit();
    DBG_Printf("PCIE MP ENABLED.\n");
ffe03b74:	f7f821        	l32r	a2, ffe01b54 <_bss_table_end+0x1d8>
ffe03b77:	013485        	call0	ffe04ec0 <dbg_printf>

    ulPreRegValue = rP0_CMD;
ffe03b7a:	f7f7c1        	l32r	a12, ffe01b58 <_bss_table_end+0x1dc>
ffe03b7d:	0020c0        	memw
ffe03b80:	862cd2        	l32i	a13, a12, 0x218
ffe03b83:	f7a6f1        	l32r	a15, ffe01a1c <_bss_table_end+0xa0>

ffe03b86 <HAL_MpPcieMain+0x136>:
    while(1)
    {
        ulCurrRegValue = rP0_CMD;
ffe03b86:	0020c0        	memw
ffe03b89:	862c02        	l32i	a0, a12, 0x218
        if ( TEST_BIT( ( ulCurrRegValue ^ ulPreRegValue ), FRE_BIT ) )
ffe03b8c:	307d00        	xor	a7, a13, a0
ffe03b8f:	196747        	bbci	a7, 4, ffe03bac <HAL_MpPcieMain+0x15c>
        {
            if ( TEST_BIT( ulCurrRegValue, FRE_BIT) )
ffe03b92:	086047        	bbci	a0, 4, ffe03b9e <HAL_MpPcieMain+0x14e>
            {
                ulCurrRegValue |= FR_BIT;
ffe03b95:	f7ec81        	l32r	a8, ffe01b48 <_bss_table_end+0x1cc>
ffe03b98:	200080        	or	a0, a0, a8
ffe03b9b:	000146        	j	ffe03ba4 <HAL_MpPcieMain+0x154>

ffe03b9e <HAL_MpPcieMain+0x14e>:
            }
            else
            {
                ulCurrRegValue &= ~FR_BIT;
ffe03b9e:	f7ef91        	l32r	a9, ffe01b5c <_bss_table_end+0x1e0>
ffe03ba1:	100090        	and	a0, a0, a9
            }
            rP0_CMD = ulCurrRegValue;
            ulPreRegValue = ulCurrRegValue;
ffe03ba4:	00dd      	mov.n	a13, a0
            }
            else
            {
                ulCurrRegValue &= ~FR_BIT;
            }
            rP0_CMD = ulCurrRegValue;
ffe03ba6:	0020c0        	memw
ffe03ba9:	866c02        	s32i	a0, a12, 0x218
            ulPreRegValue = ulCurrRegValue;
        }

        if (TRUE == l_ulRevMpInt)
ffe03bac:	0020c0        	memw
ffe03baf:	3ea8      	l32i.n	a10, a14, 12
ffe03bb1:	5b1a66        	bnei	a10, 1, ffe03c10 <HAL_MpPcieMain+0x1c0>
        {
            l_ulRevMpInt = FALSE;
ffe03bb4:	0020c0        	memw
ffe03bb7:	000c      	movi.n	a0, 0
ffe03bb9:	3e09      	s32i.n	a0, a14, 12
LOCAL volatile HOSTC_INTMSK_REG * const l_pHostIntMskReg = (volatile HOSTC_INTMSK_REG *)(REG_BASE_HOSTC + 0x14);
GLOBAL volatile U32 l_ulRevMpInt;

void HAL_MpPcieCmdProc(void)
{
    l_pMpRegSet->bsCmdStatus = SUCCESS;
ffe03bbb:	2e08      	l32i.n	a0, a14, 8
ffe03bbd:	0020c0        	memw
ffe03bc0:	1b0c      	movi.n	a11, 1
ffe03bc2:	0640b2        	s8i	a11, a0, 6
    switch(l_pMpRegSet->bsCmdType)
ffe03bc5:	0020c0        	memw
ffe03bc8:	050032        	l8ui	a3, a0, 5
ffe03bcb:	33ac      	beqz.n	a3, ffe03bf2 <HAL_MpPcieMain+0x1a2>
ffe03bcd:	0f1326        	beqi	a3, 1, ffe03be0 <HAL_MpPcieMain+0x190>
ffe03bd0:	2d2366        	bnei	a3, 2, ffe03c01 <HAL_MpPcieMain+0x1b1>
            l_pMpRegSet->ulDataOut = *(volatile U32*)(l_pMpRegSet->ulSrcAddr);
        }break;
        
        case MP_CMD_MEM_EXE:
        {     
            ((PFUNC)l_pMpRegSet->ulExeEntry)();
ffe03bd3:	0020c0        	memw
ffe03bd6:	2008      	l32i.n	a0, a0, 8
ffe03bd8:	0000c0        	callx0	a0
        }break;
ffe03bdb:	2e08      	l32i.n	a0, a14, 8
ffe03bdd:	000806        	j	ffe03c01 <HAL_MpPcieMain+0x1b1>

ffe03be0 <HAL_MpPcieMain+0x190>:
            *(volatile U32*)(l_pMpRegSet->ulDstAddr) = l_pMpRegSet->ulDataIn;
        }break;

        case MP_CMD_MEM_RD:
        {
            l_pMpRegSet->ulDataOut = *(volatile U32*)(l_pMpRegSet->ulSrcAddr);
ffe03be0:	0020c0        	memw
ffe03be3:	2028      	l32i.n	a2, a0, 8
ffe03be5:	0020c0        	memw
ffe03be8:	0228      	l32i.n	a2, a2, 0
ffe03bea:	0020c0        	memw
ffe03bed:	3029      	s32i.n	a2, a0, 12
        }break;
ffe03bef:	000386        	j	ffe03c01 <HAL_MpPcieMain+0x1b1>

ffe03bf2 <HAL_MpPcieMain+0x1a2>:
    l_pMpRegSet->bsCmdStatus = SUCCESS;
    switch(l_pMpRegSet->bsCmdType)
    {
        case MP_CMD_MEM_WR:
        {
            *(volatile U32*)(l_pMpRegSet->ulDstAddr) = l_pMpRegSet->ulDataIn;
ffe03bf2:	0020c0        	memw
ffe03bf5:	2048      	l32i.n	a4, a0, 8
ffe03bf7:	0020c0        	memw
ffe03bfa:	3038      	l32i.n	a3, a0, 12
ffe03bfc:	0020c0        	memw
ffe03bff:	0439      	s32i.n	a3, a4, 0
        default:
        {
            ;
        }
    }
    l_pMpRegSet->bsCmdTrig = TRUE;
ffe03c01:	0f5d      	mov.n	a5, a15
ffe03c03:	0020c0        	memw
ffe03c06:	1068      	l32i.n	a6, a0, 4
ffe03c08:	e20654        	insbits	a5, a6, 0, 30
ffe03c0b:	0020c0        	memw
ffe03c0e:	1059      	s32i.n	a5, a0, 4
        {
            l_ulRevMpInt = FALSE;
            HAL_MpPcieCmdProc();
        }
        
        HAL_UartDBG();
ffe03c10:	ffe105        	call0	ffe03a24 <HAL_UartDBG>
    }
ffe03c13:	ffdbc6        	j	ffe03b86 <HAL_MpPcieMain+0x136>

ffe03c16 <HAL_MpPcieMain+0x1c6>:
	...

ffe03c18 <HAL_FlashIntEntry>:
Modify History:
    20140905    Victor Zhang Create
------------------------------------------------------------------------------*/
void HAL_FlashIntEntry(void)
{
    return;
ffe03c18:	f00d      	ret.n

ffe03c1a <HAL_FlashIntEntry+0x2>:
	...

ffe03c1c <HAL_SataIsFISXferAvailable>:
Modify History:
20090703         Yao Chen 001: first created
===================================================================*/
BOOL HAL_SataIsFISXferAvailable(void)
{
    if(0 == rSDC_IOControl)
ffe03c1c:	f75841        	l32r	a4, ffe0197c <_bss_table_end>
ffe03c1f:	0020c0        	memw
    {
        return TRUE;
    }
    else
    {
        return FALSE;
ffe03c22:	030c      	movi.n	a3, 0
Modify History:
20090703         Yao Chen 001: first created
===================================================================*/
BOOL HAL_SataIsFISXferAvailable(void)
{
    if(0 == rSDC_IOControl)
ffe03c24:	2c0442        	l8ui	a4, a4, 44
    {
        return TRUE;
ffe03c27:	120c      	movi.n	a2, 1
Modify History:
20090703         Yao Chen 001: first created
===================================================================*/
BOOL HAL_SataIsFISXferAvailable(void)
{
    if(0 == rSDC_IOControl)
ffe03c29:	932340        	movnez	a2, a3, a4
    {
        return TRUE;
    }
    else
    {
        return FALSE;
ffe03c2c:	f00d      	ret.n

ffe03c2e <HAL_SataIsFISXferAvailable+0x12>:
	...

ffe03c30 <HAL_SataInitialize>:
Description :Initialize sata.
Others      :
Modify      :
****************************************************************************/
void HAL_SataInitialize(void)
{
ffe03c30:	f7cc91        	l32r	a9, ffe01b60 <_bss_table_end+0x1e4>
ffe03c33:	f79121        	l32r	a2, ffe01a78 <_bss_table_end+0xfc>
ffe03c36:	140c      	movi.n	a4, 1
ffe03c38:	f77c61        	l32r	a6, ffe01a28 <_bss_table_end+0xac>
ffe03c3b:	f79b31        	l32r	a3, ffe01aa8 <_bss_table_end+0x12c>
ffe03c3e:	f750a1        	l32r	a10, ffe01980 <_bss_table_end+0x4>
    /*
    SDC_BASE_ADDRESS  0x14[7] = 1 :receive error command fis, do not interrupt FW.
    SDC_BASE_ADDRESS  0x11[0] = 1 :receive error command fis, interrupt FW.
    */
    *(volatile U8 *)(SDC_BASE_ADDRESS + 0x11) |= 1;
ffe03c41:	0020c0        	memw
ffe03c44:	910a52        	l8ui	a5, a10, 145
ffe03c47:	205540        	or	a5, a5, a4
ffe03c4a:	0020c0        	memw
ffe03c4d:	914a52        	s8i	a5, a10, 145
    *(volatile U8 *)(SDC_BASE_ADDRESS + 0x14) |= (1<<7);
ffe03c50:	80a0b2        	movi	a11, 128
ffe03c53:	0020c0        	memw
ffe03c56:	940a82        	l8ui	a8, a10, 148
ffe03c59:	2088b0        	or	a8, a8, a11
ffe03c5c:	0020c0        	memw
ffe03c5f:	944a82        	s8i	a8, a10, 148

    /* COM_Reset Block disable */
   // *(volatile U32*)(0x1ff81f10) &= ~(0x1 << 20); 
    
    /* Initialize SDMAC */
    rSDMAC_DataBuffBase = BUFFSIZE_32K | DUMMYDATA | HOLDXFER | BYPASSEN;/*|SDBFISwDMA */
ffe03c62:	0ba652        	movi	a5, 0x60b
ffe03c65:	f7bf71        	l32r	a7, ffe01b64 <_bss_table_end+0x1e8>
ffe03c68:	0020c0        	memw
ffe03c6b:	406752        	s32i	a5, a7, 0x100

    /* Set Sata mode enable */
    rSGESataMode |= 1;
ffe03c6e:	0020c0        	memw
ffe03c71:	4722b2        	l32i	a11, a2, 0x11c
ffe03c74:	20bb40        	or	a11, a11, a4
ffe03c77:	0020c0        	memw
ffe03c7a:	4762b2        	s32i	a11, a2, 0x11c


    /* DMAEXE_STE_EN(HW will wait SDBFISReady when DMA command )*/
    rSDC_ControlRegister = FW_DMAEXE_STE_EN;
ffe03c7d:	084c      	movi.n	a8, 64
ffe03c7f:	f73fa1        	l32r	a10, ffe0197c <_bss_table_end>
ffe03c82:	0020c0        	memw
ffe03c85:	4c4a82        	s8i	a8, a10, 76

    //rSDC_SHR_LockControl |= BIT_FW_CMDINT_EN;
    
#ifndef FW_CTRL_ALL_SDBFISREADY
    /* SDB FIS ready, default all valid */
    rSDC_SendSDBFISReady = 0xffffffff;
ffe03c88:	f77c      	movi.n	a7, -1
ffe03c8a:	0020c0        	memw
ffe03c8d:	956672        	s32i	a7, a6, 0x254
#endif

#ifdef FIS_Delay
/*************FISDelay set***********************************/
    rSDC_FISDelayControl |= TXSETDEVCOMPL_DLY_EN | 0xC0;
ffe03c90:	f7b651        	l32r	a5, ffe01b68 <_bss_table_end+0x1ec>
ffe03c93:	0020c0        	memw
ffe03c96:	b02642        	l32i	a4, a6, 0x2c0
ffe03c99:	204450        	or	a4, a4, a5
ffe03c9c:	0020c0        	memw
ffe03c9f:	b06642        	s32i	a4, a6, 0x2c0
    //rSACMDM_RPRDBaseAddr = RPRD_BASE - OTFB_START_ADDRESS;
    //rSACMDM_WPRDBaseAddr = WPRD_BASE - OTFB_START_ADDRESS;
    //g_pSataReadPRD = (SATA_PRD_ENTRY*)RPRD_BASE;
    //g_pSataWritePRD = (SATA_PRD_ENTRY*)WPRD_BASE;
    //enable PRD in SRAM
    rTOP_REGGLB40 |= (1 << 26);
ffe03ca2:	f7a521        	l32r	a2, ffe01b38 <_bss_table_end+0x1bc>
ffe03ca5:	0020c0        	memw
ffe03ca8:	9023b2        	l32i	a11, a3, 0x240
ffe03cab:	20bb20        	or	a11, a11, a2
ffe03cae:	0020c0        	memw
ffe03cb1:	9063b2        	s32i	a11, a3, 0x240
    rSDC_IntMask |= (BIT_SDC_INTSRC_FIS_CONTROL | 
                    BIT_SDC_INTSRC_TXOP|
                    BIT_SDC_INTSRC_RXDMACMPL|
                    BIT_SDC_INTSRC_SERROR);
#endif
    rSDC_IntMask |= (BIT_SDC_INTSRC_FIS_CONTROL | 
ffe03cb4:	f7aea1        	l32r	a10, ffe01b6c <_bss_table_end+0x1f0>
ffe03cb7:	0020c0        	memw
ffe03cba:	dc1982        	l16ui	a8, a9, 0x1b8
ffe03cbd:	2088a0        	or	a8, a8, a10
ffe03cc0:	0020c0        	memw
ffe03cc3:	dc5982        	s16i	a8, a9, 0x1b8

    /* cache status in OTFB */
    //rSACMDM_CACHE_STATUS_BASE_ADDRESS_SRAM = (U32)(CACHE_STATUS_BASE_OTFB - OTFB_START_ADDRESS);
    //g_pCacheStatus  = (U32*)OTFB_RAMDISK_CS;//CACHE_STATUS_BASE_OTFB;
#ifdef VT3514_C0
    *(volatile U32*)(0x1ff80804) |= (3<<27); //sata force GEN1 0x1ff80804 bit [28:27] to 2'b11  
ffe03cc6:	f7aa71        	l32r	a7, ffe01b70 <_bss_table_end+0x1f4>
ffe03cc9:	0020c0        	memw
ffe03ccc:	812652        	l32i	a5, a6, 0x204
ffe03ccf:	205570        	or	a5, a5, a7
ffe03cd2:	0020c0        	memw
ffe03cd5:	816652        	s32i	a5, a6, 0x204
#endif
    /* Release reset signal for SATA */
    rGLB_18 &= ~(R_RST_SDC_DMA | R_RST_LPHY | R_RST_SDC_CMD | R_RST_SDC);
ffe03cd8:	f7a741        	l32r	a4, ffe01b74 <_bss_table_end+0x1f8>
ffe03cdb:	0020c0        	memw
ffe03cde:	862322        	l32i	a2, a3, 0x218
ffe03ce1:	102240        	and	a2, a2, a4
ffe03ce4:	0020c0        	memw
ffe03ce7:	866322        	s32i	a2, a3, 0x218

    return;
ffe03cea:	f00d      	ret.n

ffe03cec <HAL_SataSendGoodStatus>:
Modify History:
20090528    Yao Chen    001: first created
===================================================================*/
void HAL_SataSendGoodStatus(void)
{
    Lock_ShadowRegister();
ffe03cec:	8a0c      	movi.n	a10, 8
Note: 
Modify History:
20090528    Yao Chen    001: first created
===================================================================*/
void HAL_SataSendGoodStatus(void)
{
ffe03cee:	f72321        	l32r	a2, ffe0197c <_bss_table_end>
ffe03cf1:	f0c112        	addi	a1, a1, -16
ffe03cf4:	0109      	s32i.n	a0, a1, 0
ffe03cf6:	050c      	movi.n	a5, 0
ffe03cf8:	160c      	movi.n	a6, 1
ffe03cfa:	f72191        	l32r	a9, ffe01980 <_bss_table_end+0x4>
    Lock_ShadowRegister();
ffe03cfd:	0020c0        	memw
ffe03d00:	8f0982        	l8ui	a8, a9, 143
ffe03d03:	2088a0        	or	a8, a8, a10
ffe03d06:	0020c0        	memw
ffe03d09:	8f4982        	s8i	a8, a9, 143
    rSDC_COMMAND_STATUS = 0x50;
ffe03d0c:	075c      	movi.n	a7, 80
ffe03d0e:	0020c0        	memw
ffe03d11:	0b4272        	s8i	a7, a2, 11
    rSDC_FEATURE_ERROR = 1;
ffe03d14:	0020c0        	memw
ffe03d17:	054262        	s8i	a6, a2, 5
    rSDC_LBALOW = 1;
ffe03d1a:	0020c0        	memw
ffe03d1d:	074262        	s8i	a6, a2, 7
    rSDC_LBAMID = 0;
ffe03d20:	0020c0        	memw
ffe03d23:	084252        	s8i	a5, a2, 8
    rSDC_LBAHIGH = 0;
ffe03d26:	0020c0        	memw
ffe03d29:	094252        	s8i	a5, a2, 9
    rSDC_SECCNT = 1;
ffe03d2c:	0020c0        	memw
ffe03d2f:	064262        	s8i	a6, a2, 6
    rSDC_DEVICE_HEAD = 0;
ffe03d32:	0020c0        	memw
ffe03d35:	0a4252        	s8i	a5, a2, 10
    rSDC_FISDirInt &= (~BIT_SDC_FIS_INTFLAG);
ffe03d38:	fda042        	movi	a4, 253
ffe03d3b:	0020c0        	memw
ffe03d3e:	2b0232        	l8ui	a3, a2, 43
ffe03d41:	103340        	and	a3, a3, a4
ffe03d44:	0020c0        	memw
ffe03d47:	2b4232        	s8i	a3, a2, 43
Modify History:
20090528    Yao Chen    001: first created
===================================================================*/
void HAL_SataSendRegD2HFIS(void)
{
    rSDC_IOControl = BIT_SDC_IOCTRL_SENDREGD2H_FIS;
ffe03d4a:	80af02        	movi	a0, -128
ffe03d4d:	0020c0        	memw
ffe03d50:	2c4202        	s8i	a0, a2, 44

ffe03d53 <HAL_SataSendGoodStatus+0x67>:
    rSDC_LBAHIGH = 0;
    rSDC_SECCNT = 1;
    rSDC_DEVICE_HEAD = 0;
    rSDC_FISDirInt &= (~BIT_SDC_FIS_INTFLAG);
    HAL_SataSendRegD2HFIS();
    while ( FALSE == HAL_SataIsFISXferAvailable() );
ffe03d53:	ffec85        	call0	ffe03c1c <HAL_SataIsFISXferAvailable>
ffe03d56:	ff9216        	beqz	a2, ffe03d53 <HAL_SataSendGoodStatus+0x67>
    rSDC_FEATURE_ERROR = 0;
ffe03d59:	0020c0        	memw
ffe03d5c:	f70841        	l32r	a4, ffe0197c <_bss_table_end>
ffe03d5f:	030c      	movi.n	a3, 0
ffe03d61:	054432        	s8i	a3, a4, 5
    UnLock_ShadowRegister();
ffe03d64:	f7a022        	movi	a2, 247
ffe03d67:	0020c0        	memw
ffe03d6a:	f70501        	l32r	a0, ffe01980 <_bss_table_end+0x4>
ffe03d6d:	8f00b2        	l8ui	a11, a0, 143
ffe03d70:	10bb20        	and	a11, a11, a2
ffe03d73:	0020c0        	memw
ffe03d76:	8f40b2        	s8i	a11, a0, 143
    return;
ffe03d79:	0108      	l32i.n	a0, a1, 0
ffe03d7b:	10c112        	addi	a1, a1, 16
ffe03d7e:	f00d      	ret.n

ffe03d80 <HAL_SataFeedbacktoHW>:
    1. 2013.11.25 Haven Yang create function
==============================================================================*/
void HAL_SataFeedbacktoHW(HCMD* pHCmd)
{
    /* FW Decode program : command tag & command protocol */
    if (0 == g_ulEncounterError)
ffe03d80:	f70131        	l32r	a3, ffe01984 <_bss_table_end+0x8>
ffe03d83:	a80332        	l8ui	a3, a3, 168
Usage      : 
History    : 
    1. 2013.11.25 Haven Yang create function
==============================================================================*/
void HAL_SataFeedbacktoHW(HCMD* pHCmd)
{
ffe03d86:	f6fd41        	l32r	a4, ffe0197c <_bss_table_end>
ffe03d89:	03dc      	bnez.n	a3, ffe03d9d <HAL_SataFeedbacktoHW+0x1d>
    /* FW Decode program : command tag & command protocol */
    if (0 == g_ulEncounterError)
    {
        rSDC_FW_DECODE = (pHCmd->ucCmdTag << 3) | pHCmd->ucCmdProtocol;
ffe03d8b:	050262        	l8ui	a6, a2, 5
ffe03d8e:	060252        	l8ui	a5, a2, 6
ffe03d91:	1166d0        	slli	a6, a6, 3
ffe03d94:	205560        	or	a5, a5, a6
ffe03d97:	0020c0        	memw
ffe03d9a:	4d4452        	s8i	a5, a4, 77

ffe03d9d <HAL_SataFeedbacktoHW+0x1d>:
    }

    /* clear big busy, inform hardware that command receiving has been completed */
    rSDC_FW_Ctrl |= FW_CFGCMD_DONE;
ffe03d9d:	290c      	movi.n	a9, 2
ffe03d9f:	0020c0        	memw
ffe03da2:	4e0482        	l8ui	a8, a4, 78
ffe03da5:	208890        	or	a8, a8, a9
ffe03da8:	0020c0        	memw
ffe03dab:	4e4482        	s8i	a8, a4, 78

    /* Reset hardware NCQ state machine to idle */
    if (HCMD_PROTOCOL_NCQ != pHCmd->ucCmdProtocol)
ffe03dae:	060272        	l8ui	a7, a2, 6
    {
        rSDC_FW_Ctrl |= FW_CLR_NCQEXE;
ffe03db1:	1b0c      	movi.n	a11, 1

    /* clear big busy, inform hardware that command receiving has been completed */
    rSDC_FW_Ctrl |= FW_CFGCMD_DONE;

    /* Reset hardware NCQ state machine to idle */
    if (HCMD_PROTOCOL_NCQ != pHCmd->ucCmdProtocol)
ffe03db3:	0e6726        	beqi	a7, 6, ffe03dc5 <HAL_SataFeedbacktoHW+0x45>
    {
        rSDC_FW_Ctrl |= FW_CLR_NCQEXE;
ffe03db6:	0020c0        	memw
ffe03db9:	4e04a2        	l8ui	a10, a4, 78
ffe03dbc:	20aab0        	or	a10, a10, a11
ffe03dbf:	0020c0        	memw
ffe03dc2:	4e44a2        	s8i	a10, a4, 78
    }
    
}
ffe03dc5:	f00d      	ret.n

ffe03dc7 <HAL_SataFeedbacktoHW+0x47>:
	...

ffe03dc8 <HAL_SataSetTransferParam48>:
****************************************************************************/
void HAL_SataSetTransferParam48(HCMD* pHostCmd)
{
    U32 ulActualSecCount;

    ulActualSecCount = rSDC_SHRLCH_SECCNT16;
ffe03dc8:	f76631        	l32r	a3, ffe01b60 <_bss_table_end+0x1e4>
ffe03dcb:	0020c0        	memw

    if(0 == ulActualSecCount)
    {
        ulActualSecCount = 65536;
    }
    pHostCmd->ulCmdLba = rSDC_SHRLCH_LBA48;
ffe03dce:	f71651        	l32r	a5, ffe01a28 <_bss_table_end+0xac>
****************************************************************************/
void HAL_SataSetTransferParam48(HCMD* pHostCmd)
{
    U32 ulActualSecCount;

    ulActualSecCount = rSDC_SHRLCH_SECCNT16;
ffe03dd1:	ec1332        	l16ui	a3, a3, 0x1d8

    if(0 == ulActualSecCount)
    {
        ulActualSecCount = 65536;
    }
    pHostCmd->ulCmdLba = rSDC_SHRLCH_LBA48;
ffe03dd4:	0020c0        	memw
    pHostCmd->ulCmdSectorCnt = ulActualSecCount;
ffe03dd7:	f75b41        	l32r	a4, ffe01b44 <_bss_table_end+0x1c8>

    if(0 == ulActualSecCount)
    {
        ulActualSecCount = 65536;
    }
    pHostCmd->ulCmdLba = rSDC_SHRLCH_LBA48;
ffe03dda:	b52552        	l32i	a5, a5, 0x2d4
ffe03ddd:	0259      	s32i.n	a5, a2, 0
    pHostCmd->ulCmdSectorCnt = ulActualSecCount;
ffe03ddf:	833430        	moveqz	a3, a4, a3
ffe03de2:	2239      	s32i.n	a3, a2, 8
    pHostCmd->ulCmdRemSector = ulActualSecCount;
ffe03de4:	3239      	s32i.n	a3, a2, 12

    return;
ffe03de6:	f00d      	ret.n

ffe03de8 <HAL_SataSetTransferParam28>:
Description :Set parameters for 28 bit LBA cmd.
Others      :
Modify      :
****************************************************************************/
void HAL_SataSetTransferParam28(HCMD* pHostCmd)
{
ffe03de8:	f6e541        	l32r	a4, ffe0197c <_bss_table_end>
    U32 ulActualLBA;
    U32 ulActualSecCount;
    U8 ucHeadNum, ucSecNum;
    U16 usCylinNum;

    if(0 != rSDC_SHRLCH_DEV6)
ffe03deb:	0020c0        	memw
ffe03dee:	620432        	l8ui	a3, a4, 98
    {
        ulActualLBA = rSDC_SHRLCH_LBA28;
ffe03df1:	f70d51        	l32r	a5, ffe01a28 <_bss_table_end+0xac>
    U32 ulActualLBA;
    U32 ulActualSecCount;
    U8 ucHeadNum, ucSecNum;
    U16 usCylinNum;

    if(0 != rSDC_SHRLCH_DEV6)
ffe03df4:	93fc      	bnez.n	a3, ffe03e31 <HAL_SataSetTransferParam28+0x49>
        ulActualLBA = rSDC_SHRLCH_LBA28;
    }
    else
    {
        //For CHS command format
        ucHeadNum = rSDC_DEVICE_HEAD & 0xF;
ffe03df6:	0020c0        	memw
ffe03df9:	0a0462        	l8ui	a6, a4, 10
ffe03dfc:	346060        	extui	a6, a6, 0, 4
        ucSecNum = rSDC_LBALOW;
ffe03dff:	0020c0        	memw
ffe03e02:	070452        	l8ui	a5, a4, 7
        usCylinNum = (rSDC_LBAHIGH << 8) + rSDC_LBAMID;
ffe03e05:	0020c0        	memw
ffe03e08:	0804a2        	l8ui	a10, a4, 8
ffe03e0b:	0020c0        	memw
        ulActualLBA = ( usCylinNum * g_pSataIdentifyData[55] + ucHeadNum ) * g_pSataIdentifyData[56] + ucSecNum - 1;
ffe03e0e:	f6dd71        	l32r	a7, ffe01984 <_bss_table_end+0x8>
    else
    {
        //For CHS command format
        ucHeadNum = rSDC_DEVICE_HEAD & 0xF;
        ucSecNum = rSDC_LBALOW;
        usCylinNum = (rSDC_LBAHIGH << 8) + rSDC_LBAMID;
ffe03e11:	090492        	l8ui	a9, a4, 9
        ulActualLBA = ( usCylinNum * g_pSataIdentifyData[55] + ucHeadNum ) * g_pSataIdentifyData[56] + ucSecNum - 1;
ffe03e14:	292772        	l32i	a7, a7, 164
    else
    {
        //For CHS command format
        ucHeadNum = rSDC_DEVICE_HEAD & 0xF;
        ucSecNum = rSDC_LBALOW;
        usCylinNum = (rSDC_LBAHIGH << 8) + rSDC_LBAMID;
ffe03e17:	119980        	slli	a9, a9, 8
        ulActualLBA = ( usCylinNum * g_pSataIdentifyData[55] + ucHeadNum ) * g_pSataIdentifyData[56] + ucSecNum - 1;
ffe03e1a:	371782        	l16ui	a8, a7, 110
    else
    {
        //For CHS command format
        ucHeadNum = rSDC_DEVICE_HEAD & 0xF;
        ucSecNum = rSDC_LBALOW;
        usCylinNum = (rSDC_LBAHIGH << 8) + rSDC_LBAMID;
ffe03e1d:	99aa      	add.n	a9, a9, a10
        ulActualLBA = ( usCylinNum * g_pSataIdentifyData[55] + ucHeadNum ) * g_pSataIdentifyData[56] + ucSecNum - 1;
ffe03e1f:	c18890        	mul16u	a8, a8, a9
ffe03e22:	381772        	l16ui	a7, a7, 112
ffe03e25:	668a      	add.n	a6, a6, a8
ffe03e27:	826670        	mull	a6, a6, a7
ffe03e2a:	556a      	add.n	a5, a5, a6
ffe03e2c:	550b      	addi.n	a5, a5, -1
ffe03e2e:	000146        	j	ffe03e37 <HAL_SataSetTransferParam28+0x4f>

ffe03e31 <HAL_SataSetTransferParam28+0x49>:
    U8 ucHeadNum, ucSecNum;
    U16 usCylinNum;

    if(0 != rSDC_SHRLCH_DEV6)
    {
        ulActualLBA = rSDC_SHRLCH_LBA28;
ffe03e31:	0020c0        	memw
ffe03e34:	b42552        	l32i	a5, a5, 0x2d0
        ucSecNum = rSDC_LBALOW;
        usCylinNum = (rSDC_LBAHIGH << 8) + rSDC_LBAMID;
        ulActualLBA = ( usCylinNum * g_pSataIdentifyData[55] + ucHeadNum ) * g_pSataIdentifyData[56] + ucSecNum - 1;
    }

    ulActualSecCount = (0 == rSDC_SHRLCH_SECCNT8) ? 256 : rSDC_SECCNT;
ffe03e37:	0020c0        	memw
ffe03e3a:	580462        	l8ui	a6, a4, 88
ffe03e3d:	46cc      	bnez.n	a6, ffe03e45 <HAL_SataSetTransferParam28+0x5d>
ffe03e3f:	00a142        	movi	a4, 0x100
ffe03e42:	000146        	j	ffe03e4b <HAL_SataSetTransferParam28+0x63>

ffe03e45 <HAL_SataSetTransferParam28+0x5d>:
ffe03e45:	0020c0        	memw
ffe03e48:	060442        	l8ui	a4, a4, 6

    pHostCmd->ulCmdLba = ulActualLBA;
ffe03e4b:	0259      	s32i.n	a5, a2, 0
    pHostCmd->ulCmdSectorCnt = ulActualSecCount;
ffe03e4d:	2249      	s32i.n	a4, a2, 8
    pHostCmd->ulCmdRemSector = ulActualSecCount;
ffe03e4f:	3249      	s32i.n	a4, a2, 12

    return;
ffe03e51:	f00d      	ret.n

ffe03e53 <HAL_SataSetTransferParam28+0x6b>:
	...

ffe03e54 <HAL_SATAIntEntry>:
Note: 
Modify History:
    20140905    Victor Zhang Create
------------------------------------------------------------------------------*/
void HAL_SATAIntEntry(void)
{
ffe03e54:	e0c112        	addi	a1, a1, -32
ffe03e57:	31d9      	s32i.n	a13, a1, 12
ffe03e59:	41e9      	s32i.n	a14, a1, 16
ffe03e5b:	51f9      	s32i.n	a15, a1, 20
ffe03e5d:	21c9      	s32i.n	a12, a1, 8
ffe03e5f:	1109      	s32i.n	a0, a1, 4
ffe03e61:	f74501        	l32r	a0, ffe01b78 <_bss_table_end+0x1fc>
ffe03e64:	f6f1c1        	l32r	a12, ffe01a28 <_bss_table_end+0xac>

#ifdef SIM_XTENSA
    rTracer = TL_SATA_INTERRUPT_ENTRY;
#endif

    uSDC_IntSrcPending = rSDC_IntSrcPending;
ffe03e67:	0020c0        	memw
ffe03e6a:	ac2cd2        	l32i	a13, a12, 0x2b0
    {
        L1_ErrHandle_SyncEscapeISR();
    }
*/
    /* clear BIT_SDC_INTSRC_PENDING before  BIT_SDC_INTSRC_FIS_COMMAND */
    if (uSDC_IntSrcPending & BIT_SDC_INTSRC_PENDING)
ffe03e6d:	057d17        	bbci	a13, 17, ffe03e76 <HAL_SATAIntEntry+0x22>
    {
        rSDC_IntSrcPending = BIT_SDC_INTSRC_PENDING;
ffe03e70:	0020c0        	memw
ffe03e73:	ac6c02        	s32i	a0, a12, 0x2b0

ffe03e76 <HAL_SATAIntEntry+0x22>:
ffe03e76:	1e0c      	movi.n	a14, 1
ffe03e78:	f6c351        	l32r	a5, ffe01984 <_bss_table_end+0x8>
ffe03e7b:	040cd0        	extui	a0, a13, 12, 1
ffe03e7e:	0e3016        	beqz	a0, ffe03f65 <HAL_SATAIntEntry+0x111>
    if( uSDC_IntSrcPending & BIT_SDC_INTSRC_FIS_COMMAND )
    {
        U32 delay = 10; // For cycle length of latch shr is 22ns ,and of MCU is 4ns 
                        // to make sure the shr latch completed 
        /*latch SHR */
        rSDC_SHRLCH_EN = 1;
ffe03e81:	f6be71        	l32r	a7, ffe0197c <_bss_table_end>
ffe03e84:	0020c0        	memw
ffe03e87:	6047e2        	s8i	a14, a7, 96
ffe03e8a:	a40c      	movi.n	a4, 10

        while (delay--);   // delay 40ns 
ffe03e8c:	993c      	movi.n	a9, 57
ffe03e8e:	580c      	movi.n	a8, 5
ffe03e90:	0f0c      	movi.n	a15, 0
ffe03e92:	f73a21        	l32r	a2, ffe01b7c <_bss_table_end+0x200>
void HAL_SataRcvCmdISR(void)
{
    U8 ucNewCmdTag;
    INTCALLBACKPARAM CurrIntParam;

    g_ulEncounterError = 0;
ffe03e95:	a845f2        	s8i	a15, a5, 168
    {
        DBG_Getch();
    }
#endif

    pNewCmd->ucCmdStatus = HCMD_STATE_RECEIVED;
ffe03e98:	94c2a2        	addi	a10, a2, -108
ffe03e9b:	0a0d      	mov.n	a0, a10
        U32 delay = 10; // For cycle length of latch shr is 22ns ,and of MCU is 4ns 
                        // to make sure the shr latch completed 
        /*latch SHR */
        rSDC_SHRLCH_EN = 1;

        while (delay--);   // delay 40ns 
ffe03e9d:	440b      	addi.n	a4, a4, -1
ffe03e9f:	fa0466        	bnei	a4, -1, ffe03e9d <HAL_SATAIntEntry+0x49>
{
    U8 ucCmdCode;
    U8 ucCmdTag;
    HCMD* pNewCmd;

    ucCmdCode = rSDC_SHRLCH_COMMAND;
ffe03ea2:	0020c0        	memw
ffe03ea5:	5c0762        	l8ui	a6, a7, 92
    {
        DBG_Getch();
    }
#endif

    pNewCmd->ucCmdStatus = HCMD_STATE_RECEIVED;
ffe03ea8:	7f4ae2        	s8i	a14, a10, 127
    pNewCmd->ucCmdCode = ucCmdCode;
ffe03eab:	704a62        	s8i	a6, a10, 112
    pNewCmd->ucCmdTag = ucCmdTag;
ffe03eae:	714af2        	s8i	a15, a10, 113

    switch( ucCmdCode )
ffe03eb1:	2e2697        	blt	a6, a9, ffe03ee3 <HAL_SATAIntEntry+0x8f>
ffe03eb4:	47a967        	bge	a9, a6, ffe03eff <HAL_SATAIntEntry+0xab>
ffe03eb7:	c5a072        	movi	a7, 197
ffe03eba:	02a677        	bge	a6, a7, ffe03ec0 <HAL_SATAIntEntry+0x6c>
ffe03ebd:	005b46        	j	ffe0402e <HAL_SATAIntEntry+0x1da>
ffe03ec0:	022767        	blt	a7, a6, ffe03ec6 <HAL_SATAIntEntry+0x72>
ffe03ec3:	0069c6        	j	ffe0406e <HAL_SATAIntEntry+0x21a>
ffe03ec6:	caa072        	movi	a7, 202
ffe03ec9:	02a677        	bge	a6, a7, ffe03ecf <HAL_SATAIntEntry+0x7b>
ffe03ecc:	0073c6        	j	ffe0409f <HAL_SATAIntEntry+0x24b>
ffe03ecf:	452767        	blt	a7, a6, ffe03f18 <HAL_SATAIntEntry+0xc4>
        HAL_SataSetTransferParam28(pNewCmd);
        break;

    case ATA_CMD_WRITE_DMA:
        pNewCmd->ucCmdType = HCMD_TYPE_DATA;
        pNewCmd->ucCmdProtocol = HCMD_PROTOCOL_DMA;
ffe03ed2:	724a82        	s8i	a8, a10, 114
        pNewCmd->ucCmdRW = HCMD_READ;
        HAL_SataSetTransferParam28(pNewCmd);
        break;

    case ATA_CMD_WRITE_DMA:
        pNewCmd->ucCmdType = HCMD_TYPE_DATA;
ffe03ed5:	7c4af2        	s8i	a15, a10, 124
        pNewCmd->ucCmdProtocol = HCMD_PROTOCOL_DMA;
        pNewCmd->ucCmdRW = HCMD_WRITE;
ffe03ed8:	734af2        	s8i	a15, a10, 115
        HAL_SataSetTransferParam28(pNewCmd);
ffe03edb:	0129      	s32i.n	a2, a1, 0
ffe03edd:	fff085        	call0	ffe03de8 <HAL_SataSetTransferParam28>
        break;
ffe03ee0:	001046        	j	ffe03f25 <HAL_SATAIntEntry+0xd1>

ffe03ee3 <HAL_SATAIntEntry+0x8f>:

    pNewCmd->ucCmdStatus = HCMD_STATE_RECEIVED;
    pNewCmd->ucCmdCode = ucCmdCode;
    pNewCmd->ucCmdTag = ucCmdTag;

    switch( ucCmdCode )
ffe03ee3:	972c      	movi.n	a7, 41
ffe03ee5:	02a677        	bge	a6, a7, ffe03eeb <HAL_SATAIntEntry+0x97>
ffe03ee8:	004746        	j	ffe04009 <HAL_SATAIntEntry+0x1b5>
ffe03eeb:	022767        	blt	a7, a6, ffe03ef1 <HAL_SATAIntEntry+0x9d>
ffe03eee:	007786        	j	ffe040d0 <HAL_SATAIntEntry+0x27c>
ffe03ef1:	473c      	movi.n	a7, 52
ffe03ef3:	02a677        	bge	a6, a7, ffe03ef9 <HAL_SATAIntEntry+0xa5>
ffe03ef6:	005b86        	j	ffe04068 <HAL_SATAIntEntry+0x214>
ffe03ef9:	02a767        	bge	a7, a6, ffe03eff <HAL_SATAIntEntry+0xab>
ffe03efc:	006e46        	j	ffe040b9 <HAL_SATAIntEntry+0x265>
    case ATA_CMD_WRITE_SECTOR_EXT:
    case ATA_CMD_WRITE_MULTIPLE_EXT:
        pNewCmd->ucCmdType = HCMD_TYPE_DATA;
        pNewCmd->ucCmdProtocol = HCMD_PROTOCOL_PIO;
        pNewCmd->ucCmdRW = HCMD_WRITE;
        HAL_SataSetTransferParam48(pNewCmd);
ffe03eff:	0129      	s32i.n	a2, a1, 0
        HAL_SataSetTransferParam48(pNewCmd);
        break;

    case ATA_CMD_WRITE_SECTOR_EXT:
    case ATA_CMD_WRITE_MULTIPLE_EXT:
        pNewCmd->ucCmdType = HCMD_TYPE_DATA;
ffe03f01:	7c40f2        	s8i	a15, a0, 124
        pNewCmd->ucCmdProtocol = HCMD_PROTOCOL_PIO;
        pNewCmd->ucCmdRW = HCMD_WRITE;
ffe03f04:	7340f2        	s8i	a15, a0, 115
        break;

    case ATA_CMD_WRITE_SECTOR_EXT:
    case ATA_CMD_WRITE_MULTIPLE_EXT:
        pNewCmd->ucCmdType = HCMD_TYPE_DATA;
        pNewCmd->ucCmdProtocol = HCMD_PROTOCOL_PIO;
ffe03f07:	430c      	movi.n	a3, 4
ffe03f09:	724032        	s8i	a3, a0, 114
        pNewCmd->ucCmdRW = HCMD_WRITE;
        HAL_SataSetTransferParam48(pNewCmd);
ffe03f0c:	ffeb85        	call0	ffe03dc8 <HAL_SataSetTransferParam48>
        break;
ffe03f0f:	000486        	j	ffe03f25 <HAL_SATAIntEntry+0xd1>

ffe03f12 <HAL_SATAIntEntry+0xbe>:
ffe03f12:	e0c642        	addi	a4, a6, -32
ffe03f15:	1d3416        	beqz	a4, ffe040ec <HAL_SATAIntEntry+0x298>
        pNewCmd->ulCmdSectorCnt = 1;
        pNewCmd->ulCmdRemSector = 1;
        break;  */

    default:
        pNewCmd->ucCmdType = HCMD_TYPE_NONDATA;
ffe03f18:	7c40e2        	s8i	a14, a0, 124
        pNewCmd->ucCmdRW = HCMD_READ;
ffe03f1b:	7340e2        	s8i	a14, a0, 115
ffe03f1e:	0129      	s32i.n	a2, a1, 0
        pNewCmd->ucCmdProtocol = HCMD_PROTOCOL_PIO;
ffe03f20:	470c      	movi.n	a7, 4
ffe03f22:	724072        	s8i	a7, a0, 114
        break;
    }

    HAL_SataFeedbacktoHW(pNewCmd);
ffe03f25:	0128      	l32i.n	a2, a1, 0
ffe03f27:	ffe585        	call0	ffe03d80 <HAL_SataFeedbacktoHW>

    g_ulEncounterError = 0;
    
    ucNewCmdTag = HAL_SataGetCmdFromSRB();

    if (0 == g_ulEncounterError)
ffe03f2a:	f69651        	l32r	a5, ffe01984 <_bss_table_end+0x8>
ffe03f2d:	a80582        	l8ui	a8, a5, 168
ffe03f30:	f69321        	l32r	a2, ffe0197c <_bss_table_end>
ffe03f33:	f8dc      	bnez.n	a8, ffe03f56 <HAL_SATAIntEntry+0x102>
    {
        ulNextTail =0 ;
    }

    /* if the FIFO is full, return */
    if(M_HCMDFIFO_FULL(LocalHCMDFIFOHead, ulNextTail) )
ffe03f35:	2f2592        	l32i	a9, a5, 188
ffe03f38:	1b0c      	movi.n	a11, 1
ffe03f3a:	302572        	l32i	a7, a5, 192
ffe03f3d:	0a0c      	movi.n	a10, 0
ffe03f3f:	671b      	addi.n	a6, a7, 1
ffe03f41:	e0c702        	addi	a0, a7, -32
ffe03f44:	83ab00        	moveqz	a10, a11, a0
ffe03f47:	936fa0        	movnez	a6, a15, a10
ffe03f4a:	081967        	beq	a9, a6, ffe03f56 <HAL_SATAIntEntry+0x102>
    }
    }
    */
    LocalHCMDFIFO[LocalHCMDFIFOTail] = ucNewCmdTag ;

    LocalHCMDFIFOTail= ulNextTail ;
ffe03f4d:	306562        	s32i	a6, a5, 192
    {
    ucIndex =0 ;
    }
    }
    */
    LocalHCMDFIFO[LocalHCMDFIFOTail] = ucNewCmdTag ;
ffe03f50:	a03750        	addx4	a3, a7, a5
ffe03f53:	ec63f2        	s32i	a15, a3, 0x3b0
        HAL_SataRcvCmdISR();
        
#ifdef SIM
        rSDC_IntSrcPending &= ~BIT_SDC_INTSRC_FIS_COMMAND;
#else
        rSDC_IntSrcPending = BIT_SDC_INTSRC_FIS_COMMAND;
ffe03f56:	0020c0        	memw
ffe03f59:	f70941        	l32r	a4, ffe01b80 <_bss_table_end+0x204>
ffe03f5c:	ac6c42        	s32i	a4, a12, 0x2b0
#endif
        
        rSDC_SHRLCH_EN = 0;
ffe03f5f:	0020c0        	memw
ffe03f62:	6042f2        	s8i	a15, a2, 96
ffe03f65:	f6f821        	l32r	a2, ffe01b48 <_bss_table_end+0x1cc>

    }   

    if( uSDC_IntSrcPending & BIT_SDC_INTSRC_RXPIO_DATA )
ffe03f68:	086de7        	bbci	a13, 14, ffe03f74 <HAL_SATAIntEntry+0x120>
Others      :
Modify      :
****************************************************************************/
void HAL_RcvPIODataISR(void)
{
    g_bFlagPIODataRec = TRUE;
ffe03f6b:	2c65e2        	s32i	a14, a5, 176

    rSDC_IntSrcPending = BIT_SDC_INTSRC_RXPIO_DATA;
ffe03f6e:	0020c0        	memw
ffe03f71:	ac6c22        	s32i	a2, a12, 0x2b0
        rSDC_SHRLCH_EN = 0;

    }   

    if( uSDC_IntSrcPending & BIT_SDC_INTSRC_RXPIO_DATA )
        HAL_RcvPIODataISR();
ffe03f74:	f683f1        	l32r	a15, ffe01980 <_bss_table_end+0x4>
ffe03f77:	f70321        	l32r	a2, ffe01b84 <_bss_table_end+0x208>

    if( uSDC_IntSrcPending & BIT_SDC_INTSRC_OOB_DONE)
ffe03f7a:	106dd7        	bbci	a13, 13, ffe03f8e <HAL_SATAIntEntry+0x13a>
{
    //HAL_SataInitialize();  
#ifdef SIM_XTENSA
    rTracer = TL_FW_OOBDONE;
#endif       
    rSDC_IntSrcPending = BIT_SDC_INTSRC_OOB_DONE;
ffe03f7d:	0020c0        	memw
ffe03f80:	ac6c22        	s32i	a2, a12, 0x2b0
    
    rSDC_PHYControl15 = 2; /* Clear the safety protection for FIS/PMREQ trigger registers */
ffe03f83:	250c      	movi.n	a5, 2
ffe03f85:	0020c0        	memw
ffe03f88:	924f52        	s8i	a5, a15, 146
    HAL_SataSendGoodStatus();
ffe03f8b:	ffd605        	call0	ffe03cec <HAL_SataSendGoodStatus>
    if( uSDC_IntSrcPending & BIT_SDC_INTSRC_OOB_DONE)
    {
        HAL_OOBDoneISR();
    }

    if( uSDC_IntSrcPending & BIT_SDC_INTSRC_COMRESET_RCV)
ffe03f8e:	117d07        	bbci	a13, 16, ffe03fa3 <HAL_SATAIntEntry+0x14f>
{
#ifdef SIM_XTENSA
    rTracer = TL_FW_COMRESET;
#endif   

    HAL_SataInitialize();
ffe03f91:	ffc9c5        	call0	ffe03c30 <HAL_SataInitialize>
    
    rSDC_IntSrcPending = BIT_SDC_INTSRC_COMRESET_RCV;
ffe03f94:	0020c0        	memw
ffe03f97:	f6eb61        	l32r	a6, ffe01b44 <_bss_table_end+0x1c8>
ffe03f9a:	ac6c62        	s32i	a6, a12, 0x2b0
    
    rSDC_PHYControl15 = 1; /* Inform hardware to send COMINIT and continue OOB sequence */
ffe03f9d:	0020c0        	memw
ffe03fa0:	924fe2        	s8i	a14, a15, 146
        HAL_OOBDoneISR();
    }

    if( uSDC_IntSrcPending & BIT_SDC_INTSRC_COMRESET_RCV)
    {
        HAL_COMResetISR();
ffe03fa3:	00a262        	movi	a6, 0x200
    }

    if (uSDC_IntSrcPending & BIT_SDC_INTSRC_NCQFINISH)
ffe03fa6:	3f6d97        	bbci	a13, 9, ffe03fe9 <HAL_SATAIntEntry+0x195>
 //   Dbg_AutoSetFISDelay();// for hw FisDelay test only. 

#ifdef SIM
    tag = sim_CLZ(rSDC_NCQCMD_HOLD_TAG);
#else
    tag = _TIE_via_CLZ(rSDC_NCQCMD_HOLD_TAG);
ffe03fa9:	0020c0        	memw
ffe03fac:	af2c82        	l32i	a8, a12, 0x2bc
    else
    {
        tag = 31 - tag;
    }
   
    rSDC_NCQCMD_CLR_TAG |= (1 << tag);
ffe03faf:	fa1c      	movi.n	a10, 31
 //   Dbg_AutoSetFISDelay();// for hw FisDelay test only. 

#ifdef SIM
    tag = sim_CLZ(rSDC_NCQCMD_HOLD_TAG);
#else
    tag = _TIE_via_CLZ(rSDC_NCQCMD_HOLD_TAG);
ffe03fb1:	018822        	clz	a2, a8

#ifdef SIM_XTENSA
    rTracer = tag;
#endif

    if (32 == tag)
ffe03fb4:	747020        	extui	a7, a2, 0, 8
ffe03fb7:	28c726        	beqi	a7, 32, ffe03fe3 <HAL_SATAIntEntry+0x18f>
    else
    {
        tag = 31 - tag;
    }
   
    rSDC_NCQCMD_CLR_TAG |= (1 << tag);
ffe03fba:	c0aa20        	sub	a10, a10, a2
ffe03fbd:	74a0a0        	extui	a10, a10, 0, 8
ffe03fc0:	401a00        	ssl	a10
ffe03fc3:	a1fe00        	sll	a15, a14
ffe03fc6:	0020c0        	memw
ffe03fc9:	ad2cb2        	l32i	a11, a12, 0x2b4
ffe03fcc:	20bbf0        	or	a11, a11, a15
ffe03fcf:	0020c0        	memw

    HAL_HCmdSataDone(tag);
ffe03fd2:	490c      	movi.n	a9, 4
    else
    {
        tag = 31 - tag;
    }
   
    rSDC_NCQCMD_CLR_TAG |= (1 << tag);
ffe03fd4:	ad6cb2        	s32i	a11, a12, 0x2b4

    HAL_HCmdSataDone(tag);
ffe03fd7:	f6a4b1        	l32r	a11, ffe01a68 <_bss_table_end+0xec>
ffe03fda:	a0aaa0        	addx4	a10, a10, a10
ffe03fdd:	a0aab0        	addx4	a10, a10, a11
ffe03fe0:	7f4a92        	s8i	a9, a10, 127
    {
        HAL_NCQCmdFinishISR();
#ifdef SIM
        rSDC_IntSrcPending &= ~BIT_SDC_INTSRC_NCQFINISH;
#else
        rSDC_IntSrcPending = BIT_SDC_INTSRC_NCQFINISH; //lily: no need to clr.
ffe03fe3:	0020c0        	memw
ffe03fe6:	ac6c62        	s32i	a6, a12, 0x2b0
ffe03fe9:	0e1c      	movi.n	a14, 16
#endif
    }

    if( uSDC_IntSrcPending & BIT_SDC_INTSRC_SOFTRESET )
ffe03feb:	0b6d47        	bbci	a13, 4, ffe03ffa <HAL_SATAIntEntry+0x1a6>
Others      :
Modify      :
****************************************************************************/
void HAL_SoftResetISR(void)
{
    HAL_SataInitialize();
ffe03fee:	ffc405        	call0	ffe03c30 <HAL_SataInitialize>
    HAL_SataSendGoodStatus();
ffe03ff1:	ffcf85        	call0	ffe03cec <HAL_SataSendGoodStatus>
    rSDC_IntSrcPending = BIT_SDC_INTSRC_SOFTRESET;
ffe03ff4:	0020c0        	memw
ffe03ff7:	ac6ce2        	s32i	a14, a12, 0x2b0
//#if defined(HOST_SATA) && defined(MCU0)
    HAL_SataISR();
//#endif
    return;
ffe03ffa:	21c8      	l32i.n	a12, a1, 8
ffe03ffc:	31d8      	l32i.n	a13, a1, 12
ffe03ffe:	41e8      	l32i.n	a14, a1, 16
ffe04000:	51f8      	l32i.n	a15, a1, 20
ffe04002:	1108      	l32i.n	a0, a1, 4
ffe04004:	20c112        	addi	a1, a1, 32
ffe04007:	f00d      	ret.n

ffe04009 <HAL_SATAIntEntry+0x1b5>:

    pNewCmd->ucCmdStatus = HCMD_STATE_RECEIVED;
    pNewCmd->ucCmdCode = ucCmdCode;
    pNewCmd->ucCmdTag = ucCmdTag;

    switch( ucCmdCode )
ffe04009:	472c      	movi.n	a7, 36
ffe0400b:	02a677        	bge	a6, a7, ffe04011 <HAL_SATAIntEntry+0x1bd>
ffe0400e:	ffc006        	j	ffe03f12 <HAL_SATAIntEntry+0xbe>
ffe04011:	022767        	blt	a7, a6, ffe04017 <HAL_SATAIntEntry+0x1c3>
ffe04014:	002e06        	j	ffe040d0 <HAL_SATAIntEntry+0x27c>
ffe04017:	dbc6b2        	addi	a11, a6, -37
ffe0401a:	efab56        	bnez	a11, ffe03f18 <HAL_SATAIntEntry+0xc4>
        HAL_SataSetTransferParam28(pNewCmd);
        break;

    case ATA_CMD_READ_DMA_EXT:
        pNewCmd->ucCmdType = HCMD_TYPE_DATA;
        pNewCmd->ucCmdProtocol = HCMD_PROTOCOL_DMA;
ffe0401d:	724a82        	s8i	a8, a10, 114
        pNewCmd->ucCmdRW = HCMD_WRITE;
        HAL_SataSetTransferParam28(pNewCmd);
        break;

    case ATA_CMD_READ_DMA_EXT:
        pNewCmd->ucCmdType = HCMD_TYPE_DATA;
ffe04020:	7c4af2        	s8i	a15, a10, 124
        pNewCmd->ucCmdProtocol = HCMD_PROTOCOL_DMA;
        pNewCmd->ucCmdRW = HCMD_READ;
ffe04023:	734ae2        	s8i	a14, a10, 115
        HAL_SataSetTransferParam48(pNewCmd);
ffe04026:	0129      	s32i.n	a2, a1, 0
ffe04028:	ffd9c5        	call0	ffe03dc8 <HAL_SataSetTransferParam48>
        break;
ffe0402b:	ffbd86        	j	ffe03f25 <HAL_SATAIntEntry+0xd1>

ffe0402e <HAL_SATAIntEntry+0x1da>:

    pNewCmd->ucCmdStatus = HCMD_STATE_RECEIVED;
    pNewCmd->ucCmdCode = ucCmdCode;
    pNewCmd->ucCmdTag = ucCmdTag;

    switch( ucCmdCode )
ffe0402e:	680c      	movi.n	a8, 6
ffe04030:	f6cc71        	l32r	a7, ffe01b60 <_bss_table_end+0x1e4>
ffe04033:	61a092        	movi	a9, 97
ffe04036:	472697        	blt	a6, a9, ffe04081 <HAL_SATAIntEntry+0x22d>
ffe04039:	02a967        	bge	a9, a6, ffe0403f <HAL_SATAIntEntry+0x1eb>
ffe0403c:	0028c6        	j	ffe040e3 <HAL_SATAIntEntry+0x28f>
        pNewCmd->ucCmdRW = HCMD_READ;
        HAL_SataSetTransferParamNCQ(pNewCmd);
        break;

    case ATA_CMD_WRITE_FPDMA_QUEUED:
        pNewCmd->ucCmdType = HCMD_TYPE_DATA;
ffe0403f:	7c4af2        	s8i	a15, a10, 124
        pNewCmd->ucCmdProtocol = HCMD_PROTOCOL_NCQ;
        pNewCmd->ucCmdRW = HCMD_WRITE;
ffe04042:	734af2        	s8i	a15, a10, 115
        HAL_SataSetTransferParamNCQ(pNewCmd);
        break;

    case ATA_CMD_WRITE_FPDMA_QUEUED:
        pNewCmd->ucCmdType = HCMD_TYPE_DATA;
        pNewCmd->ucCmdProtocol = HCMD_PROTOCOL_NCQ;
ffe04045:	724a82        	s8i	a8, a10, 114
****************************************************************************/
void HAL_SataSetTransferParamNCQ(HCMD* pHostCmd)
{
    U32 ulActualSecCount;

    ulActualSecCount = rSDC_SHRLCH_FEATURE16;
ffe04048:	0020c0        	memw
ffe0404b:	ed1742        	l16ui	a4, a7, 0x1da
    if(0 == ulActualSecCount)
    {
        ulActualSecCount = 65536;
    }

    pHostCmd->ulCmdLba = rSDC_SHRLCH_LBA48;
ffe0404e:	0020c0        	memw
ffe04051:	b52c62        	l32i	a6, a12, 0x2d4
ffe04054:	4c6562        	s32i	a6, a5, 0x130
    pHostCmd->ulCmdSectorCnt = ulActualSecCount;
ffe04057:	f6bb31        	l32r	a3, ffe01b44 <_bss_table_end+0x1c8>
ffe0405a:	0129      	s32i.n	a2, a1, 0
ffe0405c:	834340        	moveqz	a4, a3, a4
ffe0405f:	4e6542        	s32i	a4, a5, 0x138
    pHostCmd->ulCmdRemSector = ulActualSecCount;
ffe04062:	4f6542        	s32i	a4, a5, 0x13c
    case ATA_CMD_WRITE_FPDMA_QUEUED:
        pNewCmd->ucCmdType = HCMD_TYPE_DATA;
        pNewCmd->ucCmdProtocol = HCMD_PROTOCOL_NCQ;
        pNewCmd->ucCmdRW = HCMD_WRITE;
        HAL_SataSetTransferParamNCQ(pNewCmd);
        break;
ffe04065:	ffaf06        	j	ffe03f25 <HAL_SATAIntEntry+0xd1>

ffe04068 <HAL_SATAIntEntry+0x214>:
ffe04068:	d0c642        	addi	a4, a6, -48
ffe0406b:	ea9456        	bnez	a4, ffe03f18 <HAL_SATAIntEntry+0xc4>
    case ATA_CMD_WRITE_SECTOR:
    case ATA_CMD_WRITE_MULTIPLE:
        pNewCmd->ucCmdType = HCMD_TYPE_DATA;
        pNewCmd->ucCmdProtocol = HCMD_PROTOCOL_PIO;
        pNewCmd->ucCmdRW = HCMD_WRITE;
        HAL_SataSetTransferParam28(pNewCmd);
ffe0406e:	0129      	s32i.n	a2, a1, 0
        HAL_SataSetTransferParam28(pNewCmd);
        break;

    case ATA_CMD_WRITE_SECTOR:
    case ATA_CMD_WRITE_MULTIPLE:
        pNewCmd->ucCmdType = HCMD_TYPE_DATA;
ffe04070:	7c40f2        	s8i	a15, a0, 124
        pNewCmd->ucCmdProtocol = HCMD_PROTOCOL_PIO;
        pNewCmd->ucCmdRW = HCMD_WRITE;
ffe04073:	7340f2        	s8i	a15, a0, 115
        break;

    case ATA_CMD_WRITE_SECTOR:
    case ATA_CMD_WRITE_MULTIPLE:
        pNewCmd->ucCmdType = HCMD_TYPE_DATA;
        pNewCmd->ucCmdProtocol = HCMD_PROTOCOL_PIO;
ffe04076:	460c      	movi.n	a6, 4
ffe04078:	724062        	s8i	a6, a0, 114
        pNewCmd->ucCmdRW = HCMD_WRITE;
        HAL_SataSetTransferParam28(pNewCmd);
ffe0407b:	ffd6c5        	call0	ffe03de8 <HAL_SataSetTransferParam28>
        break;
ffe0407e:	ffa8c6        	j	ffe03f25 <HAL_SATAIntEntry+0xd1>

ffe04081 <HAL_SATAIntEntry+0x22d>:
ffe04081:	a0c692        	addi	a9, a6, -96
ffe04084:	e90956        	bnez	a9, ffe03f18 <HAL_SATAIntEntry+0xc4>
    pNewCmd->ucCmdTag = ucCmdTag;

    switch( ucCmdCode )
    {
    case ATA_CMD_READ_FPDMA_QUEUED:
        pNewCmd->ucCmdType = HCMD_TYPE_DATA;
ffe04087:	7c4af2        	s8i	a15, a10, 124
        pNewCmd->ucCmdProtocol = HCMD_PROTOCOL_NCQ;
        pNewCmd->ucCmdRW = HCMD_READ;
ffe0408a:	734ae2        	s8i	a14, a10, 115

    switch( ucCmdCode )
    {
    case ATA_CMD_READ_FPDMA_QUEUED:
        pNewCmd->ucCmdType = HCMD_TYPE_DATA;
        pNewCmd->ucCmdProtocol = HCMD_PROTOCOL_NCQ;
ffe0408d:	724a82        	s8i	a8, a10, 114
****************************************************************************/
void HAL_SataSetTransferParamNCQ(HCMD* pHostCmd)
{
    U32 ulActualSecCount;

    ulActualSecCount = rSDC_SHRLCH_FEATURE16;
ffe04090:	0020c0        	memw
ffe04093:	ed1742        	l16ui	a4, a7, 0x1da
    if(0 == ulActualSecCount)
    {
        ulActualSecCount = 65536;
    }

    pHostCmd->ulCmdLba = rSDC_SHRLCH_LBA48;
ffe04096:	0020c0        	memw
ffe04099:	b52c62        	l32i	a6, a12, 0x2d4
ffe0409c:	ffed06        	j	ffe04054 <HAL_SATAIntEntry+0x200>

ffe0409f <HAL_SATAIntEntry+0x24b>:

    pNewCmd->ucCmdStatus = HCMD_STATE_RECEIVED;
    pNewCmd->ucCmdCode = ucCmdCode;
    pNewCmd->ucCmdTag = ucCmdTag;

    switch( ucCmdCode )
ffe0409f:	c8a0a2        	movi	a10, 200
ffe040a2:	c0a6a0        	sub	a10, a6, a10
ffe040a5:	e6fa56        	bnez	a10, ffe03f18 <HAL_SATAIntEntry+0xc4>

    case ATA_CMD_READ_DMA:
        pNewCmd->ucCmdType = HCMD_TYPE_DATA;
        pNewCmd->ucCmdProtocol = HCMD_PROTOCOL_DMA;
        pNewCmd->ucCmdRW = HCMD_READ;
        HAL_SataSetTransferParam28(pNewCmd);
ffe040a8:	0129      	s32i.n	a2, a1, 0
        HAL_SataSetTransferParamNCQ(pNewCmd);
        break;

    case ATA_CMD_READ_DMA:
        pNewCmd->ucCmdType = HCMD_TYPE_DATA;
        pNewCmd->ucCmdProtocol = HCMD_PROTOCOL_DMA;
ffe040aa:	724082        	s8i	a8, a0, 114
        pNewCmd->ucCmdRW = HCMD_WRITE;
        HAL_SataSetTransferParamNCQ(pNewCmd);
        break;

    case ATA_CMD_READ_DMA:
        pNewCmd->ucCmdType = HCMD_TYPE_DATA;
ffe040ad:	7c40f2        	s8i	a15, a0, 124
        pNewCmd->ucCmdProtocol = HCMD_PROTOCOL_DMA;
        pNewCmd->ucCmdRW = HCMD_READ;
ffe040b0:	7340e2        	s8i	a14, a0, 115
        HAL_SataSetTransferParam28(pNewCmd);
ffe040b3:	ffd345        	call0	ffe03de8 <HAL_SataSetTransferParam28>
        break;
ffe040b6:	ff9ac6        	j	ffe03f25 <HAL_SATAIntEntry+0xd1>

ffe040b9 <HAL_SATAIntEntry+0x265>:
ffe040b9:	cbc632        	addi	a3, a6, -53
ffe040bc:	e58356        	bnez	a3, ffe03f18 <HAL_SATAIntEntry+0xc4>
        HAL_SataSetTransferParam48(pNewCmd);
        break;

    case ATA_CMD_WRITE_DMA_EXT:
        pNewCmd->ucCmdType = HCMD_TYPE_DATA;
        pNewCmd->ucCmdProtocol = HCMD_PROTOCOL_DMA;
ffe040bf:	724a82        	s8i	a8, a10, 114
        pNewCmd->ucCmdRW = HCMD_READ;
        HAL_SataSetTransferParam48(pNewCmd);
        break;

    case ATA_CMD_WRITE_DMA_EXT:
        pNewCmd->ucCmdType = HCMD_TYPE_DATA;
ffe040c2:	7c4af2        	s8i	a15, a10, 124
        pNewCmd->ucCmdProtocol = HCMD_PROTOCOL_DMA;
        pNewCmd->ucCmdRW = HCMD_WRITE;
ffe040c5:	734af2        	s8i	a15, a10, 115
        HAL_SataSetTransferParam48(pNewCmd);
ffe040c8:	0129      	s32i.n	a2, a1, 0
ffe040ca:	ffcfc5        	call0	ffe03dc8 <HAL_SataSetTransferParam48>
        break;
ffe040cd:	ff9506        	j	ffe03f25 <HAL_SATAIntEntry+0xd1>

ffe040d0 <HAL_SATAIntEntry+0x27c>:
    case ATA_CMD_READ_SECTOR_EXT:
    case ATA_CMD_READ_MULTIPLE_EXT:
        pNewCmd->ucCmdType = HCMD_TYPE_DATA;
        pNewCmd->ucCmdProtocol = HCMD_PROTOCOL_PIO;
        pNewCmd->ucCmdRW = HCMD_READ;
        HAL_SataSetTransferParam48(pNewCmd);
ffe040d0:	0129      	s32i.n	a2, a1, 0
        HAL_SataSetTransferParam28(pNewCmd);
        break;

    case ATA_CMD_READ_SECTOR_EXT:
    case ATA_CMD_READ_MULTIPLE_EXT:
        pNewCmd->ucCmdType = HCMD_TYPE_DATA;
ffe040d2:	7c40f2        	s8i	a15, a0, 124
        pNewCmd->ucCmdProtocol = HCMD_PROTOCOL_PIO;
        pNewCmd->ucCmdRW = HCMD_READ;
ffe040d5:	7340e2        	s8i	a14, a0, 115
        break;

    case ATA_CMD_READ_SECTOR_EXT:
    case ATA_CMD_READ_MULTIPLE_EXT:
        pNewCmd->ucCmdType = HCMD_TYPE_DATA;
        pNewCmd->ucCmdProtocol = HCMD_PROTOCOL_PIO;
ffe040d8:	460c      	movi.n	a6, 4
ffe040da:	724062        	s8i	a6, a0, 114
        pNewCmd->ucCmdRW = HCMD_READ;
        HAL_SataSetTransferParam48(pNewCmd);
ffe040dd:	ffce85        	call0	ffe03dc8 <HAL_SataSetTransferParam48>
        break;
ffe040e0:	ff9046        	j	ffe03f25 <HAL_SATAIntEntry+0xd1>

ffe040e3 <HAL_SATAIntEntry+0x28f>:

    pNewCmd->ucCmdStatus = HCMD_STATE_RECEIVED;
    pNewCmd->ucCmdCode = ucCmdCode;
    pNewCmd->ucCmdTag = ucCmdTag;

    switch( ucCmdCode )
ffe040e3:	c4a072        	movi	a7, 196
ffe040e6:	c07670        	sub	a7, a6, a7
ffe040e9:	e2b756        	bnez	a7, ffe03f18 <HAL_SATAIntEntry+0xc4>
    case ATA_CMD_READ_SECTOR:
    case ATA_CMD_READ_MULTIPLE:
        pNewCmd->ucCmdType = HCMD_TYPE_DATA;
        pNewCmd->ucCmdProtocol = HCMD_PROTOCOL_PIO;
        pNewCmd->ucCmdRW = HCMD_READ;
        HAL_SataSetTransferParam28(pNewCmd);
ffe040ec:	0129      	s32i.n	a2, a1, 0
        HAL_SataSetTransferParam48(pNewCmd);
        break;

    case ATA_CMD_READ_SECTOR:
    case ATA_CMD_READ_MULTIPLE:
        pNewCmd->ucCmdType = HCMD_TYPE_DATA;
ffe040ee:	7c40f2        	s8i	a15, a0, 124
        pNewCmd->ucCmdProtocol = HCMD_PROTOCOL_PIO;
        pNewCmd->ucCmdRW = HCMD_READ;
ffe040f1:	7340e2        	s8i	a14, a0, 115
        break;

    case ATA_CMD_READ_SECTOR:
    case ATA_CMD_READ_MULTIPLE:
        pNewCmd->ucCmdType = HCMD_TYPE_DATA;
        pNewCmd->ucCmdProtocol = HCMD_PROTOCOL_PIO;
ffe040f4:	490c      	movi.n	a9, 4
ffe040f6:	724092        	s8i	a9, a0, 114
        pNewCmd->ucCmdRW = HCMD_READ;
        HAL_SataSetTransferParam28(pNewCmd);
ffe040f9:	ffcec5        	call0	ffe03de8 <HAL_SataSetTransferParam28>
        break;
ffe040fc:	ff8946        	j	ffe03f25 <HAL_SATAIntEntry+0xd1>

ffe040ff <HAL_SATAIntEntry+0x2ab>:
	...

ffe04100 <HAL_L4TimerIntEntry>:
Modify History:
    20140905    Victor Zhang Create
------------------------------------------------------------------------------*/
void HAL_L4TimerIntEntry(void)
{
    return;
ffe04100:	f00d      	ret.n

ffe04102 <HAL_L4TimerIntEntry+0x2>:
	...

ffe04104 <HAL_UserExcpEntry>:
    20141028    Gavin   add "INLINE" attribute
------------------------------------------------------------------------------*/
INLINE U32 HAL_GetMCUExcCause(void)
{
#ifndef SIM
    return XT_RSR_EXCCAUSE();
ffe04104:	03e830        	rsr.exccause	a3
{
    U32 ulExcCause;

    ulExcCause = HAL_GetMCUExcCause();

    switch (ulExcCause)
ffe04107:	254326        	beqi	a3, 4, ffe04130 <HAL_UserExcpEntry+0x2c>
INLINE void HAL_SaveMCUExcCause(U32 ulExcCause)
{
#ifndef SIM
    U32 ulEPC1;

    asm ( "rsr.epc1 %0\n\t \
ffe0410a:	f69f41        	l32r	a4, ffe01b88 <_bss_table_end+0x20c>
ffe0410d:	03b120        	rsr.epc1	a2
ffe04110:	0439      	s32i.n	a3, a4, 0
ffe04112:	1429      	s32i.n	a2, a4, 4
ffe04114:	007400        	waiti	4
            /* Just records exception cause and source instruction address at the start of OTFB and hangs. */
            HAL_SaveMCUExcCause(ulExcCause);
            break;
    }

    return;
ffe04117:	f00d      	ret.n

ffe04119 <HAL_UserExcpEntry+0x15>:
    if (rHostIntSrcReg & BIT_HR_INT)
    {
        rHostIntSrcReg = BIT_HR_INT;
        rAHCI_GHC |= 1;
    }
    else if (rHostIntSrcReg & BIT_MP_INT)
ffe04119:	0020c0        	memw
ffe0411c:	4368      	l32i.n	a6, a3, 16
ffe0411e:	0c6687        	bbci	a6, 8, ffe0412e <HAL_UserExcpEntry+0x2a>
    {
        rHostIntSrcReg = BIT_MP_INT;
ffe04121:	0020c0        	memw
ffe04124:	4359      	s32i.n	a5, a3, 16
        l_ulRevMpInt = TRUE;
ffe04126:	f61771        	l32r	a7, ffe01984 <_bss_table_end+0x8>
ffe04129:	0020c0        	memw
ffe0412c:	3749      	s32i.n	a4, a7, 12
ffe0412e:	f00d      	ret.n

ffe04130 <HAL_UserExcpEntry+0x2c>:
    20141028    Gavin   add "INLINE" attribute
------------------------------------------------------------------------------*/
INLINE U32 HAL_GetMCUIntSrc(void)
{
#ifndef SIM
    return XT_RSR_INTERRUPT();
ffe04130:	03e280        	rsr.interrupt	a8
    U32 ulIntSrc = HAL_GetMCUIntSrc();

    /* MCU0 uses an inter-processor interrupt to wake a subsystem up
     since the subsystem MCU would sleep in WAITI state when it 
     completes one stage of IDLE task. */
    if (ulIntSrc & BIT_ORINT_HOSTC)
ffe04133:	f768e7        	bbci	a8, 14, ffe0412e <HAL_UserExcpEntry+0x2a>
    {   
        HAL_HostCIntEntry();
ffe04136:	f68361        	l32r	a6, ffe01b44 <_bss_table_end+0x1c8>
ffe04139:	140c      	movi.n	a4, 1
ffe0413b:	f64f31        	l32r	a3, ffe01a78 <_bss_table_end+0xfc>
}


void HAL_HostCIntEntry(void)
{
    if (rHostIntSrcReg & BIT_HR_INT)
ffe0413e:	0020c0        	memw
ffe04141:	4398      	l32i.n	a9, a3, 16
    {
        rHostIntSrcReg = BIT_HR_INT;
        rAHCI_GHC |= 1;
ffe04143:	00a152        	movi	a5, 0x100
}


void HAL_HostCIntEntry(void)
{
    if (rHostIntSrcReg & BIT_HR_INT)
ffe04146:	cf7907        	bbci	a9, 16, ffe04119 <HAL_UserExcpEntry+0x15>
    {
        rHostIntSrcReg = BIT_HR_INT;
ffe04149:	f683b1        	l32r	a11, ffe01b58 <_bss_table_end+0x1dc>
ffe0414c:	0020c0        	memw
ffe0414f:	4369      	s32i.n	a6, a3, 16
        rAHCI_GHC |= 1;
ffe04151:	0020c0        	memw
ffe04154:	412ba2        	l32i	a10, a11, 0x104
ffe04157:	20aa40        	or	a10, a10, a4
ffe0415a:	0020c0        	memw
ffe0415d:	416ba2        	s32i	a10, a11, 0x104
            /* Just records exception cause and source instruction address at the start of OTFB and hangs. */
            HAL_SaveMCUExcCause(ulExcCause);
            break;
    }

    return;
ffe04160:	f00d      	ret.n

ffe04162 <HAL_UserExcpEntry+0x5e>:
	...

ffe04164 <TEST_FuncReturn>:
    FOR test
*************************************************/

void TEST_FuncReturn(void)
{
    DBG_Printf("TEST FUNCTION RETURE \n");
ffe04164:	f68a21        	l32r	a2, ffe01b8c <_bss_table_end+0x210>
Description:
    FOR test
*************************************************/

void TEST_FuncReturn(void)
{
ffe04167:	f0c112        	addi	a1, a1, -16
ffe0416a:	0109      	s32i.n	a0, a1, 0
    DBG_Printf("TEST FUNCTION RETURE \n");
ffe0416c:	00d505        	call0	ffe04ec0 <dbg_printf>
    return;
ffe0416f:	0108      	l32i.n	a0, a1, 0
ffe04171:	10c112        	addi	a1, a1, 16
ffe04174:	f00d      	ret.n

ffe04176 <TEST_FuncReturn+0x12>:
	...

ffe04178 <HalNfcGetPuErr..M_1429880325>:
    Get the error bit value from access DPTR (CQ REG)
*************************************************/

LOCAL BOOL  HalNfcGetPuErr(U8 Pu)
{
    return (BOOL)pNFCQDptr->CQ_REG[Pu].bsErrh;
ffe04178:	f60331        	l32r	a3, ffe01984 <_bss_table_end+0x8>
ffe0417b:	4338      	l32i.n	a3, a3, 16
ffe0417d:	a02230        	addx4	a2, a2, a3
ffe04180:	0020c0        	memw
ffe04183:	000222        	l8ui	a2, a2, 0
ffe04186:	042120        	extui	a2, a2, 1, 1
ffe04189:	f00d      	ret.n

ffe0418b <HalNfcGetPuErr..M_1429880325+0x13>:
	...

ffe0418c <HalNfcSinglePuStatus..O_1429880325>:
Description:
    Waiting until idle bit be set,then return the error bit value
*************************************************/

LOCAL BOOL HalNfcSinglePuStatus(U8 Pu)
{
ffe0418c:	742020        	extui	a2, a2, 0, 8
ffe0418f:	f0c112        	addi	a1, a1, -16
ffe04192:	f5fc41        	l32r	a4, ffe01984 <_bss_table_end+0x8>
ffe04195:	1109      	s32i.n	a0, a1, 4
ffe04197:	4458      	l32i.n	a5, a4, 16
ffe04199:	1102e0        	slli	a0, a2, 2
ffe0419c:	a05250        	addx4	a5, a2, a5

ffe0419f <HalNfcSinglePuStatus..O_1429880325+0x13>:
    while (TRUE != HalNfcGetPuIdle(Pu))
ffe0419f:	0020c0        	memw
ffe041a2:	000562        	l8ui	a6, a5, 0
ffe041a5:	f66607        	bbci	a6, 0, ffe0419f <HalNfcSinglePuStatus..O_1429880325+0x13>
                Function define
*************************************************/
LOCAL  void cdcDelay(void)
{
    U32 i;
    i = 200;
ffe041a8:	c8a042        	movi	a4, 200
ffe041ab:	0109      	s32i.n	a0, a1, 0
ffe041ad:	000046        	j	ffe041b2 <HalNfcSinglePuStatus..O_1429880325+0x26>

ffe041b0 <HalNfcSinglePuStatus..O_1429880325+0x24>:
    while(i--){
        __asm__("nop");
ffe041b0:	f03d      	nop.n
*************************************************/
LOCAL  void cdcDelay(void)
{
    U32 i;
    i = 200;
    while(i--){
ffe041b2:	440b      	addi.n	a4, a4, -1
ffe041b4:	f80466        	bnei	a4, -1, ffe041b0 <HalNfcSinglePuStatus..O_1429880325+0x24>
    {
        ;
    }
    cdcDelay();

    if (TRUE == HalNfcGetPuErr(Pu))
ffe041b7:	fffc05        	call0	ffe04178 <HalNfcGetPuErr..M_1429880325>
ffe041ba:	241266        	bnei	a2, 1, ffe041e2 <HalNfcSinglePuStatus..O_1429880325+0x56>
    }
}

LOCAL void HalNfcResetCmd(U8 Pu)
{
    pNFCQDptr->CQ_REG[Pu].bsRq0Pset = 1;
ffe041bd:	094c      	movi.n	a9, 64
ffe041bf:	f5f181        	l32r	a8, ffe01984 <_bss_table_end+0x8>
ffe041c2:	01b8      	l32i.n	a11, a1, 0
ffe041c4:	4888      	l32i.n	a8, a8, 16
ffe041c6:	bfa0a2        	movi	a10, 191
ffe041c9:	88ba      	add.n	a8, a8, a11
ffe041cb:	0020c0        	memw
ffe041ce:	010872        	l8ui	a7, a8, 1
ffe041d1:	1077a0        	and	a7, a7, a10
ffe041d4:	207790        	or	a7, a7, a9
ffe041d7:	0020c0        	memw
ffe041da:	014872        	s8i	a7, a8, 1
    cdcDelay();

    if (TRUE == HalNfcGetPuErr(Pu))
    {
        HalNfcResetCmd(Pu);
        return FAIL;
ffe041dd:	020c      	movi.n	a2, 0
    {
        ;
    }
    cdcDelay();

    if (TRUE == HalNfcGetPuErr(Pu))
ffe041df:	000046        	j	ffe041e4 <HalNfcSinglePuStatus..O_1429880325+0x58>

ffe041e2 <HalNfcSinglePuStatus..O_1429880325+0x56>:
        HalNfcResetCmd(Pu);
        return FAIL;
    }
    else
    {
        return SUCCESS;
ffe041e2:	120c      	movi.n	a2, 1
ffe041e4:	1108      	l32i.n	a0, a1, 4
ffe041e6:	10c112        	addi	a1, a1, 16
ffe041e9:	f00d      	ret.n

ffe041eb <HalNfcSinglePuStatus..O_1429880325+0x5f>:
	...

ffe041ec <HalSetTrigger..EB_1429880325>:
    so here a structurt , tTrigger , be called as a buffer to solve the issue.
    
*************************************************/

LOCAL void HalSetTrigger(U8 CmdIndex,U8 Pu,U8 ucCeSel)
{
ffe041ec:	f5e661        	l32r	a6, ffe01984 <_bss_table_end+0x8>
ffe041ef:	f0c112        	addi	a1, a1, -16
ffe041f2:	1109      	s32i.n	a0, a1, 4
ffe041f4:	4658      	l32i.n	a5, a6, 16
ffe041f6:	a05350        	addx4	a5, a3, a5
ffe041f9:	0020c0        	memw
    tTrig.bsValue = 0;
    tTrig.bsCmdType = l_aRCMD_TABLE[CmdIndex].TrigType;
#ifndef VT3514_C0
    tTrig.bsTrig = TRUE;
#else
    tTrig.bsCESel = ucCeSel;
ffe041fc:	fea0a2        	movi	a10, 254
    so here a structurt , tTrigger , be called as a buffer to solve the issue.
    
*************************************************/

LOCAL void HalSetTrigger(U8 CmdIndex,U8 Pu,U8 ucCeSel)
{
ffe041ff:	000552        	l8ui	a5, a5, 0
    volatile NFC_TRIGGER_REG *pTrig = HalGetTriggerEntry(Pu);
    NFC_TRIGGER_REG tTrig;
    tTrig.bsValue = 0;
    tTrig.bsCmdType = l_aRCMD_TABLE[CmdIndex].TrigType;
ffe04202:	b08260        	addx8	a8, a2, a6

LOCAL void HalSetTrigger(U8 CmdIndex,U8 Pu,U8 ucCeSel)
{
    volatile NFC_TRIGGER_REG *pTrig = HalGetTriggerEntry(Pu);
    NFC_TRIGGER_REG tTrig;
    tTrig.bsValue = 0;
ffe04205:	0b0c      	movi.n	a11, 0
#ifndef VT3514_C0
    tTrig.bsTrig = TRUE;
#else
    tTrig.bsCESel = ucCeSel;
#endif  
    pTrig->bsValue = tTrig.bsValue;
ffe04207:	8668      	l32i.n	a6, a6, 32
LOCAL void HalSetTrigger(U8 CmdIndex,U8 Pu,U8 ucCeSel)
{
    volatile NFC_TRIGGER_REG *pTrig = HalGetTriggerEntry(Pu);
    NFC_TRIGGER_REG tTrig;
    tTrig.bsValue = 0;
    tTrig.bsCmdType = l_aRCMD_TABLE[CmdIndex].TrigType;
ffe04209:	402882        	l32i	a8, a8, 0x100

LOCAL void HalSetTrigger(U8 CmdIndex,U8 Pu,U8 ucCeSel)
{
    volatile NFC_TRIGGER_REG *pTrig = HalGetTriggerEntry(Pu);
    NFC_TRIGGER_REG tTrig;
    tTrig.bsValue = 0;
ffe0420c:	0051b2        	s16i	a11, a1, 0
    so here a structurt , tTrigger , be called as a buffer to solve the issue.
    
*************************************************/

LOCAL void HalSetTrigger(U8 CmdIndex,U8 Pu,U8 ucCeSel)
{
ffe0420f:	415650        	srli	a5, a5, 6
    tTrig.bsValue = 0;
    tTrig.bsCmdType = l_aRCMD_TABLE[CmdIndex].TrigType;
#ifndef VT3514_C0
    tTrig.bsTrig = TRUE;
#else
    tTrig.bsCESel = ucCeSel;
ffe04212:	010192        	l8ui	a9, a1, 1
LOCAL void HalSetTrigger(U8 CmdIndex,U8 Pu,U8 ucCeSel)
{
    volatile NFC_TRIGGER_REG *pTrig = HalGetTriggerEntry(Pu);
    NFC_TRIGGER_REG tTrig;
    tTrig.bsValue = 0;
    tTrig.bsCmdType = l_aRCMD_TABLE[CmdIndex].TrigType;
ffe04215:	000172        	l8ui	a7, a1, 0
#ifndef VT3514_C0
    tTrig.bsTrig = TRUE;
#else
    tTrig.bsCESel = ucCeSel;
ffe04218:	1099a0        	and	a9, a9, a10
LOCAL void HalSetTrigger(U8 CmdIndex,U8 Pu,U8 ucCeSel)
{
    volatile NFC_TRIGGER_REG *pTrig = HalGetTriggerEntry(Pu);
    NFC_TRIGGER_REG tTrig;
    tTrig.bsValue = 0;
    tTrig.bsCmdType = l_aRCMD_TABLE[CmdIndex].TrigType;
ffe0421b:	e58180        	extui	a8, a8, 17, 15
#ifndef VT3514_C0
    tTrig.bsTrig = TRUE;
#else
    tTrig.bsCESel = ucCeSel;
ffe0421e:	04a040        	extui	a10, a4, 0, 1
ffe04221:	2099a0        	or	a9, a9, a10
ffe04224:	014192        	s8i	a9, a1, 1
LOCAL void HalSetTrigger(U8 CmdIndex,U8 Pu,U8 ucCeSel)
{
    volatile NFC_TRIGGER_REG *pTrig = HalGetTriggerEntry(Pu);
    NFC_TRIGGER_REG tTrig;
    tTrig.bsValue = 0;
    tTrig.bsCmdType = l_aRCMD_TABLE[CmdIndex].TrigType;
ffe04227:	fca092        	movi	a9, 252
ffe0422a:	107790        	and	a7, a7, a9
ffe0422d:	010874        	insbits	a7, a8, 0, 1
ffe04230:	004172        	s8i	a7, a1, 0
#ifndef VT3514_C0
    tTrig.bsTrig = TRUE;
#else
    tTrig.bsCESel = ucCeSel;
#endif  
    pTrig->bsValue = tTrig.bsValue;
ffe04233:	a05350        	addx4	a5, a3, a5
ffe04236:	905560        	addx2	a5, a5, a6
ffe04239:	001102        	l16ui	a0, a1, 0
ffe0423c:	0020c0        	memw
    HAL_DelayCycle(5);
ffe0423f:	520c      	movi.n	a2, 5
#ifndef VT3514_C0
    tTrig.bsTrig = TRUE;
#else
    tTrig.bsCESel = ucCeSel;
#endif  
    pTrig->bsValue = tTrig.bsValue;
ffe04241:	005502        	s16i	a0, a5, 0
    HAL_DelayCycle(5);
ffe04244:	00ba45        	call0	ffe04dec <HAL_DelayCycle>
}
ffe04247:	1108      	l32i.n	a0, a1, 4
ffe04249:	10c112        	addi	a1, a1, 16
ffe0424c:	f00d      	ret.n

ffe0424e <HalSetTrigger..EB_1429880325+0x62>:
	...

ffe04250 <HalSetPrcq..CB_1429880325>:
Description:
    Set the prcq entry of target PU as prcq table  
*************************************************/

LOCAL void HalSetPrcq(U8 CmdIndex,U8 Pu)
{
ffe04250:	f5cd71        	l32r	a7, ffe01984 <_bss_table_end+0x8>
    U32 i,j,ulQePhase;
    U8 ucBuf[4] = {0};
ffe04253:	f64f61        	l32r	a6, ffe01b90 <_bss_table_end+0x214>
Description:
    Set the prcq entry of target PU as prcq table  
*************************************************/

LOCAL void HalSetPrcq(U8 CmdIndex,U8 Pu)
{
ffe04256:	f0c112        	addi	a1, a1, -16
ffe04259:	1109      	s32i.n	a0, a1, 4
    U32 i,j,ulQePhase;
    U8 ucBuf[4] = {0};
ffe0425b:	0668      	l32i.n	a6, a6, 0
ffe0425d:	0169      	s32i.n	a6, a1, 0
    return the available PRCQ entry of target PU
*************************************************/

LOCAL PRCQ_ENTRY* HalNfcGetPrcqEntry(U8 Pu)
{
    U8 Wp = HalNfcGetWp(Pu);
ffe0425f:	4758      	l32i.n	a5, a7, 16
ffe04261:	a05350        	addx4	a5, a3, a5
ffe04264:	0020c0        	memw
    U32 i,j,ulQePhase;
    U8 ucBuf[4] = {0};
    U8* pPrcqBuf = (U8*)l_aRCMD_TABLE[CmdIndex].QEPtr;
    volatile PRCQ_ENTRY* pPrcqEntry = HalNfcGetPrcqEntry(Pu);

    if ( (TRUE == HAL_StrapIsSetHwFrEfuse()) 
ffe04267:	d748      	l32i.n	a4, a7, 52
    return the available PRCQ entry of target PU
*************************************************/

LOCAL PRCQ_ENTRY* HalNfcGetPrcqEntry(U8 Pu)
{
    U8 Wp = HalNfcGetWp(Pu);
ffe04269:	000552        	l8ui	a5, a5, 0
LOCAL void HalSetPrcq(U8 CmdIndex,U8 Pu)
{
    U32 i,j,ulQePhase;
    U8 ucBuf[4] = {0};
    U8* pPrcqBuf = (U8*)l_aRCMD_TABLE[CmdIndex].QEPtr;
    volatile PRCQ_ENTRY* pPrcqEntry = HalNfcGetPrcqEntry(Pu);
ffe0426c:	7708      	l32i.n	a0, a7, 28
    return the available PRCQ entry of target PU
*************************************************/

LOCAL PRCQ_ENTRY* HalNfcGetPrcqEntry(U8 Pu)
{
    U8 Wp = HalNfcGetWp(Pu);
ffe0426e:	415650        	srli	a5, a5, 6
LOCAL void HalSetPrcq(U8 CmdIndex,U8 Pu)
{
    U32 i,j,ulQePhase;
    U8 ucBuf[4] = {0};
    U8* pPrcqBuf = (U8*)l_aRCMD_TABLE[CmdIndex].QEPtr;
    volatile PRCQ_ENTRY* pPrcqEntry = HalNfcGetPrcqEntry(Pu);
ffe04271:	a05350        	addx4	a5, a3, a5
ffe04274:	1155a0        	slli	a5, a5, 6
ffe04277:	005a      	add.n	a0, a0, a5

    if ( (TRUE == HAL_StrapIsSetHwFrEfuse()) 
ffe04279:	291466        	bnei	a4, 1, ffe042a6 <HalSetPrcq..CB_1429880325+0x56>
ffe0427c:	263266        	bnei	a2, 3, ffe042a6 <HalSetPrcq..CB_1429880325+0x56>
ffe0427f:	2109      	s32i.n	a0, a1, 8
ffe04281:	212266        	bnei	a2, 2, ffe042a6 <HalSetPrcq..CB_1429880325+0x56>
ffe04284:	012d      	mov.n	a2, a1
       &&(CmdIndex == NF_RCMD_READ_SLC_1PLN) 
       &&(CmdIndex == NF_RCMD_READ_MLC_1PLN))
    {
        
        ulQePhase = HAL_StrapGetReadPRCQ((U8*)&ucBuf);
ffe04286:	ff4785        	call0	ffe03700 <HAL_StrapGetReadPRCQ>
ffe04289:	2108      	l32i.n	a0, a1, 8

        for (i=0;i<ulQePhase;i++)
ffe0428b:	041216        	beqz	a2, ffe042d0 <HalSetPrcq..CB_1429880325+0x80>
ffe0428e:	003d      	mov.n	a3, a0
ffe04290:	015d      	mov.n	a5, a1
ffe04292:	0ca276        	loopgtz	a2, ffe042a2 <HalSetPrcq..CB_1429880325+0x52>
        {
            pPrcqEntry->Entry[i] = ucBuf[i];
ffe04295:	000572        	l8ui	a7, a5, 0
ffe04298:	0020c0        	memw
ffe0429b:	004372        	s8i	a7, a3, 0
       &&(CmdIndex == NF_RCMD_READ_MLC_1PLN))
    {
        
        ulQePhase = HAL_StrapGetReadPRCQ((U8*)&ucBuf);

        for (i=0;i<ulQePhase;i++)
ffe0429e:	551b      	addi.n	a5, a5, 1
ffe042a0:	331b      	addi.n	a3, a3, 1

ffe042a2 <HalSetPrcq..CB_1429880325+0x52>:
ffe042a2:	000b06        	j	ffe042d2 <HalSetPrcq..CB_1429880325+0x82>

ffe042a5 <HalSetPrcq..CB_1429880325+0x55>:
	...

ffe042a6 <HalSetPrcq..CB_1429880325+0x56>:

    }
    else
    {      
        ulQePhase = l_aRCMD_TABLE[CmdIndex].QEPhase;
        for (i=0;i<ulQePhase;i++)
ffe042a6:	f63b41        	l32r	a4, ffe01b94 <_bss_table_end+0x218>
ffe042a9:	1132d0        	slli	a3, a2, 3
ffe042ac:	334a      	add.n	a3, a3, a4
ffe042ae:	7d0332        	l8ui	a3, a3, 125
ffe042b1:	b02270        	addx8	a2, a2, a7
ffe042b4:	139c      	beqz.n	a3, ffe042c9 <HalSetPrcq..CB_1429880325+0x79>
ffe042b6:	412222        	l32i	a2, a2, 0x104
ffe042b9:	0c9376        	loopnez	a3, ffe042c9 <HalSetPrcq..CB_1429880325+0x79>
        {
            pPrcqEntry->Entry[i] = pPrcqBuf[i];
ffe042bc:	000232        	l8ui	a3, a2, 0
ffe042bf:	0020c0        	memw
ffe042c2:	004032        	s8i	a3, a0, 0

    }
    else
    {      
        ulQePhase = l_aRCMD_TABLE[CmdIndex].QEPhase;
        for (i=0;i<ulQePhase;i++)
ffe042c5:	221b      	addi.n	a2, a2, 1
ffe042c7:	001b      	addi.n	a0, a0, 1

ffe042c9 <HalSetPrcq..CB_1429880325+0x79>:
        {
            pPrcqEntry->Entry[i] = pPrcqBuf[i];
        }
    }
    return;
ffe042c9:	1108      	l32i.n	a0, a1, 4
ffe042cb:	10c112        	addi	a1, a1, 16
ffe042ce:	f00d      	ret.n

ffe042d0 <HalSetPrcq..CB_1429880325+0x80>:
       &&(CmdIndex == NF_RCMD_READ_MLC_1PLN))
    {
        
        ulQePhase = HAL_StrapGetReadPRCQ((U8*)&ucBuf);

        for (i=0;i<ulQePhase;i++)
ffe042d0:	020c      	movi.n	a2, 0
        {
            pPrcqEntry->Entry[i] = ucBuf[i];
        }  

        for (j=0;j<sizeof(ReadDataOut);i++,j++)
ffe042d2:	302a      	add.n	a3, a0, a2
ffe042d4:	440c      	movi.n	a4, 4
ffe042d6:	f63001        	l32r	a0, ffe01b98 <_bss_table_end+0x21c>
ffe042d9:	0ca476        	loopgtz	a4, ffe042e9 <HalSetPrcq..CB_1429880325+0x99>
        {
            pPrcqEntry->Entry[i] = ReadDataOut[j];
ffe042dc:	800052        	l8ui	a5, a0, 128
ffe042df:	0020c0        	memw
ffe042e2:	004352        	s8i	a5, a3, 0
        for (i=0;i<ulQePhase;i++)
        {
            pPrcqEntry->Entry[i] = ucBuf[i];
        }  

        for (j=0;j<sizeof(ReadDataOut);i++,j++)
ffe042e5:	001b      	addi.n	a0, a0, 1
ffe042e7:	331b      	addi.n	a3, a3, 1

ffe042e9 <HalSetPrcq..CB_1429880325+0x99>:
ffe042e9:	fff706        	j	ffe042c9 <HalSetPrcq..CB_1429880325+0x79>

ffe042ec <HAL_NfcGetCeSel>:
    }
}

U8 HAL_NfcGetCeSel(U8 ucLogPu)
{
    if (TRUE == HAL_StrapNfcIs16CeMode())
ffe042ec:	f5a631        	l32r	a3, ffe01984 <_bss_table_end+0x8>
ffe042ef:	0020c0        	memw
ffe042f2:	e338      	l32i.n	a3, a3, 56
    {
        return ucLogPu & 0x1;
ffe042f4:	042020        	extui	a2, a2, 0, 1
    }
}

U8 HAL_NfcGetCeSel(U8 ucLogPu)
{
    if (TRUE == HAL_StrapNfcIs16CeMode())
ffe042f7:	016397        	bbci	a3, 9, ffe042fc <HAL_NfcGetCeSel+0x10>
    {
        return ucLogPu & 0x1;
    }
    else
    {
        return 0;
ffe042fa:	f00d      	ret.n

ffe042fc <HAL_NfcGetCeSel+0x10>:
ffe042fc:	020c      	movi.n	a2, 0
ffe042fe:	f00d      	ret.n

ffe04300 <HAL_NfcGetPhyPu>:
/*

*/
U8 HAL_NfcGetPhyPu(U8 ucLogPu)
{
    if (TRUE == HAL_StrapNfcIs16CeMode())
ffe04300:	f5a131        	l32r	a3, ffe01984 <_bss_table_end+0x8>
ffe04303:	0020c0        	memw
ffe04306:	e338      	l32i.n	a3, a3, 56
ffe04308:	046397        	bbci	a3, 9, ffe04310 <HAL_NfcGetPhyPu+0x10>
    {
        return ucLogPu >> 1;
ffe0430b:	412120        	srli	a2, a2, 1
    }
    else
    {
        return ucLogPu;
ffe0430e:	f00d      	ret.n

ffe04310 <HAL_NfcGetPhyPu+0x10>:
ffe04310:	f00d      	ret.n

ffe04312 <HAL_NfcGetPhyPu+0x12>:
	...

ffe04314 <HAL_NfcReadId>:
Output:  Status
Description:
    Read
*************************************************/
GLOBAL BOOL HAL_NfcReadId(U8 ucLogPu)
{
ffe04314:	e0c112        	addi	a1, a1, -32
ffe04317:	31d9      	s32i.n	a13, a1, 12
ffe04319:	41e9      	s32i.n	a14, a1, 16
ffe0431b:	51f9      	s32i.n	a15, a1, 20
ffe0431d:	21c9      	s32i.n	a12, a1, 8
ffe0431f:	1109      	s32i.n	a0, a1, 4
ffe04321:	02cd      	mov.n	a12, a2
    NFCQ_ENTRY *pNFCQEntry;
    BOOL bRet;

    U8 ucPhyPu = HAL_NfcGetPhyPu(ucLogPu);
ffe04323:	fffdc5        	call0	ffe04300 <HAL_NfcGetPhyPu>
ffe04326:	02dd      	mov.n	a13, a2
    U8 ucCeSel = HAL_NfcGetCeSel(ucLogPu);
ffe04328:	0c2d      	mov.n	a2, a12
ffe0432a:	fffc05        	call0	ffe042ec <HAL_NfcGetCeSel>
ffe0432d:	f595f1        	l32r	a15, ffe01984 <_bss_table_end+0x8>
ffe04330:	020d      	mov.n	a0, a2
ffe04332:	4f28      	l32i.n	a2, a15, 16
ffe04334:	11ede0        	slli	a14, a13, 2
ffe04337:	a02d20        	addx4	a2, a13, a2

ffe0433a <HAL_NfcReadId+0x26>:

    while (FALSE == HalNfcGetPuEmpty(ucPhyPu))
ffe0433a:	0020c0        	memw
ffe0433d:	000232        	l8ui	a3, a2, 0
ffe04340:	f66327        	bbci	a3, 2, ffe0433a <HAL_NfcReadId+0x26>
ffe04343:	f5e231        	l32r	a3, ffe01acc <_bss_table_end+0x150>
ffe04346:	070c      	movi.n	a7, 0
ffe04348:	0020c0        	memw
ffe0434b:	000242        	l8ui	a4, a2, 0
    {
        ;
    }

    if (TRUE == HalNfcGetPuFull(ucPhyPu))
ffe0434e:	256437        	bbci	a4, 3, ffe04377 <HAL_NfcReadId+0x63>
    {
        // FPGA only
        l_aFlashId[ucLogPu].ID[0] = 0;
ffe04351:	1358      	l32i.n	a5, a3, 4
        l_aFlashId[ucLogPu].ID[1] = 0;
        DBG_Printf("PU #%d Read ID: %x %x \n",ucLogPu,l_aFlashId[ucLogPu].ID[0],l_aFlashId[ucLogPu].ID[1]);
ffe04353:	0c3d      	mov.n	a3, a12
    }

    if (TRUE == HalNfcGetPuFull(ucPhyPu))
    {
        // FPGA only
        l_aFlashId[ucLogPu].ID[0] = 0;
ffe04355:	b05c50        	addx8	a5, a12, a5
ffe04358:	0020c0        	memw
ffe0435b:	0579      	s32i.n	a7, a5, 0
        l_aFlashId[ucLogPu].ID[1] = 0;
ffe0435d:	0020c0        	memw
ffe04360:	1579      	s32i.n	a7, a5, 4
        DBG_Printf("PU #%d Read ID: %x %x \n",ucLogPu,l_aFlashId[ucLogPu].ID[0],l_aFlashId[ucLogPu].ID[1]);
ffe04362:	f60e21        	l32r	a2, ffe01b9c <_bss_table_end+0x220>
ffe04365:	0020c0        	memw
ffe04368:	0548      	l32i.n	a4, a5, 0
ffe0436a:	0020c0        	memw
ffe0436d:	1558      	l32i.n	a5, a5, 4
ffe0436f:	00b505        	call0	ffe04ec0 <dbg_printf>
        return FAIL;
ffe04372:	020c      	movi.n	a2, 0
    if (TRUE == HalNfcGetPuFull(ucPhyPu))
    {
        // FPGA only
        l_aFlashId[ucLogPu].ID[0] = 0;
        l_aFlashId[ucLogPu].ID[1] = 0;
        DBG_Printf("PU #%d Read ID: %x %x \n",ucLogPu,l_aFlashId[ucLogPu].ID[0],l_aFlashId[ucLogPu].ID[1]);
ffe04374:	002a46        	j	ffe04421 <HAL_NfcReadId+0x10d>

ffe04377 <HAL_NfcReadId+0x63>:
    return the available NFCQ entry of target PU
*************************************************/

LOCAL NFCQ_ENTRY* HalNfcGetNfcqEntry(U8 Pu)
{
    U8 Wp = HalNfcGetWp(Pu);
ffe04377:	0020c0        	memw
ffe0437a:	0109      	s32i.n	a0, a1, 0
ffe0437c:	091c      	movi.n	a9, 16
ffe0437e:	000282        	l8ui	a8, a2, 0
*************************************************/

LOCAL void HalNfcClearNfcq(NFCQ_ENTRY* pNfcq)
{
    U32 i;
    for (i=0;i<NFCQ_ENTRY_SIZE_DW;i++)
ffe04381:	6f68      	l32i.n	a6, a15, 24
    return the available NFCQ entry of target PU
*************************************************/

LOCAL NFCQ_ENTRY* HalNfcGetNfcqEntry(U8 Pu)
{
    U8 Wp = HalNfcGetWp(Pu);
ffe04383:	418680        	srli	a8, a8, 6
*************************************************/

LOCAL void HalNfcClearNfcq(NFCQ_ENTRY* pNfcq)
{
    U32 i;
    for (i=0;i<NFCQ_ENTRY_SIZE_DW;i++)
ffe04386:	88ea      	add.n	a8, a8, a14
ffe04388:	1188a0        	slli	a8, a8, 6
ffe0438b:	668a      	add.n	a6, a6, a8
ffe0438d:	068d      	mov.n	a8, a6
ffe0438f:	03a976        	loopgtz	a9, ffe04396 <HAL_NfcReadId+0x82>
    {
        *(((U32*)pNfcq) + i)  = 0;
ffe04392:	0879      	s32i.n	a7, a8, 0
*************************************************/

LOCAL void HalNfcClearNfcq(NFCQ_ENTRY* pNfcq)
{
    U32 i;
    for (i=0;i<NFCQ_ENTRY_SIZE_DW;i++)
ffe04394:	884b      	addi.n	a8, a8, 4

ffe04396 <HAL_NfcReadId+0x82>:
        DBG_Printf("PU #%d Read ID: %x %x \n",ucLogPu,l_aFlashId[ucLogPu].ID[0],l_aFlashId[ucLogPu].ID[1]);
        return FAIL;
    }
    pNFCQEntry = HalNfcGetNfcqEntry(ucPhyPu);
    HalNfcClearNfcq((NFCQ_ENTRY *)pNFCQEntry);
    pNFCQEntry->bsDmaByteEn = TRUE;
ffe04396:	06a8      	l32i.n	a10, a6, 0
ffe04398:	2b0c      	movi.n	a11, 2
ffe0439a:	20aab0        	or	a10, a10, a11
ffe0439d:	06a9      	s32i.n	a10, a6, 0
    
    if (TRUE == HAL_StrapNfcIsOnfi())
ffe0439f:	0020c0        	memw
ffe043a2:	ef98      	l32i.n	a9, a15, 56
ffe043a4:	01e967        	bbsi	a9, 6, ffe043a9 <HAL_NfcReadId+0x95>
    {
        pNFCQEntry->bsByteAddr = 0x00;
    }
    else
    {
        pNFCQEntry->bsByteAddr = 0x40;
ffe043a7:	074c      	movi.n	a7, 64

ffe043a9 <HAL_NfcReadId+0x95>:
    }

    pNFCQEntry->bsByteLength = 8;
ffe043a9:	800c      	movi.n	a0, 8
    HalNfcClearNfcq((NFCQ_ENTRY *)pNFCQEntry);
    pNFCQEntry->bsDmaByteEn = TRUE;
    
    if (TRUE == HAL_StrapNfcIsOnfi())
    {
        pNFCQEntry->bsByteAddr = 0x00;
ffe043ab:	025672        	s16i	a7, a6, 4
    else
    {
        pNFCQEntry->bsByteAddr = 0x40;
    }

    pNFCQEntry->bsByteLength = 8;
ffe043ae:	035602        	s16i	a0, a6, 6
    20141028    Gavin   add "INLINE" attribute
------------------------------------------------------------------------------*/
INLINE void HAL_MemoryWait(void)
{
#ifndef SIM
    XT_MEMW();
ffe043b1:	0020c0        	memw
    HAL_MemoryWait();

    HalSetPrcq(NF_RCMD_READID,ucPhyPu);
ffe043b4:	120c      	movi.n	a2, 1
ffe043b6:	0d3d      	mov.n	a3, a13
ffe043b8:	ffe945        	call0	ffe04250 <HalSetPrcq..CB_1429880325>
    HalSetTrigger(NF_RCMD_READID,ucPhyPu,ucCeSel);
ffe043bb:	120c      	movi.n	a2, 1
ffe043bd:	0d3d      	mov.n	a3, a13
ffe043bf:	0148      	l32i.n	a4, a1, 0
ffe043c1:	ffe285        	call0	ffe041ec <HalSetTrigger..EB_1429880325>
ffe043c4:	4f28      	l32i.n	a2, a15, 16
ffe043c6:	22ea      	add.n	a2, a2, a14

    while (TRUE != HalNfcGetPuIdle(ucPhyPu))
ffe043c8:	0020c0        	memw
ffe043cb:	000232        	l8ui	a3, a2, 0
ffe043ce:	f66307        	bbci	a3, 0, ffe043c8 <HAL_NfcReadId+0xb4>
    {
        ;
    }

    if (TRUE == HalNfcGetPuErr(ucPhyPu))
ffe043d1:	0d2d      	mov.n	a2, a13
ffe043d3:	ffda45        	call0	ffe04178 <HalNfcGetPuErr..M_1429880325>
ffe043d6:	981226        	beqi	a2, 1, ffe04372 <HAL_NfcReadId+0x5e>
    {
        return FAIL;
    }
    else
    {
        l_aFlashId[ucLogPu].ID[0] = rNfcReadID0;
ffe043d9:	f5bc51        	l32r	a5, ffe01acc <_bss_table_end+0x150>
        l_aFlashId[ucLogPu].ID[1] = rNfcReadID1;
        DBG_Printf("PU #%d Read ID: %x %x \n",ucLogPu,rNfcReadID0,rNfcReadID1);
ffe043dc:	0c3d      	mov.n	a3, a12
    {
        return FAIL;
    }
    else
    {
        l_aFlashId[ucLogPu].ID[0] = rNfcReadID0;
ffe043de:	1558      	l32i.n	a5, a5, 4
        ;
    }

    if (TRUE == HalNfcGetPuErr(ucPhyPu))
    {
        return FAIL;
ffe043e0:	f5f0d1        	l32r	a13, ffe01ba0 <_bss_table_end+0x224>
    }
    else
    {
        l_aFlashId[ucLogPu].ID[0] = rNfcReadID0;
ffe043e3:	b05c50        	addx8	a5, a12, a5
ffe043e6:	0020c0        	memw
ffe043e9:	902d62        	l32i	a6, a13, 0x240
ffe043ec:	0020c0        	memw
ffe043ef:	0569      	s32i.n	a6, a5, 0
        l_aFlashId[ucLogPu].ID[1] = rNfcReadID1;
ffe043f1:	0020c0        	memw
ffe043f4:	912d42        	l32i	a4, a13, 0x244
ffe043f7:	0020c0        	memw
ffe043fa:	1549      	s32i.n	a4, a5, 4
        DBG_Printf("PU #%d Read ID: %x %x \n",ucLogPu,rNfcReadID0,rNfcReadID1);
ffe043fc:	f5e821        	l32r	a2, ffe01b9c <_bss_table_end+0x220>
ffe043ff:	0020c0        	memw
ffe04402:	902d42        	l32i	a4, a13, 0x240
ffe04405:	0020c0        	memw
ffe04408:	912d52        	l32i	a5, a13, 0x244
ffe0440b:	00ab45        	call0	ffe04ec0 <dbg_printf>
        if ((0 == rNfcReadID0)&&(0 == rNfcReadID1))
ffe0440e:	0020c0        	memw
ffe04411:	902d62        	l32i	a6, a13, 0x240
ffe04414:	76cc      	bnez.n	a6, ffe0441f <HAL_NfcReadId+0x10b>
ffe04416:	0020c0        	memw
ffe04419:	912d72        	l32i	a7, a13, 0x244
ffe0441c:	f52716        	beqz	a7, ffe04372 <HAL_NfcReadId+0x5e>
        {
            return FAIL;
        }
        else
        {
            return SUCCESS;
ffe0441f:	120c      	movi.n	a2, 1
ffe04421:	21c8      	l32i.n	a12, a1, 8
ffe04423:	31d8      	l32i.n	a13, a1, 12
ffe04425:	41e8      	l32i.n	a14, a1, 16
ffe04427:	51f8      	l32i.n	a15, a1, 20
ffe04429:	1108      	l32i.n	a0, a1, 4
ffe0442b:	20c112        	addi	a1, a1, 32
ffe0442e:	f00d      	ret.n

ffe04430 <HAL_ScanPu>:
Description:
    scan all pu id for MP , MP thread may evoke it through function pointer
*************************************************/

void HAL_ScanPu(void)
{
ffe04430:	d0c112        	addi	a1, a1, -48
ffe04433:	31c9      	s32i.n	a12, a1, 12
ffe04435:	51e9      	s32i.n	a14, a1, 20
ffe04437:	41d9      	s32i.n	a13, a1, 16
ffe04439:	f552d1        	l32r	a13, ffe01984 <_bss_table_end+0x8>
ffe0443c:	2109      	s32i.n	a0, a1, 8
    U32 i;
    for (i=0;i<l_ucCeMax;i++)
ffe0443e:	000d02        	l8ui	a0, a13, 0
Description:
    scan all pu id for MP , MP thread may evoke it through function pointer
*************************************************/

void HAL_ScanPu(void)
{
ffe04441:	61f9      	s32i.n	a15, a1, 24
    U32 i;
    for (i=0;i<l_ucCeMax;i++)
ffe04443:	11b016        	beqz	a0, ffe04562 <HAL_ScanPu+0x132>
ffe04446:	0c0c      	movi.n	a12, 0
ffe04448:	070c      	movi.n	a7, 0
ffe0444a:	f5a021        	l32r	a2, ffe01acc <_bss_table_end+0x150>
ffe0444d:	8179      	s32i.n	a7, a1, 32
ffe0444f:	1228      	l32i.n	a2, a2, 4
ffe04451:	7129      	s32i.n	a2, a1, 28

ffe04453 <HAL_ScanPu+0x23>:
    {
        HAL_NfcResetPu(i);
ffe04453:	81f8      	l32i.n	a15, a1, 32
ffe04455:	74f0f0        	extui	a15, a15, 0, 8
ffe04458:	0f2d      	mov.n	a2, a15
ffe0445a:	006605        	call0	ffe04abc <HAL_NfcResetPu>
GLOBAL BOOL HAL_NfcReadId(U8 ucLogPu)
{
    NFCQ_ENTRY *pNFCQEntry;
    BOOL bRet;

    U8 ucPhyPu = HAL_NfcGetPhyPu(ucLogPu);
ffe0445d:	0f2d      	mov.n	a2, a15
ffe0445f:	ffea05        	call0	ffe04300 <HAL_NfcGetPhyPu>
ffe04462:	02ed      	mov.n	a14, a2
    U8 ucCeSel = HAL_NfcGetCeSel(ucLogPu);
ffe04464:	0f2d      	mov.n	a2, a15
ffe04466:	ffe845        	call0	ffe042ec <HAL_NfcGetCeSel>
ffe04469:	4d68      	l32i.n	a6, a13, 16
ffe0446b:	110ee0        	slli	a0, a14, 2
ffe0446e:	a06e60        	addx4	a6, a14, a6

    while (FALSE == HalNfcGetPuEmpty(ucPhyPu))
ffe04471:	0020c0        	memw
ffe04474:	000672        	l8ui	a7, a6, 0
ffe04477:	f66727        	bbci	a7, 2, ffe04471 <HAL_ScanPu+0x41>
    {
        ;
    }

    if (TRUE == HalNfcGetPuFull(ucPhyPu))
ffe0447a:	0020c0        	memw
ffe0447d:	000682        	l8ui	a8, a6, 0
ffe04480:	230c      	movi.n	a3, 2
ffe04482:	236837        	bbci	a8, 3, ffe044a9 <HAL_ScanPu+0x79>
    {
        // FPGA only
        l_aFlashId[ucLogPu].ID[0] = 0;
ffe04485:	7158      	l32i.n	a5, a1, 28
        l_aFlashId[ucLogPu].ID[1] = 0;
        DBG_Printf("PU #%d Read ID: %x %x \n",ucLogPu,l_aFlashId[ucLogPu].ID[0],l_aFlashId[ucLogPu].ID[1]);
ffe04487:	0f3d      	mov.n	a3, a15
    }

    if (TRUE == HalNfcGetPuFull(ucPhyPu))
    {
        // FPGA only
        l_aFlashId[ucLogPu].ID[0] = 0;
ffe04489:	b05f50        	addx8	a5, a15, a5
ffe0448c:	0020c0        	memw
ffe0448f:	05c9      	s32i.n	a12, a5, 0
        l_aFlashId[ucLogPu].ID[1] = 0;
ffe04491:	0020c0        	memw
ffe04494:	15c9      	s32i.n	a12, a5, 4
        DBG_Printf("PU #%d Read ID: %x %x \n",ucLogPu,l_aFlashId[ucLogPu].ID[0],l_aFlashId[ucLogPu].ID[1]);
ffe04496:	f5c121        	l32r	a2, ffe01b9c <_bss_table_end+0x220>
ffe04499:	0020c0        	memw
ffe0449c:	0548      	l32i.n	a4, a5, 0
ffe0449e:	0020c0        	memw
ffe044a1:	1558      	l32i.n	a5, a5, 4
ffe044a3:	00a1c5        	call0	ffe04ec0 <dbg_printf>
ffe044a6:	002a46        	j	ffe04553 <HAL_ScanPu+0x123>

ffe044a9 <HAL_ScanPu+0x79>:
    return the available NFCQ entry of target PU
*************************************************/

LOCAL NFCQ_ENTRY* HalNfcGetNfcqEntry(U8 Pu)
{
    U8 Wp = HalNfcGetWp(Pu);
ffe044a9:	0020c0        	memw
ffe044ac:	1129      	s32i.n	a2, a1, 4
ffe044ae:	081c      	movi.n	a8, 16
ffe044b0:	000692        	l8ui	a9, a6, 0
*************************************************/

LOCAL void HalNfcClearNfcq(NFCQ_ENTRY* pNfcq)
{
    U32 i;
    for (i=0;i<NFCQ_ENTRY_SIZE_DW;i++)
ffe044b3:	6d78      	l32i.n	a7, a13, 24
    return the available NFCQ entry of target PU
*************************************************/

LOCAL NFCQ_ENTRY* HalNfcGetNfcqEntry(U8 Pu)
{
    U8 Wp = HalNfcGetWp(Pu);
ffe044b5:	419690        	srli	a9, a9, 6
*************************************************/

LOCAL void HalNfcClearNfcq(NFCQ_ENTRY* pNfcq)
{
    U32 i;
    for (i=0;i<NFCQ_ENTRY_SIZE_DW;i++)
ffe044b8:	990a      	add.n	a9, a9, a0
ffe044ba:	1199a0        	slli	a9, a9, 6
ffe044bd:	779a      	add.n	a7, a7, a9
ffe044bf:	076d      	mov.n	a6, a7
ffe044c1:	03a876        	loopgtz	a8, ffe044c8 <HAL_ScanPu+0x98>
    {
        *(((U32*)pNfcq) + i)  = 0;
ffe044c4:	06c9      	s32i.n	a12, a6, 0
*************************************************/

LOCAL void HalNfcClearNfcq(NFCQ_ENTRY* pNfcq)
{
    U32 i;
    for (i=0;i<NFCQ_ENTRY_SIZE_DW;i++)
ffe044c6:	664b      	addi.n	a6, a6, 4

ffe044c8 <HAL_ScanPu+0x98>:
        DBG_Printf("PU #%d Read ID: %x %x \n",ucLogPu,l_aFlashId[ucLogPu].ID[0],l_aFlashId[ucLogPu].ID[1]);
        return FAIL;
    }
    pNFCQEntry = HalNfcGetNfcqEntry(ucPhyPu);
    HalNfcClearNfcq((NFCQ_ENTRY *)pNFCQEntry);
    pNFCQEntry->bsDmaByteEn = TRUE;
ffe044c8:	07b8      	l32i.n	a11, a7, 0
ffe044ca:	20bb30        	or	a11, a11, a3
ffe044cd:	07b9      	s32i.n	a11, a7, 0
    
    if (TRUE == HAL_StrapNfcIsOnfi())
ffe044cf:	0020c0        	memw
ffe044d2:	eda8      	l32i.n	a10, a13, 56
ffe044d4:	0109      	s32i.n	a0, a1, 0
ffe044d6:	056a67        	bbci	a10, 6, ffe044df <HAL_ScanPu+0xaf>
    {
        pNFCQEntry->bsByteAddr = 0x00;
ffe044d9:	0257c2        	s16i	a12, a7, 4
ffe044dc:	000106        	j	ffe044e4 <HAL_ScanPu+0xb4>

ffe044df <HAL_ScanPu+0xaf>:
    }
    else
    {
        pNFCQEntry->bsByteAddr = 0x40;
ffe044df:	004c      	movi.n	a0, 64
ffe044e1:	025702        	s16i	a0, a7, 4
    }

    pNFCQEntry->bsByteLength = 8;
ffe044e4:	820c      	movi.n	a2, 8
ffe044e6:	035722        	s16i	a2, a7, 6
ffe044e9:	0020c0        	memw
    HAL_MemoryWait();

    HalSetPrcq(NF_RCMD_READID,ucPhyPu);
ffe044ec:	120c      	movi.n	a2, 1
ffe044ee:	0e3d      	mov.n	a3, a14
ffe044f0:	ffd5c5        	call0	ffe04250 <HalSetPrcq..CB_1429880325>
    HalSetTrigger(NF_RCMD_READID,ucPhyPu,ucCeSel);
ffe044f3:	120c      	movi.n	a2, 1
ffe044f5:	0e3d      	mov.n	a3, a14
ffe044f7:	1148      	l32i.n	a4, a1, 4
ffe044f9:	ffcf05        	call0	ffe041ec <HalSetTrigger..EB_1429880325>
ffe044fc:	0178      	l32i.n	a7, a1, 0
ffe044fe:	4d68      	l32i.n	a6, a13, 16
ffe04500:	667a      	add.n	a6, a6, a7

    while (TRUE != HalNfcGetPuIdle(ucPhyPu))
ffe04502:	0020c0        	memw
ffe04505:	000682        	l8ui	a8, a6, 0
ffe04508:	f66807        	bbci	a8, 0, ffe04502 <HAL_ScanPu+0xd2>
    {
        ;
    }

    if (TRUE == HalNfcGetPuErr(ucPhyPu))
ffe0450b:	0e2d      	mov.n	a2, a14
ffe0450d:	ffc685        	call0	ffe04178 <HalNfcGetPuErr..M_1429880325>
ffe04510:	f5a4e1        	l32r	a14, ffe01ba0 <_bss_table_end+0x224>
ffe04513:	3c1226        	beqi	a2, 1, ffe04553 <HAL_ScanPu+0x123>
    {
        return FAIL;
    }
    else
    {
        l_aFlashId[ucLogPu].ID[0] = rNfcReadID0;
ffe04516:	71a8      	l32i.n	a10, a1, 28
        l_aFlashId[ucLogPu].ID[1] = rNfcReadID1;
        DBG_Printf("PU #%d Read ID: %x %x \n",ucLogPu,rNfcReadID0,rNfcReadID1);
ffe04518:	0f3d      	mov.n	a3, a15
    {
        return FAIL;
    }
    else
    {
        l_aFlashId[ucLogPu].ID[0] = rNfcReadID0;
ffe0451a:	b0afa0        	addx8	a10, a15, a10
ffe0451d:	0020c0        	memw
ffe04520:	902eb2        	l32i	a11, a14, 0x240
ffe04523:	0020c0        	memw
ffe04526:	0ab9      	s32i.n	a11, a10, 0
        l_aFlashId[ucLogPu].ID[1] = rNfcReadID1;
ffe04528:	0020c0        	memw
ffe0452b:	912e92        	l32i	a9, a14, 0x244
ffe0452e:	0020c0        	memw
ffe04531:	1a99      	s32i.n	a9, a10, 4
        DBG_Printf("PU #%d Read ID: %x %x \n",ucLogPu,rNfcReadID0,rNfcReadID1);
ffe04533:	f59a21        	l32r	a2, ffe01b9c <_bss_table_end+0x220>
ffe04536:	0020c0        	memw
ffe04539:	902e42        	l32i	a4, a14, 0x240
ffe0453c:	0020c0        	memw
ffe0453f:	912e52        	l32i	a5, a14, 0x244
ffe04542:	0097c5        	call0	ffe04ec0 <dbg_printf>
        if ((0 == rNfcReadID0)&&(0 == rNfcReadID1))
ffe04545:	0020c0        	memw
ffe04548:	902eb2        	l32i	a11, a14, 0x240
ffe0454b:	4bcc      	bnez.n	a11, ffe04553 <HAL_ScanPu+0x123>
ffe0454d:	0020c0        	memw
ffe04550:	912ef2        	l32i	a15, a14, 0x244
*************************************************/

void HAL_ScanPu(void)
{
    U32 i;
    for (i=0;i<l_ucCeMax;i++)
ffe04553:	8108      	l32i.n	a0, a1, 32
ffe04555:	000d22        	l8ui	a2, a13, 0
ffe04558:	001b      	addi.n	a0, a0, 1
ffe0455a:	8109      	s32i.n	a0, a1, 32
ffe0455c:	02b027        	bgeu	a0, a2, ffe04562 <HAL_ScanPu+0x132>
ffe0455f:	ffbc06        	j	ffe04453 <HAL_ScanPu+0x23>
    {
        HAL_NfcResetPu(i);
        HAL_NfcReadId(i);
    }
}
ffe04562:	31c8      	l32i.n	a12, a1, 12
ffe04564:	41d8      	l32i.n	a13, a1, 16
ffe04566:	51e8      	l32i.n	a14, a1, 20
ffe04568:	61f8      	l32i.n	a15, a1, 24
ffe0456a:	2108      	l32i.n	a0, a1, 8
ffe0456c:	30c112        	addi	a1, a1, 48
ffe0456f:	f00d      	ret.n

ffe04571 <HAL_ScanPu+0x141>:
ffe04571:	000000                                        ...

ffe04574 <HAL_SetDELAYCOUNT>:
    mcu invoke it to set DELAYCOUNT val with ulDELAYCOUNTVal via ERI bus.
History:
    20141120    Tobey   create
------------------------------------------------------------------------------*/
void HAL_SetDELAYCOUNT(U32 ulDELAYCOUNTVal)
{
ffe04574:	f0c112        	addi	a1, a1, -16
ffe04577:	11c9      	s32i.n	a12, a1, 4
ffe04579:	0109      	s32i.n	a0, a1, 0
    //only lower 24-bits of the register are significant
    if(ulDELAYCOUNTVal >= (1<<24))
ffe0457b:	f58a01        	l32r	a0, ffe01ba4 <_bss_table_end+0x228>
    mcu invoke it to set DELAYCOUNT val with ulDELAYCOUNTVal via ERI bus.
History:
    20141120    Tobey   create
------------------------------------------------------------------------------*/
void HAL_SetDELAYCOUNT(U32 ulDELAYCOUNTVal)
{
ffe0457e:	02cd      	mov.n	a12, a2
    //only lower 24-bits of the register are significant
    if(ulDELAYCOUNTVal >= (1<<24))
ffe04580:	05b027        	bgeu	a0, a2, ffe04589 <HAL_SetDELAYCOUNT+0x15>
    {
        DBG_Getch("DELAYCOUNT setting error!\n");
ffe04583:	f58921        	l32r	a2, ffe01ba8 <_bss_table_end+0x22c>
ffe04586:	006605        	call0	ffe04be8 <DBG_Getch>

ffe04589 <HAL_SetDELAYCOUNT+0x15>:
    }
    XT_WER(ulDELAYCOUNTVal, TRAX_DELAYCOUNT);
ffe04589:	f58821        	l32r	a2, ffe01bac <_bss_table_end+0x230>
    return;
ffe0458c:	0108      	l32i.n	a0, a1, 0
    //only lower 24-bits of the register are significant
    if(ulDELAYCOUNTVal >= (1<<24))
    {
        DBG_Getch("DELAYCOUNT setting error!\n");
    }
    XT_WER(ulDELAYCOUNTVal, TRAX_DELAYCOUNT);
ffe0458e:	4072c0        	wer	a12, a2
    return;
ffe04591:	11c8      	l32i.n	a12, a1, 4
ffe04593:	10c112        	addi	a1, a1, 16
ffe04596:	f00d      	ret.n

ffe04598 <HalGetTraceSize..EC_1429880325>:
U16 HAL_GetMEMSTARTADDR(void)
{
    U16 usMemStartAddr;
    U32 ulMemAddrTemp;
    
    ulMemAddrTemp = XT_RER(TRAX_MEMSTARTADDR);
ffe04598:	f58661        	l32r	a6, ffe01bb0 <_bss_table_end+0x234>
U16 HAL_GetMEMENDADDR(void)
{
    U16 usMemEndAddr;
    U32 ulMemAddrTemp;
    
    ulMemAddrTemp = XT_RER(TRAX_MEMENDADDR);
ffe0459b:	f58651        	l32r	a5, ffe01bb4 <_bss_table_end+0x238>
U16 HAL_GetMEMSTARTADDR(void)
{
    U16 usMemStartAddr;
    U32 ulMemAddrTemp;
    
    ulMemAddrTemp = XT_RER(TRAX_MEMSTARTADDR);
ffe0459e:	406640        	rer	a4, a6
U16 HAL_GetMEMENDADDR(void)
{
    U16 usMemEndAddr;
    U32 ulMemAddrTemp;
    
    ulMemAddrTemp = XT_RER(TRAX_MEMENDADDR);
ffe045a1:	406530        	rer	a3, a5
    S16 ssTraceSize;

    usStartAddr = HAL_GetMEMSTARTADDR();
    usEndAddr = HAL_GetMEMENDADDR();
    
    ssTraceSize = usEndAddr - usStartAddr;
ffe045a4:	c44040        	extui	a4, a4, 0, 13
ffe045a7:	c43030        	extui	a3, a3, 0, 13
ffe045aa:	c03340        	sub	a3, a3, a4
ffe045ad:	234380        	sext	a4, a3, 15
    if (ssTraceSize < 0)
ffe045b0:	0863f7        	bbci	a3, 15, ffe045bc <HalGetTraceSize..EC_1429880325+0x24>
    {
      ssTraceSize += ((pContext->ulTraxTramSize >> 2) - 1);
ffe045b3:	1258      	l32i.n	a5, a2, 4
ffe045b5:	415250        	srli	a5, a5, 2
ffe045b8:	445a      	add.n	a4, a4, a5
ffe045ba:	440b      	addi.n	a4, a4, -1

ffe045bc <HalGetTraceSize..EC_1429880325+0x24>:
    }
    /* In terms of bytes */
    ssTraceSize = (ssTraceSize + 1) << 2;

    return (U16)ssTraceSize;
ffe045bc:	241b      	addi.n	a2, a4, 1
ffe045be:	1122e0        	slli	a2, a2, 2
ffe045c1:	f42020        	extui	a2, a2, 0, 16
ffe045c4:	f00d      	ret.n

ffe045c6 <HalGetTraceSize..EC_1429880325+0x2e>:
	...

ffe045c8 <HAL_SetMEMENDADDR>:
    mcu invoke it to set MEMENDADDR val with ulMEMENDADDRVal via ERI bus.
History:
    20141120    Tobey   create
------------------------------------------------------------------------------*/
void HAL_SetMEMENDADDR(U16 ulMEMENDADDRVal)
{
ffe045c8:	f0c112        	addi	a1, a1, -16
ffe045cb:	11c9      	s32i.n	a12, a1, 4
ffe045cd:	0109      	s32i.n	a0, a1, 0
    U32 ulMemAddrTemp;
    
    if(ulMEMENDADDRVal > (1<<m))
ffe045cf:	f56d01        	l32r	a0, ffe01b84 <_bss_table_end+0x208>
    mcu invoke it to set MEMENDADDR val with ulMEMENDADDRVal via ERI bus.
History:
    20141120    Tobey   create
------------------------------------------------------------------------------*/
void HAL_SetMEMENDADDR(U16 ulMEMENDADDRVal)
{
ffe045d2:	02cd      	mov.n	a12, a2
    U32 ulMemAddrTemp;
    
    if(ulMEMENDADDRVal > (1<<m))
ffe045d4:	02b027        	bgeu	a0, a2, ffe045da <HAL_SetMEMENDADDR+0x12>
    {
        DBG_Getch();
ffe045d7:	006105        	call0	ffe04be8 <DBG_Getch>

ffe045da <HAL_SetMEMENDADDR+0x12>:
ffe045da:	f57631        	l32r	a3, ffe01bb4 <_bss_table_end+0x238>

    }

    ulMemAddrTemp = XT_RER(TRAX_MEMENDADDR);
    ulMemAddrTemp = (ulMemAddrTemp & (INVALID_8F<<m)) | ulMEMENDADDRVal;
    XT_WER(ulMemAddrTemp, TRAX_MEMENDADDR);
ffe045dd:	f57641        	l32r	a4, ffe01bb8 <_bss_table_end+0x23c>
    {
        DBG_Getch();

    }

    ulMemAddrTemp = XT_RER(TRAX_MEMENDADDR);
ffe045e0:	406320        	rer	a2, a3
    ulMemAddrTemp = (ulMemAddrTemp & (INVALID_8F<<m)) | ulMEMENDADDRVal;
    XT_WER(ulMemAddrTemp, TRAX_MEMENDADDR);
    
    return;
ffe045e3:	0108      	l32i.n	a0, a1, 0

    }

    ulMemAddrTemp = XT_RER(TRAX_MEMENDADDR);
    ulMemAddrTemp = (ulMemAddrTemp & (INVALID_8F<<m)) | ulMEMENDADDRVal;
    XT_WER(ulMemAddrTemp, TRAX_MEMENDADDR);
ffe045e5:	102240        	and	a2, a2, a4
ffe045e8:	202c20        	or	a2, a12, a2
    
    return;
ffe045eb:	11c8      	l32i.n	a12, a1, 4

    }

    ulMemAddrTemp = XT_RER(TRAX_MEMENDADDR);
    ulMemAddrTemp = (ulMemAddrTemp & (INVALID_8F<<m)) | ulMEMENDADDRVal;
    XT_WER(ulMemAddrTemp, TRAX_MEMENDADDR);
ffe045ed:	407320        	wer	a2, a3
    
    return;
ffe045f0:	10c112        	addi	a1, a1, 16
ffe045f3:	f00d      	ret.n

ffe045f5 <HAL_SetMEMENDADDR+0x2d>:
ffe045f5:	000000                                        ...

ffe045f8 <HAL_SetMEMSTARTADDR>:
    mcu invoke it to set MEMSTARTADDR val with ulMEMSTARTADDRVal via ERI bus.
History:
    20141120    Tobey   create
------------------------------------------------------------------------------*/
void HAL_SetMEMSTARTADDR(U16 usMEMSTARTADDRVal)
{
ffe045f8:	f0c112        	addi	a1, a1, -16
ffe045fb:	11c9      	s32i.n	a12, a1, 4
ffe045fd:	0109      	s32i.n	a0, a1, 0
    U32 ulMemAddrTemp;
    
    if(usMEMSTARTADDRVal > (1<<m))
ffe045ff:	f56101        	l32r	a0, ffe01b84 <_bss_table_end+0x208>
    mcu invoke it to set MEMSTARTADDR val with ulMEMSTARTADDRVal via ERI bus.
History:
    20141120    Tobey   create
------------------------------------------------------------------------------*/
void HAL_SetMEMSTARTADDR(U16 usMEMSTARTADDRVal)
{
ffe04602:	02cd      	mov.n	a12, a2
    U32 ulMemAddrTemp;
    
    if(usMEMSTARTADDRVal > (1<<m))
ffe04604:	02b027        	bgeu	a0, a2, ffe0460a <HAL_SetMEMSTARTADDR+0x12>
    {
        DBG_Getch();
ffe04607:	005e05        	call0	ffe04be8 <DBG_Getch>

ffe0460a <HAL_SetMEMSTARTADDR+0x12>:
ffe0460a:	f56931        	l32r	a3, ffe01bb0 <_bss_table_end+0x234>

    }
    
    ulMemAddrTemp = XT_RER(TRAX_MEMSTARTADDR);
    ulMemAddrTemp = (ulMemAddrTemp & (INVALID_8F<<m)) | usMEMSTARTADDRVal;
    XT_WER(ulMemAddrTemp, TRAX_MEMSTARTADDR);
ffe0460d:	f56a41        	l32r	a4, ffe01bb8 <_bss_table_end+0x23c>
    {
        DBG_Getch();

    }
    
    ulMemAddrTemp = XT_RER(TRAX_MEMSTARTADDR);
ffe04610:	406320        	rer	a2, a3
    ulMemAddrTemp = (ulMemAddrTemp & (INVALID_8F<<m)) | usMEMSTARTADDRVal;
    XT_WER(ulMemAddrTemp, TRAX_MEMSTARTADDR);
    
    return;
ffe04613:	0108      	l32i.n	a0, a1, 0

    }
    
    ulMemAddrTemp = XT_RER(TRAX_MEMSTARTADDR);
    ulMemAddrTemp = (ulMemAddrTemp & (INVALID_8F<<m)) | usMEMSTARTADDRVal;
    XT_WER(ulMemAddrTemp, TRAX_MEMSTARTADDR);
ffe04615:	102240        	and	a2, a2, a4
ffe04618:	202c20        	or	a2, a12, a2
    
    return;
ffe0461b:	11c8      	l32i.n	a12, a1, 4

    }
    
    ulMemAddrTemp = XT_RER(TRAX_MEMSTARTADDR);
    ulMemAddrTemp = (ulMemAddrTemp & (INVALID_8F<<m)) | usMEMSTARTADDRVal;
    XT_WER(ulMemAddrTemp, TRAX_MEMSTARTADDR);
ffe0461d:	407320        	wer	a2, a3
    
    return;
ffe04620:	10c112        	addi	a1, a1, 16
ffe04623:	f00d      	ret.n

ffe04625 <HAL_SetMEMSTARTADDR+0x2d>:
ffe04625:	000000                                        ...

ffe04628 <HAL_TraxIsTraceActive>:
    mcu invoke it check trax whether active or not.
History:
    20141120    Tobey   create
------------------------------------------------------------------------------*/
BOOL HAL_TraxIsTraceActive(void)
{
ffe04628:	f0c112        	addi	a1, a1, -16
    20141120    Tobey   create
------------------------------------------------------------------------------*/
TRAXSTATREG HAL_GetTRAXSTAT(void)
{
    TRAXSTATREG tTraxStat;
    *((U32 *)(&tTraxStat)) = XT_RER(TRAX_STAT);
ffe0462b:	f56451        	l32r	a5, ffe01bbc <_bss_table_end+0x240>
------------------------------------------------------------------------------*/
BOOL HAL_TraxIsTraceActive(void)
{
    TRAXSTATREG tTraxStat;
    
    tTraxStat = HAL_GetTRAXSTAT();
ffe0462e:	414b      	addi.n	a4, a1, 4
    20141120    Tobey   create
------------------------------------------------------------------------------*/
TRAXSTATREG HAL_GetTRAXSTAT(void)
{
    TRAXSTATREG tTraxStat;
    *((U32 *)(&tTraxStat)) = XT_RER(TRAX_STAT);
ffe04630:	406530        	rer	a3, a5
------------------------------------------------------------------------------*/
BOOL HAL_TraxIsTraceActive(void)
{
    TRAXSTATREG tTraxStat;
    
    tTraxStat = HAL_GetTRAXSTAT();
ffe04633:	0439      	s32i.n	a3, a4, 0
    return tTraxStat.bsTRACT;
ffe04635:	1128      	l32i.n	a2, a1, 4
ffe04637:	10c112        	addi	a1, a1, 16
ffe0463a:	042020        	extui	a2, a2, 0, 1
ffe0463d:	f00d      	ret.n

ffe0463f <HAL_TraxIsTraceActive+0x17>:
	...

ffe04640 <HAL_TraxGetTraceRamSize>:
    
    tTraxStat = HAL_GetTRAXSTAT();
    ucPower = tTraxStat.bsMEMSZ;
    ulRamSize = TraxPowerOf2(ucPower);

    return ulRamSize;
ffe04640:	120c      	movi.n	a2, 1
    mcu invoke it get TraceRAM size.
History:
    20141120    Tobey   create
------------------------------------------------------------------------------*/
U32 HAL_TraxGetTraceRamSize(void)
{
ffe04642:	f0c112        	addi	a1, a1, -16
    20141120    Tobey   create
------------------------------------------------------------------------------*/
TRAXSTATREG HAL_GetTRAXSTAT(void)
{
    TRAXSTATREG tTraxStat;
    *((U32 *)(&tTraxStat)) = XT_RER(TRAX_STAT);
ffe04645:	f55d61        	l32r	a6, ffe01bbc <_bss_table_end+0x240>
{
    U8 ucPower;
    U32 ulRamSize = 1;
    TRAXSTATREG tTraxStat;
    
    tTraxStat = HAL_GetTRAXSTAT();
ffe04648:	514b      	addi.n	a5, a1, 4
    20141120    Tobey   create
------------------------------------------------------------------------------*/
TRAXSTATREG HAL_GetTRAXSTAT(void)
{
    TRAXSTATREG tTraxStat;
    *((U32 *)(&tTraxStat)) = XT_RER(TRAX_STAT);
ffe0464a:	406640        	rer	a4, a6
{
    U8 ucPower;
    U32 ulRamSize = 1;
    TRAXSTATREG tTraxStat;
    
    tTraxStat = HAL_GetTRAXSTAT();
ffe0464d:	0549      	s32i.n	a4, a5, 0
    ucPower = tTraxStat.bsMEMSZ;
    ulRamSize = TraxPowerOf2(ucPower);

    return ulRamSize;
ffe0464f:	1138      	l32i.n	a3, a1, 4
ffe04651:	10c112        	addi	a1, a1, 16
ffe04654:	443830        	extui	a3, a3, 8, 5
ffe04657:	401300        	ssl	a3
ffe0465a:	a12200        	sll	a2, a2
ffe0465d:	f00d      	ret.n

ffe0465f <HAL_TraxGetTraceRamSize+0x1f>:
	...

ffe04660 <HAL_TraxStart>:
    invoke it let trax start.
History:
    20141120    Tobey   create
------------------------------------------------------------------------------*/
BOOL HAL_TraxStart(void)
{ 
ffe04660:	f0c112        	addi	a1, a1, -16
ffe04663:	2109      	s32i.n	a0, a1, 8
    TRAXCTRLREG tTraxCtrl;
    
    if(FALSE == HAL_TraxIsTraceActive())
ffe04665:	fffc05        	call0	ffe04628 <HAL_TraxIsTraceActive>
ffe04668:	62ec      	bnez.n	a2, ffe04692 <HAL_TraxStart+0x32>
    {
        tTraxCtrl = HAL_GetTRAXCTRL();
ffe0466a:	f55531        	l32r	a3, ffe01bc0 <_bss_table_end+0x244>
ffe0466d:	414b      	addi.n	a4, a1, 4
------------------------------------------------------------------------------*/
TRAXCTRLREG HAL_GetTRAXCTRL(void)
{
    TRAXCTRLREG tTraxCtrl;
    
    *((U32 *)(&tTraxCtrl)) = XT_RER(TRAX_CTRL);
ffe0466f:	406370        	rer	a7, a3
{ 
    TRAXCTRLREG tTraxCtrl;
    
    if(FALSE == HAL_TraxIsTraceActive())
    {
        tTraxCtrl = HAL_GetTRAXCTRL();
ffe04672:	0479      	s32i.n	a7, a4, 0
        tTraxCtrl.bsTREN = FALSE;
ffe04674:	1158      	l32i.n	a5, a1, 4
ffe04676:	e67c      	movi.n	a6, -2
ffe04678:	105560        	and	a5, a5, a6
History:
    20141120    Tobey   create
------------------------------------------------------------------------------*/
void HAL_SetTRAXCTRL(TRAXCTRLREG * pTRAXCTRLVal)
{
    XT_WER(*((U32 *)pTRAXCTRLVal), TRAX_CTRL);
ffe0467b:	407350        	wer	a5, a3
    TRAXCTRLREG tTraxCtrl;
    
    if(FALSE == HAL_TraxIsTraceActive())
    {
        tTraxCtrl = HAL_GetTRAXCTRL();
        tTraxCtrl.bsTREN = FALSE;
ffe0467e:	1159      	s32i.n	a5, a1, 4
------------------------------------------------------------------------------*/
TRAXCTRLREG HAL_GetTRAXCTRL(void)
{
    TRAXCTRLREG tTraxCtrl;
    
    *((U32 *)(&tTraxCtrl)) = XT_RER(TRAX_CTRL);
ffe04680:	406320        	rer	a2, a3
    {
        tTraxCtrl = HAL_GetTRAXCTRL();
        tTraxCtrl.bsTREN = FALSE;
        HAL_SetTRAXCTRL(&tTraxCtrl);

        tTraxCtrl = HAL_GetTRAXCTRL();
ffe04683:	0429      	s32i.n	a2, a4, 0
History:
    20141120    Tobey   create
------------------------------------------------------------------------------*/
void HAL_SetTRAXCTRL(TRAXCTRLREG * pTRAXCTRLVal)
{
    XT_WER(*((U32 *)pTRAXCTRLVal), TRAX_CTRL);
ffe04685:	1108      	l32i.n	a0, a1, 4
ffe04687:	120c      	movi.n	a2, 1
ffe04689:	200020        	or	a0, a0, a2
ffe0468c:	407300        	wer	a0, a3
------------------------------------------------------------------------------*/
BOOL HAL_TraxStart(void)
{ 
    TRAXCTRLREG tTraxCtrl;
    
    if(FALSE == HAL_TraxIsTraceActive())
ffe0468f:	0001c6        	j	ffe0469a <HAL_TraxStart+0x3a>

ffe04692 <HAL_TraxStart+0x32>:
        tTraxCtrl.bsTREN= TRUE;
        HAL_SetTRAXCTRL(&tTraxCtrl);
    }
    else
    {
        DBG_Printf("It's tracing now\n");
ffe04692:	f54c21        	l32r	a2, ffe01bc4 <_bss_table_end+0x248>
ffe04695:	008285        	call0	ffe04ec0 <dbg_printf>
        return FALSE;
ffe04698:	020c      	movi.n	a2, 0
ffe0469a:	2108      	l32i.n	a0, a1, 8
ffe0469c:	10c112        	addi	a1, a1, 16
ffe0469f:	f00d      	ret.n

ffe046a1 <HAL_TraxStart+0x41>:
ffe046a1:	000000                                        ...

ffe046a4 <HAL_TraxGetPostSize>:
------------------------------------------------------------------------------*/
TRAXCTRLREG HAL_GetTRAXCTRL(void)
{
    TRAXCTRLREG tTraxCtrl;
    
    *((U32 *)(&tTraxCtrl)) = XT_RER(TRAX_CTRL);
ffe046a4:	f54781        	l32r	a8, ffe01bc0 <_bss_table_end+0x244>
    invoke it to get Trax post size.
History:
    20141120    Tobey   create
------------------------------------------------------------------------------*/
void HAL_TraxGetPostSize(U32 * pDelayCount, U8 * pUnitType)
{
ffe046a7:	f0c112        	addi	a1, a1, -16
------------------------------------------------------------------------------*/
U32 HAL_GetDELAYCOUNT(void)
{
    U32 ulDelayCnt;
    
    ulDelayCnt = XT_RER(TRAX_DELAYCOUNT);
ffe046aa:	f54091        	l32r	a9, ffe01bac <_bss_table_end+0x230>
{
    U32 ulDelayCnt;
    TRAXCTRLREG tTraxCtrl;
    
    ulDelayCnt = HAL_GetDELAYCOUNT();
    tTraxCtrl = HAL_GetTRAXCTRL();
ffe046ad:	714b      	addi.n	a7, a1, 4
------------------------------------------------------------------------------*/
U32 HAL_GetDELAYCOUNT(void)
{
    U32 ulDelayCnt;
    
    ulDelayCnt = XT_RER(TRAX_DELAYCOUNT);
ffe046af:	406950        	rer	a5, a9
------------------------------------------------------------------------------*/
TRAXCTRLREG HAL_GetTRAXCTRL(void)
{
    TRAXCTRLREG tTraxCtrl;
    
    *((U32 *)(&tTraxCtrl)) = XT_RER(TRAX_CTRL);
ffe046b2:	406860        	rer	a6, a8
{
    U32 ulDelayCnt;
    TRAXCTRLREG tTraxCtrl;
    
    ulDelayCnt = HAL_GetDELAYCOUNT();
    tTraxCtrl = HAL_GetTRAXCTRL();
ffe046b5:	0769      	s32i.n	a6, a7, 0
    
    if(0 == tTraxCtrl.bsCNTU)//by word or percent
ffe046b7:	1148      	l32i.n	a4, a1, 4
------------------------------------------------------------------------------*/
TRAXCTRLREG HAL_GetTRAXCTRL(void)
{
    TRAXCTRLREG tTraxCtrl;
    
    *((U32 *)(&tTraxCtrl)) = XT_RER(TRAX_CTRL);
ffe046b9:	160c      	movi.n	a6, 1
    TRAXCTRLREG tTraxCtrl;
    
    ulDelayCnt = HAL_GetDELAYCOUNT();
    tTraxCtrl = HAL_GetTRAXCTRL();
    
    if(0 == tTraxCtrl.bsCNTU)//by word or percent
ffe046bb:	12e497        	bbsi	a4, 9, ffe046d1 <HAL_TraxGetPostSize+0x2d>
ffe046be:	558c      	beqz.n	a5, ffe046c7 <HAL_TraxGetPostSize+0x23>
    {
        if (ulDelayCnt > 0)
        {
            ulDelayCnt += (POSTSIZE_ADJUST/4);
            *pDelayCount = (int)(ulDelayCnt * 4);
ffe046c0:	0a2c      	movi.n	a10, 32
ffe046c2:	a0a5a0        	addx4	a10, a5, a10
ffe046c5:	02a9      	s32i.n	a10, a2, 0

ffe046c7 <HAL_TraxGetPostSize+0x23>:
        }
        *pUnitType = 0;
ffe046c7:	020c      	movi.n	a2, 0
ffe046c9:	004322        	s8i	a2, a3, 0
    {
        *pDelayCount = ulDelayCnt;
        *pUnitType = 1;
    }
    
    return;
ffe046cc:	10c112        	addi	a1, a1, 16
ffe046cf:	f00d      	ret.n

ffe046d1 <HAL_TraxGetPostSize+0x2d>:
        }
        *pUnitType = 0;
    }
    else//by instruction
    {
        *pDelayCount = ulDelayCnt;
ffe046d1:	0259      	s32i.n	a5, a2, 0
ffe046d3:	062d      	mov.n	a2, a6
ffe046d5:	fffc06        	j	ffe046c9 <HAL_TraxGetPostSize+0x25>

ffe046d8 <HAL_TraxSetPostSize>:
    invoke it to set Trax post size.
History:
    20141120    Tobey   create
------------------------------------------------------------------------------*/
void HAL_TraxSetPostSize(TRAX_CONTEXT *pContext, U32 ulDelayCount,  U8 ucUnitType)
{
ffe046d8:	f53a51        	l32r	a5, ffe01bc0 <_bss_table_end+0x244>
ffe046db:	e0c112        	addi	a1, a1, -32
ffe046de:	31c9      	s32i.n	a12, a1, 12
ffe046e0:	41d9      	s32i.n	a13, a1, 16
ffe046e2:	2109      	s32i.n	a0, a1, 8
ffe046e4:	03dd      	mov.n	a13, a3
------------------------------------------------------------------------------*/
TRAXCTRLREG HAL_GetTRAXCTRL(void)
{
    TRAXCTRLREG tTraxCtrl;
    
    *((U32 *)(&tTraxCtrl)) = XT_RER(TRAX_CTRL);
ffe046e6:	406500        	rer	a0, a5
    U16 usTraceSize;
    U32 ulDelayUnitCnt;
    TRAXCTRLREG tTraxCtrl;
    
    
    tTraxCtrl = HAL_GetTRAXCTRL();
ffe046e9:	314b      	addi.n	a3, a1, 4
ffe046eb:	0309      	s32i.n	a0, a3, 0
    switch(ucUnitType)
ffe046ed:	11c8      	l32i.n	a12, a1, 4
------------------------------------------------------------------------------*/
TRAXCTRLREG HAL_GetTRAXCTRL(void)
{
    TRAXCTRLREG tTraxCtrl;
    
    *((U32 *)(&tTraxCtrl)) = XT_RER(TRAX_CTRL);
ffe046ef:	ffad02        	movi	a0, 0xfffffdff
ffe046f2:	d4ac      	beqz.n	a4, ffe04723 <HAL_TraxSetPostSize+0x4b>
    U32 ulDelayUnitCnt;
    TRAXCTRLREG tTraxCtrl;
    
    
    tTraxCtrl = HAL_GetTRAXCTRL();
    switch(ucUnitType)
ffe046f4:	781426        	beqi	a4, 1, ffe04770 <HAL_TraxSetPostSize+0x98>
ffe046f7:	3f2426        	beqi	a4, 2, ffe0473a <HAL_TraxSetPostSize+0x62>
            ulDelayUnitCnt = ((ulDelayCount/100) * usTraceSize)/4; //((usDelayCount * (usTraceSize/16)) /25);
            break;
        }
        default:
        {
            DBG_Getch();
ffe046fa:	004ec5        	call0	ffe04be8 <DBG_Getch>

ffe046fd <HAL_TraxSetPostSize+0x25>:
        }
    }

    if (tTraxCtrl.bsCNTU == 0)
ffe046fd:	0cec97        	bbsi	a12, 9, ffe0470d <HAL_TraxSetPostSize+0x35>
    {
        ulDelayUnitCnt = (ulDelayUnitCnt < (POSTSIZE_ADJUST/4)) ? 0 : ulDelayUnitCnt - (POSTSIZE_ADJUST/4);
ffe04700:	058db6        	bltui	a13, 8, ffe04709 <HAL_TraxSetPostSize+0x31>
ffe04703:	f8cd02        	addi	a0, a13, -8
ffe04706:	000046        	j	ffe0470b <HAL_TraxSetPostSize+0x33>

ffe04709 <HAL_TraxSetPostSize+0x31>:
ffe04709:	000c      	movi.n	a0, 0
ffe0470b:	00dd      	mov.n	a13, a0
    }

    HAL_SetTRAXCTRL(&tTraxCtrl);
    HAL_SetDELAYCOUNT(ulDelayUnitCnt);
ffe0470d:	0d2d      	mov.n	a2, a13
History:
    20141120    Tobey   create
------------------------------------------------------------------------------*/
void HAL_SetTRAXCTRL(TRAXCTRLREG * pTRAXCTRLVal)
{
    XT_WER(*((U32 *)pTRAXCTRLVal), TRAX_CTRL);
ffe0470f:	f52c61        	l32r	a6, ffe01bc0 <_bss_table_end+0x244>
ffe04712:	4076c0        	wer	a12, a6
        ulDelayUnitCnt = (ulDelayUnitCnt < (POSTSIZE_ADJUST/4)) ? 0 : ulDelayUnitCnt - (POSTSIZE_ADJUST/4);
    }

    HAL_SetTRAXCTRL(&tTraxCtrl);
    HAL_SetDELAYCOUNT(ulDelayUnitCnt);
    return;
ffe04715:	41d8      	l32i.n	a13, a1, 16
ffe04717:	31c8      	l32i.n	a12, a1, 12
    {
        ulDelayUnitCnt = (ulDelayUnitCnt < (POSTSIZE_ADJUST/4)) ? 0 : ulDelayUnitCnt - (POSTSIZE_ADJUST/4);
    }

    HAL_SetTRAXCTRL(&tTraxCtrl);
    HAL_SetDELAYCOUNT(ulDelayUnitCnt);
ffe04719:	ffe585        	call0	ffe04574 <HAL_SetDELAYCOUNT>
    return;
ffe0471c:	2108      	l32i.n	a0, a1, 8
ffe0471e:	20c112        	addi	a1, a1, 32
ffe04721:	f00d      	ret.n

ffe04723 <HAL_TraxSetPostSize+0x4b>:
    switch(ucUnitType)
    {
        case 0:
        {
            tTraxCtrl.bsCNTU = 0;
            if(ulDelayCount >= 0x4000000)
ffe04723:	f52971        	l32r	a7, ffe01bc8 <_bss_table_end+0x24c>
    tTraxCtrl = HAL_GetTRAXCTRL();
    switch(ucUnitType)
    {
        case 0:
        {
            tTraxCtrl.bsCNTU = 0;
ffe04726:	10cc00        	and	a12, a12, a0
            if(ulDelayCount >= 0x4000000)
ffe04729:	08b7d7        	bgeu	a7, a13, ffe04735 <HAL_TraxSetPostSize+0x5d>
            {
                DBG_Printf("DelayCount by word is too large");
ffe0472c:	f52821        	l32r	a2, ffe01bcc <_bss_table_end+0x250>
ffe0472f:	007905        	call0	ffe04ec0 <dbg_printf>
                DBG_Getch();
ffe04732:	004b45        	call0	ffe04be8 <DBG_Getch>
ffe04735:	0d0d      	mov.n	a0, a13
ffe04737:	000bc6        	j	ffe0476a <HAL_TraxSetPostSize+0x92>

ffe0473a <HAL_TraxSetPostSize+0x62>:
            ulDelayUnitCnt = ulDelayCount;
            break;
        }
        case 2:
        {
            tTraxCtrl.bsCNTU = 0;
ffe0473a:	10cc00        	and	a12, a12, a0
            usTraceSize = HalGetTraceSize(pContext);
ffe0473d:	ffe585        	call0	ffe04598 <HalGetTraceSize..EC_1429880325>
ffe04740:	020d      	mov.n	a0, a2
            usMaxPercent = (0x4000000/usTraceSize)*100;
            if(ulDelayCount > usMaxPercent)
ffe04742:	f4fd81        	l32r	a8, ffe01b38 <_bss_table_end+0x1bc>
ffe04745:	64a092        	movi	a9, 100
ffe04748:	d28820        	quos	a8, a8, a2
ffe0474b:	c18890        	mul16u	a8, a8, a9
            break;
        }
        case 2:
        {
            tTraxCtrl.bsCNTU = 0;
            usTraceSize = HalGetTraceSize(pContext);
ffe0474e:	5129      	s32i.n	a2, a1, 20
            usMaxPercent = (0x4000000/usTraceSize)*100;
            if(ulDelayCount > usMaxPercent)
ffe04750:	f48080        	extui	a8, a8, 0, 16
ffe04753:	0ab8d7        	bgeu	a8, a13, ffe04761 <HAL_TraxSetPostSize+0x89>
            {
                DBG_Printf("DelayCount percent is too large");
ffe04756:	f51e21        	l32r	a2, ffe01bd0 <_bss_table_end+0x254>
ffe04759:	007645        	call0	ffe04ec0 <dbg_printf>
                DBG_Getch();
ffe0475c:	004885        	call0	ffe04be8 <DBG_Getch>
ffe0475f:	5108      	l32i.n	a0, a1, 20
            }

            /* convert to number of words. copy form cadence's driver*/
            ulDelayUnitCnt = ((ulDelayCount/100) * usTraceSize)/4; //((usDelayCount * (usTraceSize/16)) /25);
ffe04761:	64a092        	movi	a9, 100
ffe04764:	c29d90        	quou	a9, a13, a9
ffe04767:	820090        	mull	a0, a0, a9
ffe0476a:	41d200        	srli	a13, a0, 2
            break;
ffe0476d:	ffe306        	j	ffe046fd <HAL_TraxSetPostSize+0x25>

ffe04770 <HAL_TraxSetPostSize+0x98>:
            ulDelayUnitCnt = ulDelayCount/4;//by DW
            break;
        }
        case 1:
        {
            tTraxCtrl.bsCNTU = 1;
ffe04770:	00a2b2        	movi	a11, 0x200
            if (ulDelayCount >=0x01000000)
ffe04773:	f50ca1        	l32r	a10, ffe01ba4 <_bss_table_end+0x228>
            ulDelayUnitCnt = ulDelayCount/4;//by DW
            break;
        }
        case 1:
        {
            tTraxCtrl.bsCNTU = 1;
ffe04776:	20ccb0        	or	a12, a12, a11
            if (ulDelayCount >=0x01000000)
ffe04779:	80bad7        	bgeu	a10, a13, ffe046fd <HAL_TraxSetPostSize+0x25>
            {
                DBG_Printf("DelayCount by instruction is too large");
ffe0477c:	f51621        	l32r	a2, ffe01bd4 <_bss_table_end+0x258>
ffe0477f:	007405        	call0	ffe04ec0 <dbg_printf>
                DBG_Getch();
ffe04782:	004645        	call0	ffe04be8 <DBG_Getch>
ffe04785:	ffdd06        	j	ffe046fd <HAL_TraxSetPostSize+0x25>

ffe04788 <HAL_TraxSetSMPER>:
void HAL_TraxSetSMPER(U32 ulTraxSize)
{
    TRAXCTRLREG tTraxCtrl;
    tTraxCtrl = HAL_GetTRAXCTRL();

    if(ulTraxSize <= 256)
ffe04788:	f51471        	l32r	a7, ffe01bd8 <_bss_table_end+0x25c>
    invoke it selects the trace synchronization message period.
History:
    20141120    Tobey   create
------------------------------------------------------------------------------*/
void HAL_TraxSetSMPER(U32 ulTraxSize)
{
ffe0478b:	f50d61        	l32r	a6, ffe01bc0 <_bss_table_end+0x244>
ffe0478e:	f0c112        	addi	a1, a1, -16
    TRAXCTRLREG tTraxCtrl;
    tTraxCtrl = HAL_GetTRAXCTRL();
ffe04791:	914b      	addi.n	a9, a1, 4
------------------------------------------------------------------------------*/
TRAXCTRLREG HAL_GetTRAXCTRL(void)
{
    TRAXCTRLREG tTraxCtrl;
    
    *((U32 *)(&tTraxCtrl)) = XT_RER(TRAX_CTRL);
ffe04793:	406680        	rer	a8, a6
    20141120    Tobey   create
------------------------------------------------------------------------------*/
void HAL_TraxSetSMPER(U32 ulTraxSize)
{
    TRAXCTRLREG tTraxCtrl;
    tTraxCtrl = HAL_GetTRAXCTRL();
ffe04796:	0989      	s32i.n	a8, a9, 0

    if(ulTraxSize <= 256)
ffe04798:	1158      	l32i.n	a5, a1, 4
ffe0479a:	00a132        	movi	a3, 0x100
ffe0479d:	105570        	and	a5, a5, a7
ffe047a0:	0d3327        	bltu	a3, a2, ffe047b1 <HAL_TraxSetSMPER+0x29>
    {
        tTraxCtrl.bsSMPER = 5;
ffe047a3:	f50e21        	l32r	a2, ffe01bdc <_bss_table_end+0x260>

ffe047a6 <HAL_TraxSetSMPER+0x1e>:
    {
        tTraxCtrl.bsSMPER = 1;
    }

    HAL_SetTRAXCTRL(&tTraxCtrl);
    return;
ffe047a6:	10c112        	addi	a1, a1, 16
    TRAXCTRLREG tTraxCtrl;
    tTraxCtrl = HAL_GetTRAXCTRL();

    if(ulTraxSize <= 256)
    {
        tTraxCtrl.bsSMPER = 5;
ffe047a9:	20a520        	or	a10, a5, a2
History:
    20141120    Tobey   create
------------------------------------------------------------------------------*/
void HAL_SetTRAXCTRL(TRAXCTRLREG * pTRAXCTRLVal)
{
    XT_WER(*((U32 *)pTRAXCTRLVal), TRAX_CTRL);
ffe047ac:	4076a0        	wer	a10, a6
    {
        tTraxCtrl.bsSMPER = 1;
    }

    HAL_SetTRAXCTRL(&tTraxCtrl);
    return;
ffe047af:	f00d      	ret.n

ffe047b1 <HAL_TraxSetSMPER+0x29>:
    TRAXCTRLREG tTraxCtrl;
    tTraxCtrl = HAL_GetTRAXCTRL();

    if(ulTraxSize <= 256)
    {
        tTraxCtrl.bsSMPER = 5;
ffe047b1:	f4e571        	l32r	a7, ffe01b48 <_bss_table_end+0x1cc>
    }
    else if((ulTraxSize > 256) && (ulTraxSize <= 1024))
ffe047b4:	00a4b2        	movi	a11, 0x400
ffe047b7:	043b27        	bltu	a11, a2, ffe047bf <HAL_TraxSetSMPER+0x37>
ffe047ba:	072d      	mov.n	a2, a7
ffe047bc:	fff986        	j	ffe047a6 <HAL_TraxSetSMPER+0x1e>

ffe047bf <HAL_TraxSetSMPER+0x37>:
    {
        tTraxCtrl.bsSMPER = 4;
ffe047bf:	f4f081        	l32r	a8, ffe01b80 <_bss_table_end+0x204>
    }
    else if((ulTraxSize > 1024) && (ulTraxSize <= 4096))
ffe047c2:	053827        	bltu	a8, a2, ffe047cb <HAL_TraxSetSMPER+0x43>
    {
        tTraxCtrl.bsSMPER = 3;
ffe047c5:	f50621        	l32r	a2, ffe01be0 <_bss_table_end+0x264>
ffe047c8:	fff686        	j	ffe047a6 <HAL_TraxSetSMPER+0x1e>

ffe047cb <HAL_TraxSetSMPER+0x43>:
    }
    else if((ulTraxSize > 4096) && (ulTraxSize <= 16384))
ffe047cb:	053727        	bltu	a7, a2, ffe047d4 <HAL_TraxSetSMPER+0x4c>
    {
        tTraxCtrl.bsSMPER = 2;
ffe047ce:	f4ed21        	l32r	a2, ffe01b84 <_bss_table_end+0x208>
ffe047d1:	fff446        	j	ffe047a6 <HAL_TraxSetSMPER+0x1e>

ffe047d4 <HAL_TraxSetSMPER+0x4c>:
ffe047d4:	082d      	mov.n	a2, a8
ffe047d6:	fff306        	j	ffe047a6 <HAL_TraxSetSMPER+0x1e>

ffe047d9 <HAL_TraxSetSMPER+0x51>:
ffe047d9:	000000                                        ...

ffe047dc <HAL_TraxGetRamBoundary>:
U16 HAL_GetMEMSTARTADDR(void)
{
    U16 usMemStartAddr;
    U32 ulMemAddrTemp;
    
    ulMemAddrTemp = XT_RER(TRAX_MEMSTARTADDR);
ffe047dc:	f4f561        	l32r	a6, ffe01bb0 <_bss_table_end+0x234>
ffe047df:	406650        	rer	a5, a6
U16 HAL_GetMEMENDADDR(void)
{
    U16 usMemEndAddr;
    U32 ulMemAddrTemp;
    
    ulMemAddrTemp = XT_RER(TRAX_MEMENDADDR);
ffe047e2:	f4f461        	l32r	a6, ffe01bb4 <_bss_table_end+0x238>
History:
    20141120    Tobey   create
------------------------------------------------------------------------------*/
void HAL_TraxGetRamBoundary(U16 * pStartAddr, U16 * pEndAddr)
{    
    *pStartAddr = HAL_GetMEMSTARTADDR();
ffe047e5:	c45050        	extui	a5, a5, 0, 13
U16 HAL_GetMEMENDADDR(void)
{
    U16 usMemEndAddr;
    U32 ulMemAddrTemp;
    
    ulMemAddrTemp = XT_RER(TRAX_MEMENDADDR);
ffe047e8:	406640        	rer	a4, a6
History:
    20141120    Tobey   create
------------------------------------------------------------------------------*/
void HAL_TraxGetRamBoundary(U16 * pStartAddr, U16 * pEndAddr)
{    
    *pStartAddr = HAL_GetMEMSTARTADDR();
ffe047eb:	005252        	s16i	a5, a2, 0
    *pEndAddr = HAL_GetMEMENDADDR();
ffe047ee:	c44040        	extui	a4, a4, 0, 13
ffe047f1:	005342        	s16i	a4, a3, 0
 
    return;
ffe047f4:	f00d      	ret.n

ffe047f6 <HAL_TraxGetRamBoundary+0x1a>:
	...

ffe047f8 <HAL_TraxSetRamBoundary>:
    invoke it to set TraceRAM trace boundary
History:
    20141120    Tobey   create
------------------------------------------------------------------------------*/
void HAL_TraxSetRamBoundary(TRAX_CONTEXT *pContext, U16 usStartAddr, U16 usEndAddr)
{
ffe047f8:	f0c112        	addi	a1, a1, -16
ffe047fb:	21d9      	s32i.n	a13, a1, 8
ffe047fd:	0109      	s32i.n	a0, a1, 0
ffe047ff:	31e9      	s32i.n	a14, a1, 12
ffe04801:	11c9      	s32i.n	a12, a1, 4
ffe04803:	02ed      	mov.n	a14, a2
ffe04805:	03cd      	mov.n	a12, a3
    S16 ssTraceSize;
    U16 usStartAddrRd;
    U16 usEndAddrRd;
    if (( usStartAddr > (pContext->ulTraxTramSize >> 2) - 1)
ffe04807:	1208      	l32i.n	a0, a2, 4
    invoke it to set TraceRAM trace boundary
History:
    20141120    Tobey   create
------------------------------------------------------------------------------*/
void HAL_TraxSetRamBoundary(TRAX_CONTEXT *pContext, U16 usStartAddr, U16 usEndAddr)
{
ffe04809:	04dd      	mov.n	a13, a4
    S16 ssTraceSize;
    U16 usStartAddrRd;
    U16 usEndAddrRd;
    if (( usStartAddr > (pContext->ulTraxTramSize >> 2) - 1)
ffe0480b:	410200        	srli	a0, a0, 2
ffe0480e:	000b      	addi.n	a0, a0, -1
ffe04810:	023037        	bltu	a0, a3, ffe04816 <HAL_TraxSetRamBoundary+0x1e>
ffe04813:	08b047        	bgeu	a0, a4, ffe0481f <HAL_TraxSetRamBoundary+0x27>

ffe04816 <HAL_TraxSetRamBoundary+0x1e>:
       || ( usEndAddr > (pContext->ulTraxTramSize >> 2) - 1))
    {
        DBG_Printf("trax addr is out of range\n");
ffe04816:	f4f321        	l32r	a2, ffe01be4 <_bss_table_end+0x268>
ffe04819:	006a45        	call0	ffe04ec0 <dbg_printf>
        DBG_Getch();
ffe0481c:	003c85        	call0	ffe04be8 <DBG_Getch>
    }
    
    ssTraceSize = (S16)usEndAddr - (S16)usStartAddr;
ffe0481f:	c02dc0        	sub	a2, a13, a12
ffe04822:	230280        	sext	a0, a2, 15
    if (ssTraceSize < 0)
ffe04825:	0862f7        	bbci	a2, 15, ffe04831 <HAL_TraxSetRamBoundary+0x39>
    {
       ssTraceSize += ((pContext->ulTraxTramSize >> 2) - 1);
ffe04828:	1e28      	l32i.n	a2, a14, 4
ffe0482a:	412220        	srli	a2, a2, 2
ffe0482d:	002a      	add.n	a0, a0, a2
ffe0482f:	000b      	addi.n	a0, a0, -1
    }
    /* In terms of bytes */
    ssTraceSize = (ssTraceSize + 1) << 2;
    
    if (ssTraceSize < TRAX_MIN_TRACEMEM)
ffe04831:	301b      	addi.n	a3, a0, 1
ffe04833:	1133e0        	slli	a3, a3, 2
ffe04836:	233380        	sext	a3, a3, 15
ffe04839:	08d3e6        	bgei	a3, 64, ffe04845 <HAL_TraxSetRamBoundary+0x4d>
    {
        DBG_Printf("trax size setting error\n");
ffe0483c:	f4eb21        	l32r	a2, ffe01be8 <_bss_table_end+0x26c>
ffe0483f:	006805        	call0	ffe04ec0 <dbg_printf>
        DBG_Getch();
ffe04842:	003a45        	call0	ffe04be8 <DBG_Getch>
    }

    if(FALSE == HAL_TraxIsTraceActive())
ffe04845:	ffde05        	call0	ffe04628 <HAL_TraxIsTraceActive>
     {
        DBG_Getch();
        DBG_Printf("trace boundary setting fail!\n");
     }

    return;
ffe04848:	31e8      	l32i.n	a14, a1, 12
ffe0484a:	b2cc      	bnez.n	a2, ffe04859 <HAL_TraxSetRamBoundary+0x61>
        DBG_Getch();
    }

    if(FALSE == HAL_TraxIsTraceActive())
    {
        HAL_SetMEMSTARTADDR(usStartAddr);
ffe0484c:	0c2d      	mov.n	a2, a12
ffe0484e:	ffda85        	call0	ffe045f8 <HAL_SetMEMSTARTADDR>
        HAL_SetMEMENDADDR(usEndAddr);
ffe04851:	0d2d      	mov.n	a2, a13
ffe04853:	ffd745        	call0	ffe045c8 <HAL_SetMEMENDADDR>
ffe04856:	000146        	j	ffe0485f <HAL_TraxSetRamBoundary+0x67>

ffe04859 <HAL_TraxSetRamBoundary+0x61>:
    }
    else
    {
        DBG_Printf("Trax is busy, can't set ram boundary!\n");
ffe04859:	f4e421        	l32r	a2, ffe01bec <_bss_table_end+0x270>
ffe0485c:	006605        	call0	ffe04ec0 <dbg_printf>
U16 HAL_GetMEMSTARTADDR(void)
{
    U16 usMemStartAddr;
    U32 ulMemAddrTemp;
    
    ulMemAddrTemp = XT_RER(TRAX_MEMSTARTADDR);
ffe0485f:	f4d461        	l32r	a6, ffe01bb0 <_bss_table_end+0x234>
U16 HAL_GetMEMENDADDR(void)
{
    U16 usMemEndAddr;
    U32 ulMemAddrTemp;
    
    ulMemAddrTemp = XT_RER(TRAX_MEMENDADDR);
ffe04862:	f4d451        	l32r	a5, ffe01bb4 <_bss_table_end+0x238>
U16 HAL_GetMEMSTARTADDR(void)
{
    U16 usMemStartAddr;
    U32 ulMemAddrTemp;
    
    ulMemAddrTemp = XT_RER(TRAX_MEMSTARTADDR);
ffe04865:	406640        	rer	a4, a6
U16 HAL_GetMEMENDADDR(void)
{
    U16 usMemEndAddr;
    U32 ulMemAddrTemp;
    
    ulMemAddrTemp = XT_RER(TRAX_MEMENDADDR);
ffe04868:	406500        	rer	a0, a5
      * of the trace RAM are set to default, so there is a need to read them back
      * and check */
     usStartAddrRd = HAL_GetMEMSTARTADDR();
     usEndAddrRd = HAL_GetMEMENDADDR();
    
     if ((usStartAddrRd != usStartAddr) || (usEndAddrRd != usEndAddr))
ffe0486b:	c44040        	extui	a4, a4, 0, 13
ffe0486e:	059c47        	bne	a12, a4, ffe04877 <HAL_TraxSetRamBoundary+0x7f>
ffe04871:	c47000        	extui	a7, a0, 0, 13
ffe04874:	081d77        	beq	a13, a7, ffe04880 <HAL_TraxSetRamBoundary+0x88>
     {
        DBG_Getch();
ffe04877:	003705        	call0	ffe04be8 <DBG_Getch>
        DBG_Printf("trace boundary setting fail!\n");
ffe0487a:	f4dd21        	l32r	a2, ffe01bf0 <_bss_table_end+0x274>
ffe0487d:	006405        	call0	ffe04ec0 <dbg_printf>
     }

    return;
ffe04880:	11c8      	l32i.n	a12, a1, 4
ffe04882:	21d8      	l32i.n	a13, a1, 8
ffe04884:	0108      	l32i.n	a0, a1, 0
ffe04886:	10c112        	addi	a1, a1, 16
ffe04889:	f00d      	ret.n

ffe0488b <HAL_TraxSetRamBoundary+0x93>:
	...

ffe0488c <HAL_TraxInitERI>:
    20141120    Tobey   create
------------------------------------------------------------------------------*/
TRAXIDREG HAL_GetTRAXID(void)
{
    TRAXIDREG tTraxId;
    *((U32 *)(&tTraxId)) = XT_RER(TRAX_ID);
ffe0488c:	f43f31        	l32r	a3, ffe01988 <_bss_table_end+0xc>
    mcu invoke it to Init Trax via ERI.
History:
    20141120    Tobey   create
------------------------------------------------------------------------------*/
void HAL_TraxInitERI(TRAX_CONTEXT *pContext)
{
ffe0488f:	e0c112        	addi	a1, a1, -32
ffe04892:	41d9      	s32i.n	a13, a1, 16
ffe04894:	2109      	s32i.n	a0, a1, 8
ffe04896:	31c9      	s32i.n	a12, a1, 12
    20141120    Tobey   create
------------------------------------------------------------------------------*/
TRAXIDREG HAL_GetTRAXID(void)
{
    TRAXIDREG tTraxId;
    *((U32 *)(&tTraxId)) = XT_RER(TRAX_ID);
ffe04898:	406300        	rer	a0, a3
    mcu invoke it to Init Trax via ERI.
History:
    20141120    Tobey   create
------------------------------------------------------------------------------*/
void HAL_TraxInitERI(TRAX_CONTEXT *pContext)
{
ffe0489b:	02cd      	mov.n	a12, a2
    U32 ulRamSize;
    TRAXIDREG tTraxId;

    tTraxId = HAL_GetTRAXID();
ffe0489d:	214b      	addi.n	a2, a1, 4
ffe0489f:	0209      	s32i.n	a0, a2, 0

    if((0 == *(U32 *)&tTraxId) || (INVALID_8F== *(U32 *)&tTraxId))
ffe048a1:	11d8      	l32i.n	a13, a1, 4
ffe048a3:	1d8c      	beqz.n	a13, ffe048a8 <HAL_TraxInitERI+0x1c>
ffe048a5:	020d66        	bnei	a13, -1, ffe048ab <HAL_TraxInitERI+0x1f>

ffe048a8 <HAL_TraxInitERI+0x1c>:
    {
        DBG_Getch();
ffe048a8:	0033c5        	call0	ffe04be8 <DBG_Getch>
    }

    pContext->usTraxVersion= (tTraxId.bsMAJVER<<3) | tTraxId.bsMINVER;
ffe048ab:	e551d0        	extui	a5, a13, 17, 15
ffe048ae:	3544d0        	extui	a4, a13, 20, 4
ffe048b1:	1144d0        	slli	a4, a4, 3
ffe048b4:	020544        	insbits	a4, a5, 0, 2
ffe048b7:	005c42        	s16i	a4, a12, 0
    ulRamSize = HAL_TraxGetTraceRamSize();
ffe048ba:	ffd845        	call0	ffe04640 <HAL_TraxGetTraceRamSize>
ffe048bd:	02dd      	mov.n	a13, a2

    if ((ulRamSize < TRAXRAM_SIZE_MIN) || (ulRamSize > TRAXRAM_SIZE_MAX))
ffe048bf:	05e2b6        	bltui	a2, 128, ffe048c8 <HAL_TraxInitERI+0x3c>
ffe048c2:	f45551        	l32r	a5, ffe01a18 <_bss_table_end+0x9c>
ffe048c5:	08b527        	bgeu	a5, a2, ffe048d1 <HAL_TraxInitERI+0x45>
    {
        DBG_Getch();
ffe048c8:	0031c5        	call0	ffe04be8 <DBG_Getch>
        DBG_Printf("Trax Ram Size error\n");
ffe048cb:	f4ca21        	l32r	a2, ffe01bf4 <_bss_table_end+0x278>
ffe048ce:	005f05        	call0	ffe04ec0 <dbg_printf>

    /* Lets assume initially that the total memory traced is
    * the trace RAM size */
    pContext->ulTotalMemlen= pContext->ulTraxTramSize;  
    
    return;
ffe048d1:	2108      	l32i.n	a0, a1, 8
    {
        DBG_Getch();
        DBG_Printf("Trax Ram Size error\n");
    }

    pContext->ulTraxTramSize= ulRamSize;
ffe048d3:	1cd9      	s32i.n	a13, a12, 4

    pContext->usAddrReadLast= 0;

    /* Lets assume initially that the total memory traced is
    * the trace RAM size */
    pContext->ulTotalMemlen= pContext->ulTraxTramSize;  
ffe048d5:	4cd9      	s32i.n	a13, a12, 16

    pContext->ulTraxTramSize= ulRamSize;

    pContext->ulFlags= TRAX_FHEADF_OCD_ENABLED;

    pContext->usAddrReadLast= 0;
ffe048d7:	060c      	movi.n	a6, 0
        DBG_Printf("Trax Ram Size error\n");
    }

    pContext->ulTraxTramSize= ulRamSize;

    pContext->ulFlags= TRAX_FHEADF_OCD_ENABLED;
ffe048d9:	170c      	movi.n	a7, 1
ffe048db:	2c79      	s32i.n	a7, a12, 8

    pContext->usAddrReadLast= 0;
ffe048dd:	065c62        	s16i	a6, a12, 12

    /* Lets assume initially that the total memory traced is
    * the trace RAM size */
    pContext->ulTotalMemlen= pContext->ulTraxTramSize;  
    
    return;
ffe048e0:	41d8      	l32i.n	a13, a1, 16
ffe048e2:	31c8      	l32i.n	a12, a1, 12
ffe048e4:	20c112        	addi	a1, a1, 32
ffe048e7:	f00d      	ret.n

ffe048e9 <HAL_TraxInitERI+0x5d>:
ffe048e9:	000000                                        ...

ffe048ec <HAL_CofigTraceBuffMutiMcu>:
void HAL_CofigTraceBuffMutiMcu(void)
{
    U32 ulTmp = 0;
#ifdef TRACE_MXDSRAM1_3
    ulTmp |= 2<<8;
    rGLB_24 |= ulTmp;
ffe048ec:	00a242        	movi	a4, 0x200
    invoke it to configure 3 mcu use trax memory.
History:
    20141120    Tobey   create
------------------------------------------------------------------------------*/
void HAL_CofigTraceBuffMutiMcu(void)
{
ffe048ef:	f46e31        	l32r	a3, ffe01aa8 <_bss_table_end+0x12c>
    U32 ulTmp = 0;
#ifdef TRACE_MXDSRAM1_3
    ulTmp |= 2<<8;
    rGLB_24 |= ulTmp;
ffe048f2:	0020c0        	memw
ffe048f5:	892322        	l32i	a2, a3, 0x224
ffe048f8:	202240        	or	a2, a2, a4
ffe048fb:	0020c0        	memw
ffe048fe:	896322        	s32i	a2, a3, 0x224

    ulTmp |= 2<<3;
    rGLB_24 |= ulTmp;
#endif

    return;
ffe04901:	f00d      	ret.n

ffe04903 <HAL_CofigTraceBuffMutiMcu+0x17>:
	...

ffe04904 <HAL_MemZero>:
****************************************************************************/
void HAL_MemZero(U32* TargetAddr,U32 LengthDW)
{
    U32 i;

    for (i = 0 ; i < LengthDW; i++)
ffe04904:	050c      	movi.n	a5, 0
ffe04906:	039376        	loopnez	a3, ffe0490d <HAL_MemZero+0x9>
    {
        *TargetAddr++ = 0;
ffe04909:	0259      	s32i.n	a5, a2, 0
ffe0490b:	224b      	addi.n	a2, a2, 4

ffe0490d <HAL_MemZero+0x9>:
    }
}
ffe0490d:	f00d      	ret.n

ffe0490f <HAL_MemZero+0xb>:
	...

ffe04910 <HAL_StrapNfcType>:
    ROM boot program may initialize NFC into matched mode according PINS
History : 2014/10/23 Victor Zhang  Create 
*************************************************/

U8  HAL_StrapNfcType(void)
{
ffe04910:	f41d31        	l32r	a3, ffe01984 <_bss_table_end+0x8>
ffe04913:	0020c0        	memw
ffe04916:	150c      	movi.n	a5, 1
ffe04918:	e368      	l32i.n	a6, a3, 56
ffe0491a:	020c      	movi.n	a2, 0
ffe0491c:	046460        	extui	a6, a6, 4, 1
ffe0491f:	832560        	moveqz	a2, a5, a6
    U8 ucType;
    ucType = 0;
    ucType |= HAL_StrapNfcIsAsync();
    ucType |= (HAL_StrapNfcIsTLC() << 1);
ffe04922:	0020c0        	memw
ffe04925:	e348      	l32i.n	a4, a3, 56
ffe04927:	044540        	extui	a4, a4, 5, 1
    ucType |= (HAL_StrapNfcIsOnfi() << 2);
ffe0492a:	0020c0        	memw
ffe0492d:	e338      	l32i.n	a3, a3, 56
    return ucType;
ffe0492f:	1144f0        	slli	a4, a4, 1
ffe04932:	202240        	or	a2, a2, a4
{
    U8 ucType;
    ucType = 0;
    ucType |= HAL_StrapNfcIsAsync();
    ucType |= (HAL_StrapNfcIsTLC() << 1);
    ucType |= (HAL_StrapNfcIsOnfi() << 2);
ffe04935:	043630        	extui	a3, a3, 6, 1
    return ucType;
ffe04938:	1133e0        	slli	a3, a3, 2
ffe0493b:	202230        	or	a2, a2, a3
ffe0493e:	742020        	extui	a2, a2, 0, 8
ffe04941:	f00d      	ret.n

ffe04943 <HAL_StrapNfcType+0x33>:
	...

ffe04944 <HalNfcTimingInit..G_1429880325>:
    standing for worm boot . 
*************************************************/

LOCAL void HalNfcTimingInit(void)
{
    gPageReadCmdIndex = NF_RCMD_READ_MLC_1PLN;
ffe04944:	220c      	movi.n	a2, 2
    worm boot bit belongs to pmu scratch register 2 (PMU_2c),we define the bit[0]
    standing for worm boot . 
*************************************************/

LOCAL void HalNfcTimingInit(void)
{
ffe04946:	d0c112        	addi	a1, a1, -48
ffe04949:	a1c9      	s32i.n	a12, a1, 40
ffe0494b:	f40ec1        	l32r	a12, ffe01984 <_bss_table_end+0x8>
ffe0494e:	9109      	s32i.n	a0, a1, 36
    gPageReadCmdIndex = NF_RCMD_READ_MLC_1PLN;
    if (FALSE == HAL_StrapIsSetHwFrEfuse())
ffe04950:	dc08      	l32i.n	a0, a12, 52
    standing for worm boot . 
*************************************************/

LOCAL void HalNfcTimingInit(void)
{
    gPageReadCmdIndex = NF_RCMD_READ_MLC_1PLN;
ffe04952:	144c22        	s8i	a2, a12, 20
    if (FALSE == HAL_StrapIsSetHwFrEfuse())
ffe04955:	13d056        	bnez	a0, ffe04a96 <HalNfcTimingInit..G_1429880325+0x152>
    {
        NFC_REG_CONFIG* pReg ;
        U8 ulNfcIndex = HAL_StrapNfcType();
ffe04958:	fffb45        	call0	ffe04910 <HAL_StrapNfcType>
ffe0495b:	023d      	mov.n	a3, a2
ffe0495d:	1129      	s32i.n	a2, a1, 4

        DBG_Printf("NFC type is %d,",ulNfcIndex);
ffe0495f:	f4a621        	l32r	a2, ffe01bf8 <_bss_table_end+0x27c>
ffe04962:	0055c5        	call0	ffe04ec0 <dbg_printf>
        DBG_Printf(" %s ",(TRUE == HAL_StrapNfcIsAsync())?"ASYNC":"SYNC");
ffe04965:	0020c0        	memw
ffe04968:	f4a721        	l32r	a2, ffe01c04 <_bss_table_end+0x288>
ffe0496b:	f4a441        	l32r	a4, ffe01bfc <_bss_table_end+0x280>
ffe0496e:	f4a431        	l32r	a3, ffe01c00 <_bss_table_end+0x284>
ffe04971:	160c      	movi.n	a6, 1
ffe04973:	ec78      	l32i.n	a7, a12, 56
ffe04975:	050c      	movi.n	a5, 0
ffe04977:	047470        	extui	a7, a7, 4, 1
ffe0497a:	835670        	moveqz	a5, a6, a7
ffe0497d:	550b      	addi.n	a5, a5, -1
ffe0497f:	933450        	movnez	a3, a4, a5
ffe04982:	0053c5        	call0	ffe04ec0 <dbg_printf>
        DBG_Printf(" %s ",(TRUE == HAL_StrapNfcIsOnfi())? "ONFI":"TOGGLE");
ffe04985:	0020c0        	memw
ffe04988:	ec88      	l32i.n	a8, a12, 56
ffe0498a:	f49f31        	l32r	a3, ffe01c08 <_bss_table_end+0x28c>
ffe0498d:	048680        	extui	a8, a8, 6, 1
ffe04990:	10b816        	beqz	a8, ffe04a9f <HalNfcTimingInit..G_1429880325+0x15b>
ffe04993:	0042c6        	j	ffe04aa2 <HalNfcTimingInit..G_1429880325+0x15e>

ffe04996 <HalNfcTimingInit..G_1429880325+0x52>:
        DBG_Printf(" %s \n",(TRUE == HAL_StrapNfcIsTLC())?"TLC":"MLC");
ffe04996:	f49d31        	l32r	a3, ffe01c0c <_bss_table_end+0x290>
ffe04999:	f49d21        	l32r	a2, ffe01c10 <_bss_table_end+0x294>
ffe0499c:	005205        	call0	ffe04ec0 <dbg_printf>

        pReg = (NFC_REG_CONFIG*)&l_aNfcInitTable[ulNfcIndex];

        DBG_TRACE(TRACE_NFC_INIT);
ffe0499f:	f49d01        	l32r	a0, ffe01c14 <_bss_table_end+0x298>
ffe049a2:	f436a1        	l32r	a10, ffe01a7c <_bss_table_end+0x100>
ffe049a5:	f47ec1        	l32r	a12, ffe01ba0 <_bss_table_end+0x224>
ffe049a8:	f440b1        	l32r	a11, ffe01aa8 <_bss_table_end+0x12c>
ffe049ab:	0020c0        	memw
ffe049ae:	a06b02        	s32i	a0, a11, 0x280
        DBG_TRACE(ulNfcIndex);
ffe049b1:	0020c0        	memw
ffe049b4:	1198      	l32i.n	a9, a1, 4
ffe049b6:	a06b92        	s32i	a9, a11, 0x280

        rNFC(0x0) = pReg->NFC00;
ffe049b9:	f444b1        	l32r	a11, ffe01acc <_bss_table_end+0x150>
ffe049bc:	b09990        	addx8	a9, a9, a9
ffe049bf:	a099b0        	addx4	a9, a9, a11
ffe049c2:	0199      	s32i.n	a9, a1, 0
ffe049c4:	182942        	l32i	a4, a9, 96
ffe049c7:	0020c0        	memw
ffe049ca:	806c42        	s32i	a4, a12, 0x200
        rNFC(0x4) = pReg->NFC04;
ffe049cd:	192962        	l32i	a6, a9, 100
ffe049d0:	2169      	s32i.n	a6, a1, 8
ffe049d2:	0020c0        	memw
ffe049d5:	816c62        	s32i	a6, a12, 0x204
        rNFC(0x8) = pReg->NFC08;
ffe049d8:	1a2952        	l32i	a5, a9, 104
ffe049db:	3159      	s32i.n	a5, a1, 12
ffe049dd:	0020c0        	memw
ffe049e0:	826c52        	s32i	a5, a12, 0x208
        rNFC(0x2c)= pReg->NFC2C;
ffe049e3:	1b2932        	l32i	a3, a9, 108
ffe049e6:	4139      	s32i.n	a3, a1, 16
ffe049e8:	0020c0        	memw
ffe049eb:	8b6c32        	s32i	a3, a12, 0x22c
        rNFC(0x30)= pReg->NFC30;
ffe049ee:	1c2922        	l32i	a2, a9, 112
ffe049f1:	5129      	s32i.n	a2, a1, 20
ffe049f3:	0020c0        	memw
ffe049f6:	8c6c22        	s32i	a2, a12, 0x230
        rNFC(0x80)= pReg->NFC80;
ffe049f9:	1d2902        	l32i	a0, a9, 116
ffe049fc:	6109      	s32i.n	a0, a1, 24
ffe049fe:	0020c0        	memw
ffe04a01:	a06c02        	s32i	a0, a12, 0x280
        rNFC(0x88)= pReg->NFC88;
ffe04a04:	1e29b2        	l32i	a11, a9, 120
ffe04a07:	71b9      	s32i.n	a11, a1, 28
ffe04a09:	0020c0        	memw
ffe04a0c:	a26cb2        	s32i	a11, a12, 0x288
        rPMU(0x20)= pReg->PMU20;
ffe04a0f:	1f2992        	l32i	a9, a9, 124
ffe04a12:	8199      	s32i.n	a9, a1, 32
ffe04a14:	0020c0        	memw
ffe04a17:	486a92        	s32i	a9, a10, 0x120

        DBG_Printf("NFC 00 : 0x%x -- 0x%x\n",rNFC(0x0),pReg->NFC00);
ffe04a1a:	f47f21        	l32r	a2, ffe01c18 <_bss_table_end+0x29c>
ffe04a1d:	0020c0        	memw
ffe04a20:	802c32        	l32i	a3, a12, 0x200
ffe04a23:	0049c5        	call0	ffe04ec0 <dbg_printf>
        DBG_Printf("NFC 04 : 0x%x -- 0x%x\n",rNFC(0x4),pReg->NFC04);
ffe04a26:	f47d21        	l32r	a2, ffe01c1c <_bss_table_end+0x2a0>
ffe04a29:	0020c0        	memw
ffe04a2c:	812c32        	l32i	a3, a12, 0x204
ffe04a2f:	2148      	l32i.n	a4, a1, 8
ffe04a31:	0048c5        	call0	ffe04ec0 <dbg_printf>
        DBG_Printf("NFC 08 : 0x%x -- 0x%x\n",rNFC(0x8),pReg->NFC08);
ffe04a34:	f47b21        	l32r	a2, ffe01c20 <_bss_table_end+0x2a4>
ffe04a37:	0020c0        	memw
ffe04a3a:	822c32        	l32i	a3, a12, 0x208
ffe04a3d:	3148      	l32i.n	a4, a1, 12
ffe04a3f:	004805        	call0	ffe04ec0 <dbg_printf>
        DBG_Printf("NFC 2c : 0x%x -- 0x%x\n",rNFC(0x2c),pReg->NFC2C);
ffe04a42:	f47821        	l32r	a2, ffe01c24 <_bss_table_end+0x2a8>
ffe04a45:	0020c0        	memw
ffe04a48:	8b2c32        	l32i	a3, a12, 0x22c
ffe04a4b:	4148      	l32i.n	a4, a1, 16
ffe04a4d:	004705        	call0	ffe04ec0 <dbg_printf>
        DBG_Printf("NFC 30 : 0x%x -- 0x%x\n",rNFC(0x30),pReg->NFC30);
ffe04a50:	f47621        	l32r	a2, ffe01c28 <_bss_table_end+0x2ac>
ffe04a53:	0020c0        	memw
ffe04a56:	8c2c32        	l32i	a3, a12, 0x230
ffe04a59:	5148      	l32i.n	a4, a1, 20
ffe04a5b:	004645        	call0	ffe04ec0 <dbg_printf>
        DBG_Printf("NFC 80 : 0x%x -- 0x%x\n",rNFC(0x80),pReg->NFC80);
ffe04a5e:	f47321        	l32r	a2, ffe01c2c <_bss_table_end+0x2b0>
ffe04a61:	0020c0        	memw
ffe04a64:	a02c32        	l32i	a3, a12, 0x280
ffe04a67:	6148      	l32i.n	a4, a1, 24
ffe04a69:	004545        	call0	ffe04ec0 <dbg_printf>
        DBG_Printf("NFC 88 : 0x%x -- 0x%x\n",rNFC(0x88),pReg->NFC88);
ffe04a6c:	f47121        	l32r	a2, ffe01c30 <_bss_table_end+0x2b4>
ffe04a6f:	0020c0        	memw
ffe04a72:	a22c32        	l32i	a3, a12, 0x288
ffe04a75:	7148      	l32i.n	a4, a1, 28
ffe04a77:	01c8      	l32i.n	a12, a1, 0
ffe04a79:	004445        	call0	ffe04ec0 <dbg_printf>
        DBG_Printf("PMU 20 : 0x%x -- 0x%x\n",rPMU(0x20),pReg->PMU20);
ffe04a7c:	f46e21        	l32r	a2, ffe01c34 <_bss_table_end+0x2b8>
ffe04a7f:	0020c0        	memw
ffe04a82:	f3fe31        	l32r	a3, ffe01a7c <_bss_table_end+0x100>
ffe04a85:	8148      	l32i.n	a4, a1, 32
ffe04a87:	482332        	l32i	a3, a3, 0x120
ffe04a8a:	004345        	call0	ffe04ec0 <dbg_printf>
        gPageReadCmdIndex = pReg->RCmdIndex;
ffe04a8d:	f3bd51        	l32r	a5, ffe01984 <_bss_table_end+0x8>
ffe04a90:	202c42        	l32i	a4, a12, 128
ffe04a93:	144542        	s8i	a4, a5, 20
    }    
}
ffe04a96:	a1c8      	l32i.n	a12, a1, 40
ffe04a98:	9108      	l32i.n	a0, a1, 36
ffe04a9a:	30c112        	addi	a1, a1, 48
ffe04a9d:	f00d      	ret.n

ffe04a9f <HalNfcTimingInit..G_1429880325+0x15b>:
        NFC_REG_CONFIG* pReg ;
        U8 ulNfcIndex = HAL_StrapNfcType();

        DBG_Printf("NFC type is %d,",ulNfcIndex);
        DBG_Printf(" %s ",(TRUE == HAL_StrapNfcIsAsync())?"ASYNC":"SYNC");
        DBG_Printf(" %s ",(TRUE == HAL_StrapNfcIsOnfi())? "ONFI":"TOGGLE");
ffe04a9f:	f46631        	l32r	a3, ffe01c38 <_bss_table_end+0x2bc>
ffe04aa2:	f45821        	l32r	a2, ffe01c04 <_bss_table_end+0x288>
ffe04aa5:	004185        	call0	ffe04ec0 <dbg_printf>
        DBG_Printf(" %s \n",(TRUE == HAL_StrapNfcIsTLC())?"TLC":"MLC");
ffe04aa8:	0020c0        	memw
ffe04aab:	ec68      	l32i.n	a6, a12, 56
ffe04aad:	f46331        	l32r	a3, ffe01c3c <_bss_table_end+0x2c0>
ffe04ab0:	046560        	extui	a6, a6, 5, 1
ffe04ab3:	edf616        	beqz	a6, ffe04996 <HalNfcTimingInit..G_1429880325+0x52>
ffe04ab6:	ffb7c6        	j	ffe04999 <HalNfcTimingInit..G_1429880325+0x55>

ffe04ab9 <HalNfcTimingInit..G_1429880325+0x175>:
ffe04ab9:	000000                                        ...

ffe04abc <HAL_NfcResetPu>:
Description:
    Issue reset pu requeset  
*************************************************/

GLOBAL BOOL HAL_NfcResetPu(U8 ucLogPu)
{
ffe04abc:	f0c112        	addi	a1, a1, -16
ffe04abf:	11c9      	s32i.n	a12, a1, 4
ffe04ac1:	21d9      	s32i.n	a13, a1, 8
ffe04ac3:	0109      	s32i.n	a0, a1, 0
ffe04ac5:	02dd      	mov.n	a13, a2
    volatile NFCQ_ENTRY *pNfcqEntry;
    U8 ucPhyPu = HAL_NfcGetPhyPu(ucLogPu);
ffe04ac7:	ff8385        	call0	ffe04300 <HAL_NfcGetPhyPu>
ffe04aca:	02cd      	mov.n	a12, a2
    U8 ucCeSel = HAL_NfcGetCeSel(ucLogPu);
ffe04acc:	0d2d      	mov.n	a2, a13
ffe04ace:	ff81c5        	call0	ffe042ec <HAL_NfcGetCeSel>
ffe04ad1:	f3ac61        	l32r	a6, ffe01984 <_bss_table_end+0x8>
ffe04ad4:	02dd      	mov.n	a13, a2
ffe04ad6:	4608      	l32i.n	a0, a6, 16
ffe04ad8:	113ce0        	slli	a3, a12, 2
ffe04adb:	a00c00        	addx4	a0, a12, a0

ffe04ade <HAL_NfcResetPu+0x22>:
    
    while (FALSE == HalNfcGetPuEmpty(ucPhyPu))
ffe04ade:	0020c0        	memw
ffe04ae1:	000022        	l8ui	a2, a0, 0
ffe04ae4:	f66227        	bbci	a2, 2, ffe04ade <HAL_NfcResetPu+0x22>
    return the available NFCQ entry of target PU
*************************************************/

LOCAL NFCQ_ENTRY* HalNfcGetNfcqEntry(U8 Pu)
{
    U8 Wp = HalNfcGetWp(Pu);
ffe04ae7:	0020c0        	memw
*************************************************/

LOCAL void HalNfcClearNfcq(NFCQ_ENTRY* pNfcq)
{
    U32 i;
    for (i=0;i<NFCQ_ENTRY_SIZE_DW;i++)
ffe04aea:	020c      	movi.n	a2, 0
ffe04aec:	041c      	movi.n	a4, 16
    return the available NFCQ entry of target PU
*************************************************/

LOCAL NFCQ_ENTRY* HalNfcGetNfcqEntry(U8 Pu)
{
    U8 Wp = HalNfcGetWp(Pu);
ffe04aee:	000052        	l8ui	a5, a0, 0
*************************************************/

LOCAL void HalNfcClearNfcq(NFCQ_ENTRY* pNfcq)
{
    U32 i;
    for (i=0;i<NFCQ_ENTRY_SIZE_DW;i++)
ffe04af1:	6608      	l32i.n	a0, a6, 24
    return the available NFCQ entry of target PU
*************************************************/

LOCAL NFCQ_ENTRY* HalNfcGetNfcqEntry(U8 Pu)
{
    U8 Wp = HalNfcGetWp(Pu);
ffe04af3:	415650        	srli	a5, a5, 6
*************************************************/

LOCAL void HalNfcClearNfcq(NFCQ_ENTRY* pNfcq)
{
    U32 i;
    for (i=0;i<NFCQ_ENTRY_SIZE_DW;i++)
ffe04af6:	553a      	add.n	a5, a5, a3
ffe04af8:	1155a0        	slli	a5, a5, 6
ffe04afb:	005a      	add.n	a0, a0, a5
ffe04afd:	03a476        	loopgtz	a4, ffe04b04 <HAL_NfcResetPu+0x48>
    {
        *(((U32*)pNfcq) + i)  = 0;
ffe04b00:	0029      	s32i.n	a2, a0, 0
*************************************************/

LOCAL void HalNfcClearNfcq(NFCQ_ENTRY* pNfcq)
{
    U32 i;
    for (i=0;i<NFCQ_ENTRY_SIZE_DW;i++)
ffe04b02:	004b      	addi.n	a0, a0, 4

ffe04b04 <HAL_NfcResetPu+0x48>:
ffe04b04:	0020c0        	memw

    pNfcqEntry = HalNfcGetNfcqEntry(ucPhyPu);
    HalNfcClearNfcq((NFCQ_ENTRY *)pNfcqEntry);

    HAL_MemoryWait();
    HalSetPrcq(NF_RCMD_RESET,ucPhyPu);
ffe04b07:	020c      	movi.n	a2, 0
ffe04b09:	0c3d      	mov.n	a3, a12
ffe04b0b:	ff7445        	call0	ffe04250 <HalSetPrcq..CB_1429880325>
    HalSetTrigger(NF_RCMD_RESET,ucPhyPu,ucCeSel);
ffe04b0e:	0d4d      	mov.n	a4, a13
ffe04b10:	020c      	movi.n	a2, 0
ffe04b12:	0c3d      	mov.n	a3, a12
ffe04b14:	ff6d45        	call0	ffe041ec <HalSetTrigger..EB_1429880325>
    return HalNfcSinglePuStatus(ucPhyPu);
ffe04b17:	0c2d      	mov.n	a2, a12
ffe04b19:	21d8      	l32i.n	a13, a1, 8
ffe04b1b:	11c8      	l32i.n	a12, a1, 4
ffe04b1d:	ff66c5        	call0	ffe0418c <HalNfcSinglePuStatus..O_1429880325>
ffe04b20:	0108      	l32i.n	a0, a1, 0
ffe04b22:	10c112        	addi	a1, a1, 16
ffe04b25:	f00d      	ret.n

ffe04b27 <HAL_NfcResetPu+0x6b>:
	...

ffe04b28 <HAL_NormalDsgInit>:
    20141028    Gavin   change attribute to "INLINE"
------------------------------------------------------------------------------*/
INLINE U32 HAL_GetMcuId(void)
{
    U32 ulMcuId;
    ulMcuId = XT_RSR_PRID();
ffe04b28:	03eb30        	rsr.prid	a3
ffe04b2b:	f39641        	l32r	a4, ffe01984 <_bss_table_end+0x8>
History:
    201409011    Tobey   uniform coding style
------------------------------------------------------------------------------*/
void HAL_NormalDsgInit(void)
{
    l_ulMcuID = HAL_GetMcuId();
ffe04b2e:	a439      	s32i.n	a3, a4, 40
    if (MCU0_ID == l_ulMcuID)
ffe04b30:	091366        	bnei	a3, 1, ffe04b3d <HAL_NormalDsgInit+0x15>
    {
#ifdef VT3514_C0
        l_pDsgReport = (pDSG_REPORT_MCU)(&rDsgReportMcu0);
ffe04b33:	f44321        	l32r	a2, ffe01c40 <_bss_table_end+0x2c4>
ffe04b36:	0020c0        	memw
ffe04b39:	b429      	s32i.n	a2, a4, 44
    else //MCU2_ID
    {
        l_pDsgReport = (pDSG_REPORT_MCU)(&rDsgReportMcu2);
    }      
    
    return;
ffe04b3b:	f00d      	ret.n

ffe04b3d <HAL_NormalDsgInit+0x15>:
        l_pDsgReport = (pDSG_REPORT_MCU)(&rDsgReportMcu0);
#else      
        l_pDsgReport = (pDSG_REPORT_MCU)(&rDsgReportMcu1);
#endif
    }
    else if (MCU1_ID == l_ulMcuID)
ffe04b3d:	092326        	beqi	a3, 2, ffe04b4a <HAL_NormalDsgInit+0x22>
    {
        l_pDsgReport = (pDSG_REPORT_MCU)(&rDsgReportMcu1);
    }
    else //MCU2_ID
    {
        l_pDsgReport = (pDSG_REPORT_MCU)(&rDsgReportMcu2);
ffe04b40:	f44151        	l32r	a5, ffe01c44 <_bss_table_end+0x2c8>
ffe04b43:	0020c0        	memw
ffe04b46:	b459      	s32i.n	a5, a4, 44
    }      
    
    return;
ffe04b48:	f00d      	ret.n

ffe04b4a <HAL_NormalDsgInit+0x22>:
        l_pDsgReport = (pDSG_REPORT_MCU)(&rDsgReportMcu1);
#endif
    }
    else if (MCU1_ID == l_ulMcuID)
    {
        l_pDsgReport = (pDSG_REPORT_MCU)(&rDsgReportMcu1);
ffe04b4a:	f43f31        	l32r	a3, ffe01c48 <_bss_table_end+0x2cc>
ffe04b4d:	0020c0        	memw
ffe04b50:	b439      	s32i.n	a3, a4, 44
    else //MCU2_ID
    {
        l_pDsgReport = (pDSG_REPORT_MCU)(&rDsgReportMcu2);
    }      
    
    return;
ffe04b52:	f00d      	ret.n

ffe04b54 <HalFlashQEEInit..J_1429880325>:

LOCAL void HalFlashQEEInit(void)
{
    U32 ulQeIndex;

    for (ulQeIndex = 0; ulQeIndex < QE_CMD_GROUP_DEPTH; ulQeIndex++)
ffe04b54:	f43e61        	l32r	a6, ffe01c4c <_bss_table_end+0x2d0>
ffe04b57:	021c      	movi.n	a2, 16
ffe04b59:	f38a71        	l32r	a7, ffe01984 <_bss_table_end+0x8>
Description:
    Initialize QEE registers 
*************************************************/

LOCAL void HalFlashQEEInit(void)
{
ffe04b5c:	f3dc81        	l32r	a8, ffe01acc <_bss_table_end+0x150>
    U32 ulQeIndex;

    for (ulQeIndex = 0; ulQeIndex < QE_CMD_GROUP_DEPTH; ulQeIndex++)
ffe04b5f:	9778      	l32i.n	a7, a7, 36
ffe04b61:	083d      	mov.n	a3, a8
ffe04b63:	205770        	or	a5, a7, a7
ffe04b66:	204770        	or	a4, a7, a7
ffe04b69:	19a276        	loopgtz	a2, ffe04b86 <HalFlashQEEInit..J_1429880325+0x32>
    {
        pNfcQEEntry->PRCQ_CQE1E[ulQeIndex] = g_aCQE1E[ulQeIndex];
ffe04b6c:	8006a2        	l8ui	a10, a6, 128
ffe04b6f:	0020c0        	memw
ffe04b72:	0045a2        	s8i	a10, a5, 0
        pNfcQEEntry->PRCQ_CQE2E[ulQeIndex] = g_aCQE2E[ulQeIndex];
ffe04b75:	e81392        	l16ui	a9, a3, 0x1d0
ffe04b78:	0020c0        	memw

LOCAL void HalFlashQEEInit(void)
{
    U32 ulQeIndex;

    for (ulQeIndex = 0; ulQeIndex < QE_CMD_GROUP_DEPTH; ulQeIndex++)
ffe04b7b:	332b      	addi.n	a3, a3, 2
ffe04b7d:	551b      	addi.n	a5, a5, 1
    {
        pNfcQEEntry->PRCQ_CQE1E[ulQeIndex] = g_aCQE1E[ulQeIndex];
        pNfcQEEntry->PRCQ_CQE2E[ulQeIndex] = g_aCQE2E[ulQeIndex];
ffe04b7f:	085492        	s16i	a9, a4, 16

LOCAL void HalFlashQEEInit(void)
{
    U32 ulQeIndex;

    for (ulQeIndex = 0; ulQeIndex < QE_CMD_GROUP_DEPTH; ulQeIndex++)
ffe04b82:	661b      	addi.n	a6, a6, 1
ffe04b84:	442b      	addi.n	a4, a4, 2

ffe04b86 <HalFlashQEEInit..J_1429880325+0x32>:
    {
        pNfcQEEntry->PRCQ_CQE1E[ulQeIndex] = g_aCQE1E[ulQeIndex];
        pNfcQEEntry->PRCQ_CQE2E[ulQeIndex] = g_aCQE2E[ulQeIndex];
    }

    for (ulQeIndex = 0; ulQeIndex < QE_OPRATION_GROUP_DEPTH; ulQeIndex++)
ffe04b86:	083d      	mov.n	a3, a8
ffe04b88:	8b0c      	movi.n	a11, 8
ffe04b8a:	0cab76        	loopgtz	a11, ffe04b9a <HalFlashQEEInit..J_1429880325+0x46>
    {
        pNfcQEEntry->PRCQ_SQEE[ulQeIndex] = g_aSQEE[ulQeIndex];
ffe04b8d:	f81322        	l16ui	a2, a3, 0x1f0
ffe04b90:	0020c0        	memw
ffe04b93:	285722        	s16i	a2, a7, 80
    {
        pNfcQEEntry->PRCQ_CQE1E[ulQeIndex] = g_aCQE1E[ulQeIndex];
        pNfcQEEntry->PRCQ_CQE2E[ulQeIndex] = g_aCQE2E[ulQeIndex];
    }

    for (ulQeIndex = 0; ulQeIndex < QE_OPRATION_GROUP_DEPTH; ulQeIndex++)
ffe04b96:	332b      	addi.n	a3, a3, 2
ffe04b98:	772b      	addi.n	a7, a7, 2
    {
        pNfcQEEntry->PRCQ_SQEE[ulQeIndex] = g_aSQEE[ulQeIndex];
    }
}
ffe04b9a:	f00d      	ret.n

ffe04b9c <HalFlashCmdTableInit..I_1429880325>:
    U8 i;
    U32 ulCurQECnt = 0;
    U32 ulCurPioQECnt = 0;
    U32 Len = (sizeof(RCMD_TABLE)*NF_RCMD_CNT)/sizeof(U32);

    for (i=0; i<Len;i++)
ffe04b9c:	030c      	movi.n	a3, 0
ffe04b9e:	f37951        	l32r	a5, ffe01984 <_bss_table_end+0x8>
ffe04ba1:	f3ca61        	l32r	a6, ffe01acc <_bss_table_end+0x150>
    {
        *((U32*)l_aRCMD_TABLE + i) = *((U32*)aRCMD_TABLE + i);
    }
    
    for(ucCmdIndex = 0; ucCmdIndex <NF_RCMD_CNT; ucCmdIndex++)
ffe04ba4:	f3fc91        	l32r	a9, ffe01b94 <_bss_table_end+0x218>
ffe04ba7:	a0a182        	movi	a8, 0x1a0
ffe04baa:	4a0c      	movi.n	a10, 4
ffe04bac:	820c      	movi.n	a2, 8
ffe04bae:	10a276        	loopgtz	a2, ffe04bc2 <HalFlashCmdTableInit..I_1429880325+0x26>
    U32 ulCurPioQECnt = 0;
    U32 Len = (sizeof(RCMD_TABLE)*NF_RCMD_CNT)/sizeof(U32);

    for (i=0; i<Len;i++)
    {
        *((U32*)l_aRCMD_TABLE + i) = *((U32*)aRCMD_TABLE + i);
ffe04bb1:	a07350        	addx4	a7, a3, a5
ffe04bb4:	a04360        	addx4	a4, a3, a6
ffe04bb7:	602442        	l32i	a4, a4, 0x180
ffe04bba:	406742        	s32i	a4, a7, 0x100
    U8 i;
    U32 ulCurQECnt = 0;
    U32 ulCurPioQECnt = 0;
    U32 Len = (sizeof(RCMD_TABLE)*NF_RCMD_CNT)/sizeof(U32);

    for (i=0; i<Len;i++)
ffe04bbd:	331b      	addi.n	a3, a3, 1
ffe04bbf:	743030        	extui	a3, a3, 0, 8

ffe04bc2 <HalFlashCmdTableInit..I_1429880325+0x26>:
    {
        *((U32*)l_aRCMD_TABLE + i) = *((U32*)aRCMD_TABLE + i);
    }
    
    for(ucCmdIndex = 0; ucCmdIndex <NF_RCMD_CNT; ucCmdIndex++)
ffe04bc2:	030c      	movi.n	a3, 0
ffe04bc4:	070c      	movi.n	a7, 0
ffe04bc6:	1caa76        	loopgtz	a10, ffe04be6 <HalFlashCmdTableInit..I_1429880325+0x4a>
    {
        if(FALSE == l_aRCMD_TABLE[ucCmdIndex].IsPIO)
ffe04bc9:	b04350        	addx8	a4, a3, a5
ffe04bcc:	4024b2        	l32i	a11, a4, 0x100
        {
            l_aRCMD_TABLE[ucCmdIndex].QEPtr = (U32)&l_aQETable[ulCurQECnt];
            ulCurQECnt += l_aRCMD_TABLE[ucCmdIndex].QEPhase;
ffe04bcf:	b02390        	addx8	a2, a3, a9
        *((U32*)l_aRCMD_TABLE + i) = *((U32*)aRCMD_TABLE + i);
    }
    
    for(ucCmdIndex = 0; ucCmdIndex <NF_RCMD_CNT; ucCmdIndex++)
    {
        if(FALSE == l_aRCMD_TABLE[ucCmdIndex].IsPIO)
ffe04bd2:	0bfb07        	bbsi	a11, 16, ffe04be1 <HalFlashCmdTableInit..I_1429880325+0x45>
        {
            l_aRCMD_TABLE[ucCmdIndex].QEPtr = (U32)&l_aQETable[ulCurQECnt];
ffe04bd5:	a68a      	add.n	a10, a6, a8
ffe04bd7:	a7aa      	add.n	a10, a7, a10
ffe04bd9:	4164a2        	s32i	a10, a4, 0x104
            ulCurQECnt += l_aRCMD_TABLE[ucCmdIndex].QEPhase;
ffe04bdc:	7d0222        	l8ui	a2, a2, 125
ffe04bdf:	727a      	add.n	a7, a2, a7

ffe04be1 <HalFlashCmdTableInit..I_1429880325+0x45>:
    for (i=0; i<Len;i++)
    {
        *((U32*)l_aRCMD_TABLE + i) = *((U32*)aRCMD_TABLE + i);
    }
    
    for(ucCmdIndex = 0; ucCmdIndex <NF_RCMD_CNT; ucCmdIndex++)
ffe04be1:	331b      	addi.n	a3, a3, 1
ffe04be3:	743030        	extui	a3, a3, 0, 8

ffe04be6 <HalFlashCmdTableInit..I_1429880325+0x4a>:
        {
            l_aRCMD_TABLE[ucCmdIndex].QEPtr = (U32)&l_aQETable[ulCurQECnt];
            ulCurQECnt += l_aRCMD_TABLE[ucCmdIndex].QEPhase;
        }
    }
}
ffe04be6:	f00d      	ret.n

ffe04be8 <DBG_Getch>:
U32  g_ulSaveDramSize;

#ifndef SIM
volatile U32 g_dbg_enable;
void DRAM_ATTR DBG_Getch()
{
ffe04be8:	f36731        	l32r	a3, ffe01984 <_bss_table_end+0x8>
    U32 nTestLoop = 0;

    while(g_dbg_enable)
ffe04beb:	0020c0        	memw
ffe04bee:	252322        	l32i	a2, a3, 148
ffe04bf1:	728c      	beqz.n	a2, ffe04bfc <DBG_Getch+0x14>

ffe04bf3 <DBG_Getch+0xb>:
ffe04bf3:	0020c0        	memw
ffe04bf6:	252342        	l32i	a4, a3, 148
ffe04bf9:	ff6456        	bnez	a4, ffe04bf3 <DBG_Getch+0xb>
    {
        nTestLoop++;
    }
    g_dbg_enable = 1;
ffe04bfc:	150c      	movi.n	a5, 1
ffe04bfe:	0020c0        	memw
ffe04c01:	256352        	s32i	a5, a3, 148
}
ffe04c04:	f00d      	ret.n

ffe04c06 <DBG_Getch+0x1e>:
	...

ffe04c08 <HAL_DMAEIsEntryAvailable>:
{
    volatile DMAE_CMDENTRY *pCmdEntry;
    U8 ucStatus;
 
    pCmdEntry =  (volatile DMAE_CMDENTRY *)(DMAE_CMDENTRY_BASE + ucCmdID * sizeof(DMAE_CMDENTRY));
    ucStatus = pCmdEntry->bsStatus;
ffe04c08:	f41241        	l32r	a4, ffe01c50 <_bss_table_end+0x2d4>
ffe04c0b:	1132c0        	slli	a3, a2, 4
ffe04c0e:	334a      	add.n	a3, a3, a4
ffe04c10:	0020c0        	memw
ffe04c13:	0338      	l32i.n	a3, a3, 0
ffe04c15:	142c30        	extui	a2, a3, 12, 2
    
    if ((DMAE_CMDENTRY_STATUS_DONE == ucStatus) || (DMAE_CMDENTRY_STATUS_IDLE == ucStatus))
ffe04c18:	053226        	beqi	a2, 3, ffe04c21 <HAL_DMAEIsEntryAvailable+0x19>
ffe04c1b:	228c      	beqz.n	a2, ffe04c21 <HAL_DMAEIsEntryAvailable+0x19>
    {
        return TRUE;
    }
    
    return FALSE;
ffe04c1d:	020c      	movi.n	a2, 0
ffe04c1f:	f00d      	ret.n

ffe04c21 <HAL_DMAEIsEntryAvailable+0x19>:
    pCmdEntry =  (volatile DMAE_CMDENTRY *)(DMAE_CMDENTRY_BASE + ucCmdID * sizeof(DMAE_CMDENTRY));
    ucStatus = pCmdEntry->bsStatus;
    
    if ((DMAE_CMDENTRY_STATUS_DONE == ucStatus) || (DMAE_CMDENTRY_STATUS_IDLE == ucStatus))
    {
        return TRUE;
ffe04c21:	120c      	movi.n	a2, 1
    }
    
    return FALSE;
ffe04c23:	f00d      	ret.n

ffe04c25 <HAL_DMAEIsEntryAvailable+0x1d>:
ffe04c25:	000000                                        ...

ffe04c28 <HAL_DMAEParseAddress>:
History:  
20140912    Kristin    Coding style uniform
------------------------------------------------------------------------------*/
BOOL DMAE_TEXT_ATTR HAL_DMAEParseAddress(U8 *pAreaType, U32 *pAddrOut, const U32 ulAddrIn)
{  
    if (ulAddrIn < SRAM0_START_ADDRESS)
ffe04c28:	f40b51        	l32r	a5, ffe01c54 <_bss_table_end+0x2d8>
    {    
        return FALSE;
    }
    else if ((ulAddrIn >= SRAM0_START_ADDRESS) && (ulAddrIn < DRAM_START_ADDRESS)) /* SRAM */
ffe04c2b:	f37861        	l32r	a6, ffe01a0c <_bss_table_end+0x90>
History:  
20140912    Kristin    Coding style uniform
------------------------------------------------------------------------------*/
BOOL DMAE_TEXT_ATTR HAL_DMAEParseAddress(U8 *pAreaType, U32 *pAddrOut, const U32 ulAddrIn)
{  
    if (ulAddrIn < SRAM0_START_ADDRESS)
ffe04c2e:	033547        	bltu	a5, a4, ffe04c35 <HAL_DMAEParseAddress+0xd>
    {    
        return FALSE;
ffe04c31:	020c      	movi.n	a2, 0
    else
    {
        return FALSE;
    }
    
    return TRUE;
ffe04c33:	f00d      	ret.n

ffe04c35 <HAL_DMAEParseAddress+0xd>:
{  
    if (ulAddrIn < SRAM0_START_ADDRESS)
    {    
        return FALSE;
    }
    else if ((ulAddrIn >= SRAM0_START_ADDRESS) && (ulAddrIn < DRAM_START_ADDRESS)) /* SRAM */
ffe04c35:	0a3647        	bltu	a6, a4, ffe04c43 <HAL_DMAEParseAddress+0x1b>
    {
        *pAddrOut = ulAddrIn;        
ffe04c38:	0349      	s32i.n	a4, a3, 0
        *pAreaType = DMAE_SEL_AREA_PIF;     
ffe04c3a:	030c      	movi.n	a3, 0
ffe04c3c:	004232        	s8i	a3, a2, 0
    else
    {
        return FALSE;
    }
    
    return TRUE;
ffe04c3f:	120c      	movi.n	a2, 1
ffe04c41:	f00d      	ret.n

ffe04c43 <HAL_DMAEParseAddress+0x1b>:
    else if ((ulAddrIn >= SRAM0_START_ADDRESS) && (ulAddrIn < DRAM_START_ADDRESS)) /* SRAM */
    {
        *pAddrOut = ulAddrIn;        
        *pAreaType = DMAE_SEL_AREA_PIF;     
    }
    else if ((ulAddrIn >= DRAM_START_ADDRESS) && (ulAddrIn < SPI_START_ADDRESS)) /* DRAM */
ffe04c43:	f35a71        	l32r	a7, ffe019ac <_bss_table_end+0x30>
    {
        *pAddrOut = ulAddrIn;        
        *pAreaType = DMAE_SEL_AREA_DRAM;     
    }
    else if ((ulAddrIn >= SPI_START_ADDRESS) && (ulAddrIn < OTFB_START_ADDRESS)) /* SPI NOR Flash */
ffe04c46:	f35181        	l32r	a8, ffe0198c <_bss_table_end+0x10>
    else if ((ulAddrIn >= SRAM0_START_ADDRESS) && (ulAddrIn < DRAM_START_ADDRESS)) /* SRAM */
    {
        *pAddrOut = ulAddrIn;        
        *pAreaType = DMAE_SEL_AREA_PIF;     
    }
    else if ((ulAddrIn >= DRAM_START_ADDRESS) && (ulAddrIn < SPI_START_ADDRESS)) /* DRAM */
ffe04c49:	063747        	bltu	a7, a4, ffe04c53 <HAL_DMAEParseAddress+0x2b>
    {
        *pAddrOut = ulAddrIn;        
ffe04c4c:	0349      	s32i.n	a4, a3, 0
        *pAreaType = DMAE_SEL_AREA_DRAM;     
ffe04c4e:	230c      	movi.n	a3, 2
ffe04c50:	fffa06        	j	ffe04c3c <HAL_DMAEParseAddress+0x14>

ffe04c53 <HAL_DMAEParseAddress+0x2b>:
    }
    else if ((ulAddrIn >= SPI_START_ADDRESS) && (ulAddrIn < OTFB_START_ADDRESS)) /* SPI NOR Flash */
ffe04c53:	063847        	bltu	a8, a4, ffe04c5d <HAL_DMAEParseAddress+0x35>
    {
        *pAddrOut = ulAddrIn; 
ffe04c56:	0349      	s32i.n	a4, a3, 0
        *pAreaType = DMAE_SEL_AREA_SPI; 
ffe04c58:	330c      	movi.n	a3, 3
ffe04c5a:	fff786        	j	ffe04c3c <HAL_DMAEParseAddress+0x14>

ffe04c5d <HAL_DMAEParseAddress+0x35>:
    }
    else if (ulAddrIn >= OTFB_START_ADDRESS) /* OTFB */
    {
        *pAddrOut = ulAddrIn;
ffe04c5d:	0349      	s32i.n	a4, a3, 0
        *pAreaType = DMAE_SEL_AREA_OTFB;
ffe04c5f:	130c      	movi.n	a3, 1
ffe04c61:	fff5c6        	j	ffe04c3c <HAL_DMAEParseAddress+0x14>

ffe04c64 <HAL_DMAECopyOneBlockLenLimit..B_1429880325>:
    local function
History:  
20140912    Kristin    Coding style uniform
------------------------------------------------------------------------------*/
LOCAL BOOL DMAE_TEXT_ATTR HAL_DMAECopyOneBlockLenLimit(const U32 ulDesAddr, const U32 ulSrcAddr, const U32 ulBlockLenInByte)
{
ffe04c64:	d0c112        	addi	a1, a1, -48
ffe04c67:	61c9      	s32i.n	a12, a1, 24
ffe04c69:	5109      	s32i.n	a0, a1, 20
ffe04c6b:	81e9      	s32i.n	a14, a1, 32
ffe04c6d:	71d9      	s32i.n	a13, a1, 28
ffe04c6f:	02ed      	mov.n	a14, a2
ffe04c71:	04dd      	mov.n	a13, a4
ffe04c73:	032d      	mov.n	a2, a3
ffe04c75:	03eb00        	rsr.prid	a0
ffe04c78:	4129      	s32i.n	a2, a1, 16
    U8 ucCmdId;
    U8 ucCmdIDRet = INVALID_2F;

    ucMCUID = HAL_GetMcuId();

    switch(ucMCUID)
ffe04c7a:	740000        	extui	a0, a0, 0, 8
ffe04c7d:	300b      	addi.n	a3, a0, -1
ffe04c7f:	130316        	beqz	a3, ffe04db3 <HAL_DMAECopyOneBlockLenLimit..B_1429880325+0x14f>
ffe04c82:	fec022        	addi	a2, a0, -2
ffe04c85:	142216        	beqz	a2, ffe04dcb <HAL_DMAECopyOneBlockLenLimit..B_1429880325+0x167>
ffe04c88:	183066        	bnei	a0, 3, ffe04ca4 <HAL_DMAECopyOneBlockLenLimit..B_1429880325+0x40>
            }
        }
        break;

    case MCU2_ID:
        for (ucCmdId = DMAE_CMD_HEAD_MCU2; ucCmdId <= DMAE_CMD_TAIL_MCU2; ucCmdId++)
ffe04c8b:	5c0c      	movi.n	a12, 5

ffe04c8d <HAL_DMAECopyOneBlockLenLimit..B_1429880325+0x29>:
        {
            if (TRUE == HAL_DMAEIsEntryAvailable(ucCmdId))
ffe04c8d:	0c2d      	mov.n	a2, a12
ffe04c8f:	fff785        	call0	ffe04c08 <HAL_DMAEIsEntryAvailable>
ffe04c92:	320b      	addi.n	a3, a2, -1
ffe04c94:	f38c      	beqz.n	a3, ffe04ca7 <HAL_DMAECopyOneBlockLenLimit..B_1429880325+0x43>
            }
        }
        break;

    case MCU2_ID:
        for (ucCmdId = DMAE_CMD_HEAD_MCU2; ucCmdId <= DMAE_CMD_TAIL_MCU2; ucCmdId++)
ffe04c96:	cc1b      	addi.n	a12, a12, 1
ffe04c98:	74c0c0        	extui	a12, a12, 0, 8
ffe04c9b:	ee8c66        	bnei	a12, 8, ffe04c8d <HAL_DMAECopyOneBlockLenLimit..B_1429880325+0x29>
ffe04c9e:	ffa0c2        	movi	a12, 255
ffe04ca1:	000086        	j	ffe04ca7 <HAL_DMAECopyOneBlockLenLimit..B_1429880325+0x43>

ffe04ca4 <HAL_DMAECopyOneBlockLenLimit..B_1429880325+0x40>:
    U8 ucCmdId;
    U8 ucCmdIDRet = INVALID_2F;

    ucMCUID = HAL_GetMcuId();

    switch(ucMCUID)
ffe04ca4:	ffa0c2        	movi	a12, 255
    U8 ucSrcAreaType;
    U32 ulCmdDesAddr;
    U32 ulCmdSrcAddr;
    
    ucCurCmdID = HAL_DMAEGetNextCmdID();
    if (INVALID_2F == ucCurCmdID)
ffe04ca7:	ffa002        	movi	a0, 255
ffe04caa:	c00c00        	sub	a0, a12, a0
ffe04cad:	0a5016        	beqz	a0, ffe04d56 <HAL_DMAECopyOneBlockLenLimit..B_1429880325+0xf2>
        return FALSE;
    }

    pCurCmdEntry = (volatile DMAE_CMDENTRY *)(DMAE_CMDENTRY_BASE + ucCurCmdID * sizeof(DMAE_CMDENTRY));
    
    if ((FALSE == HAL_DMAEParseAddress(&ucDesAreaType, &ulCmdDesAddr, ulDesAddr))
ffe04cb0:	0e4d      	mov.n	a4, a14
ffe04cb2:	012d      	mov.n	a2, a1
ffe04cb4:	314b      	addi.n	a3, a1, 4
ffe04cb6:	fff705        	call0	ffe04c28 <HAL_DMAEParseAddress>
ffe04cb9:	099216        	beqz	a2, ffe04d56 <HAL_DMAECopyOneBlockLenLimit..B_1429880325+0xf2>
ffe04cbc:	218b      	addi.n	a2, a1, 8
ffe04cbe:	31cb      	addi.n	a3, a1, 12
ffe04cc0:	4148      	l32i.n	a4, a1, 16
ffe04cc2:	fff645        	call0	ffe04c28 <HAL_DMAEParseAddress>
ffe04cc5:	08d216        	beqz	a2, ffe04d56 <HAL_DMAECopyOneBlockLenLimit..B_1429880325+0xf2>
        || (FALSE == HAL_DMAEParseAddress(&ucSrcAreaType, &ulCmdSrcAddr, ulSrcAddr)))
    {
        return FALSE;
ffe04cc8:	f3e401        	l32r	a0, ffe01c58 <_bss_table_end+0x2dc>
    }
    
    pCurCmdEntry->bTrigger = 0;
ffe04ccb:	11ecc0        	slli	a14, a12, 4
    pCurCmdEntry = (volatile DMAE_CMDENTRY *)(DMAE_CMDENTRY_BASE + ucCurCmdID * sizeof(DMAE_CMDENTRY));
    
    if ((FALSE == HAL_DMAEParseAddress(&ucDesAreaType, &ulCmdDesAddr, ulDesAddr))
        || (FALSE == HAL_DMAEParseAddress(&ucSrcAreaType, &ulCmdSrcAddr, ulSrcAddr)))
    {
        return FALSE;
ffe04cce:	ffaea2        	movi	a10, 0xfffffeff
    }
    
    pCurCmdEntry->bTrigger = 0;
ffe04cd1:	ee0a      	add.n	a14, a14, a0
ffe04cd3:	0020c0        	memw
ffe04cd6:	7f2e92        	l32i	a9, a14, 0x1fc
ffe04cd9:	1099a0        	and	a9, a9, a10
ffe04cdc:	0020c0        	memw
ffe04cdf:	7f6e92        	s32i	a9, a14, 0x1fc
    
    pCurCmdEntry->bsDesType = ucDesAreaType;
ffe04ce2:	0020c0        	memw
ffe04ce5:	000182        	l8ui	a8, a1, 0
ffe04ce8:	7f2e72        	l32i	a7, a14, 0x1fc
ffe04ceb:	010874        	insbits	a7, a8, 0, 1
ffe04cee:	0020c0        	memw
ffe04cf1:	7f6e72        	s32i	a7, a14, 0x1fc
    pCurCmdEntry->ulDesAddr = ulCmdDesAddr;
ffe04cf4:	1168      	l32i.n	a6, a1, 4
ffe04cf6:	0020c0        	memw
ffe04cf9:	7e6e62        	s32i	a6, a14, 0x1f8
    pCurCmdEntry->bsSrcType = ucSrcAreaType;
ffe04cfc:	0020c0        	memw
ffe04cff:	080152        	l8ui	a5, a1, 8
ffe04d02:	7f2e42        	l32i	a4, a14, 0x1fc
ffe04d05:	224544        	insbits	a4, a5, 4, 6
ffe04d08:	0020c0        	memw
ffe04d0b:	7f6e42        	s32i	a4, a14, 0x1fc
    pCurCmdEntry->ulSrcAddr = ulCmdSrcAddr;
ffe04d0e:	3138      	l32i.n	a3, a1, 12
ffe04d10:	0020c0        	memw
ffe04d13:	7d6e32        	s32i	a3, a14, 0x1f4
History:  
20140912    Kristin    Coding style uniform
------------------------------------------------------------------------------*/
U16 DMAE_TEXT_ATTR HAL_DMAEGetCmdLen(U32 ulLenByte)
{
    if (0 != (ulLenByte & 0xF))
ffe04d16:	f20c      	movi.n	a2, 15
ffe04d18:	0802d7        	bnone	a2, a13, ffe04d24 <HAL_DMAECopyOneBlockLenLimit..B_1429880325+0xc0>
    {
        DBG_Printf("HAL_DMAEGetCmdLen: Length is not divisible by 16-byte, error!\n");
ffe04d1b:	f3d021        	l32r	a2, ffe01c5c <_bss_table_end+0x2e0>
ffe04d1e:	001a05        	call0	ffe04ec0 <dbg_printf>
        DBG_Getch();
ffe04d21:	ffec45        	call0	ffe04be8 <DBG_Getch>
    
    pCurCmdEntry->bsDesType = ucDesAreaType;
    pCurCmdEntry->ulDesAddr = ulCmdDesAddr;
    pCurCmdEntry->bsSrcType = ucSrcAreaType;
    pCurCmdEntry->ulSrcAddr = ulCmdSrcAddr;
    pCurCmdEntry->bsLength = HAL_DMAEGetCmdLen(ulBlockLenInByte);
ffe04d24:	0020c0        	memw
ffe04d27:	7f2e42        	l32i	a4, a14, 0x1fc
ffe04d2a:	4154d0        	srli	a5, a13, 4
ffe04d2d:	550b      	addi.n	a5, a5, -1
ffe04d2f:	f00544        	insbits	a4, a5, 16, 28
ffe04d32:	0020c0        	memw
ffe04d35:	7f6e42        	s32i	a4, a14, 0x1fc
ffe04d38:	03eb30        	rsr.prid	a3
    U8 ucMCUSel;
    DMAE_CMDENTRY *pCmdEntry = (DMAE_CMDENTRY *)(DMAE_CMDENTRY_BASE + ucDMAECmdID * sizeof(DMAE_CMDENTRY));

    ucMCUID = HAL_GetMcuId();

    switch (ucMCUID)
ffe04d3b:	743030        	extui	a3, a3, 0, 8
ffe04d3e:	191326        	beqi	a3, 1, ffe04d5b <HAL_DMAECopyOneBlockLenLimit..B_1429880325+0xf7>
ffe04d41:	fec362        	addi	a6, a3, -2
ffe04d44:	09e616        	beqz	a6, ffe04de6 <HAL_DMAECopyOneBlockLenLimit..B_1429880325+0x182>
ffe04d47:	633326        	beqi	a3, 3, ffe04dae <HAL_DMAECopyOneBlockLenLimit..B_1429880325+0x14a>
    case MCU2_ID:
        ucMCUSel = DMAE_SEL_MCU2;
        break;

    default:
        DBG_Printf("HAL_DMAESelMCU: get MCU ID %d error", ucMCUID);
ffe04d4a:	f3c521        	l32r	a2, ffe01c60 <_bss_table_end+0x2e4>
ffe04d4d:	001705        	call0	ffe04ec0 <dbg_printf>
        DBG_Getch();
ffe04d50:	ffe945        	call0	ffe04be8 <DBG_Getch>
        break;
ffe04d53:	000186        	j	ffe04d5d <HAL_DMAECopyOneBlockLenLimit..B_1429880325+0xf9>

ffe04d56 <HAL_DMAECopyOneBlockLenLimit..B_1429880325+0xf2>:
    U32 ulCmdSrcAddr;
    
    ucCurCmdID = HAL_DMAEGetNextCmdID();
    if (INVALID_2F == ucCurCmdID)
    {
        return FALSE;
ffe04d56:	020c      	movi.n	a2, 0
    U8 ucSrcAreaType;
    U32 ulCmdDesAddr;
    U32 ulCmdSrcAddr;
    
    ucCurCmdID = HAL_DMAEGetNextCmdID();
    if (INVALID_2F == ucCurCmdID)
ffe04d58:	001146        	j	ffe04da1 <HAL_DMAECopyOneBlockLenLimit..B_1429880325+0x13d>

ffe04d5b <HAL_DMAECopyOneBlockLenLimit..B_1429880325+0xf7>:
    ucMCUID = HAL_GetMcuId();

    switch (ucMCUID)
    {
    case MCU0_ID:
        ucMCUSel = DMAE_SEL_MCU0;
ffe04d5b:	000c      	movi.n	a0, 0
    HAL_MultiCoreGetSpinLockWait(SPINLOCKID_DMAE);
    rGLB_64 &= (~MSK_DMAE_MCU_SEL);
    rGLB_64 |= (ucMCUSel << 16);
    HAL_MultiCoreReleaseSpinLock(SPINLOCKID_DMAE);
#else
    pCmdEntry->bsMCUSel = ucMCUSel;
ffe04d5d:	f3be41        	l32r	a4, ffe01c58 <_bss_table_end+0x2dc>
ffe04d60:	7430c0        	extui	a3, a12, 0, 8
ffe04d63:	1133c0        	slli	a3, a3, 4
ffe04d66:	334a      	add.n	a3, a3, a4
ffe04d68:	7f23a2        	l32i	a10, a3, 0x1fc
ffe04d6b:	63e0a4        	insbits	a10, a0, 14, 15
ffe04d6e:	7f63a2        	s32i	a10, a3, 0x1fc
    pCurCmdEntry->bsSrcType = ucSrcAreaType;
    pCurCmdEntry->ulSrcAddr = ulCmdSrcAddr;
    pCurCmdEntry->bsLength = HAL_DMAEGetCmdLen(ulBlockLenInByte);
    HAL_DMAESelMCU(ucCurCmdID);
  
    pCurCmdEntry->bTrigger = 1;
ffe04d71:	00a182        	movi	a8, 0x100
ffe04d74:	0020c0        	memw
ffe04d77:	7f2e72        	l32i	a7, a14, 0x1fc
ffe04d7a:	ffae92        	movi	a9, 0xfffffeff
ffe04d7d:	107790        	and	a7, a7, a9
ffe04d80:	207780        	or	a7, a7, a8
ffe04d83:	0020c0        	memw
ffe04d86:	7f6e72        	s32i	a7, a14, 0x1fc
{
    volatile DMAE_CMDENTRY *pCmdEntry;
    U8 ucStatus;
    
    pCmdEntry =  (volatile DMAE_CMDENTRY *)(DMAE_CMDENTRY_BASE + ucCmdID * sizeof(DMAE_CMDENTRY));
    ucStatus = pCmdEntry->bsStatus;
ffe04d89:	0020c0        	memw
    
    if (DMAE_CMDENTRY_STATUS_DONE == ucStatus)
ffe04d8c:	050c      	movi.n	a5, 0
{
    volatile DMAE_CMDENTRY *pCmdEntry;
    U8 ucStatus;
    
    pCmdEntry =  (volatile DMAE_CMDENTRY *)(DMAE_CMDENTRY_BASE + ucCmdID * sizeof(DMAE_CMDENTRY));
    ucStatus = pCmdEntry->bsStatus;
ffe04d8e:	7f2362        	l32i	a6, a3, 0x1fc
    
    if (DMAE_CMDENTRY_STATUS_DONE == ucStatus)
ffe04d91:	140c      	movi.n	a4, 1
{
    volatile DMAE_CMDENTRY *pCmdEntry;
    U8 ucStatus;
    
    pCmdEntry =  (volatile DMAE_CMDENTRY *)(DMAE_CMDENTRY_BASE + ucCmdID * sizeof(DMAE_CMDENTRY));
    ucStatus = pCmdEntry->bsStatus;
ffe04d93:	146c60        	extui	a6, a6, 12, 2
    
    if (DMAE_CMDENTRY_STATUS_DONE == ucStatus)
ffe04d96:	fdc662        	addi	a6, a6, -3
ffe04d99:	934560        	movnez	a4, a5, a6
#ifdef SIM
    pCurCmdEntry->bsStatus = DMAE_CMDENTRY_STATUS_PENDING;
    DMAE_ModelProcessCmdEntry(ucCurCmdID);
#endif
    
    while (FALSE == HAL_DMAEIsCmdDone(ucCurCmdID))
ffe04d9c:	fe9416        	beqz	a4, ffe04d89 <HAL_DMAECopyOneBlockLenLimit..B_1429880325+0x125>
    {  
    }    

    return TRUE;
ffe04d9f:	120c      	movi.n	a2, 1
ffe04da1:	61c8      	l32i.n	a12, a1, 24
ffe04da3:	71d8      	l32i.n	a13, a1, 28
ffe04da5:	81e8      	l32i.n	a14, a1, 32
ffe04da7:	5108      	l32i.n	a0, a1, 20
ffe04da9:	30c112        	addi	a1, a1, 48
ffe04dac:	f00d      	ret.n

ffe04dae <HAL_DMAECopyOneBlockLenLimit..B_1429880325+0x14a>:
    case MCU1_ID:
        ucMCUSel = DMAE_SEL_MCU1;
        break;

    case MCU2_ID:
        ucMCUSel = DMAE_SEL_MCU2;
ffe04dae:	200c      	movi.n	a0, 2
        break;
ffe04db0:	ffea46        	j	ffe04d5d <HAL_DMAECopyOneBlockLenLimit..B_1429880325+0xf9>

ffe04db3 <HAL_DMAECopyOneBlockLenLimit..B_1429880325+0x14f>:
    ucMCUID = HAL_GetMcuId();

    switch(ucMCUID)
    {
    case MCU0_ID:
        for (ucCmdId = DMAE_CMD_HEAD_MCU0; ucCmdId <= DMAE_CMD_TAIL_MCU0; ucCmdId++)
ffe04db3:	0c0c      	movi.n	a12, 0
        {
            if (TRUE == HAL_DMAEIsEntryAvailable(ucCmdId))
ffe04db5:	0c2d      	mov.n	a2, a12
ffe04db7:	ffe505        	call0	ffe04c08 <HAL_DMAEIsEntryAvailable>
ffe04dba:	021266        	bnei	a2, 1, ffe04dc0 <HAL_DMAECopyOneBlockLenLimit..B_1429880325+0x15c>
ffe04dbd:	ffb986        	j	ffe04ca7 <HAL_DMAECopyOneBlockLenLimit..B_1429880325+0x43>
    ucMCUID = HAL_GetMcuId();

    switch(ucMCUID)
    {
    case MCU0_ID:
        for (ucCmdId = DMAE_CMD_HEAD_MCU0; ucCmdId <= DMAE_CMD_TAIL_MCU0; ucCmdId++)
ffe04dc0:	cc1b      	addi.n	a12, a12, 1
ffe04dc2:	74c0c0        	extui	a12, a12, 0, 8
ffe04dc5:	ec2c66        	bnei	a12, 2, ffe04db5 <HAL_DMAECopyOneBlockLenLimit..B_1429880325+0x151>
ffe04dc8:	ffb606        	j	ffe04ca4 <HAL_DMAECopyOneBlockLenLimit..B_1429880325+0x40>

ffe04dcb <HAL_DMAECopyOneBlockLenLimit..B_1429880325+0x167>:
            }
        }
        break;

    case MCU1_ID:
        for (ucCmdId = DMAE_CMD_HEAD_MCU1; ucCmdId <= DMAE_CMD_TAIL_MCU1; ucCmdId++)
ffe04dcb:	2c0c      	movi.n	a12, 2
        {
            if (TRUE == HAL_DMAEIsEntryAvailable(ucCmdId))
ffe04dcd:	0c2d      	mov.n	a2, a12
ffe04dcf:	ffe385        	call0	ffe04c08 <HAL_DMAEIsEntryAvailable>
ffe04dd2:	021266        	bnei	a2, 1, ffe04dd8 <HAL_DMAECopyOneBlockLenLimit..B_1429880325+0x174>
ffe04dd5:	ffb386        	j	ffe04ca7 <HAL_DMAECopyOneBlockLenLimit..B_1429880325+0x43>
            }
        }
        break;

    case MCU1_ID:
        for (ucCmdId = DMAE_CMD_HEAD_MCU1; ucCmdId <= DMAE_CMD_TAIL_MCU1; ucCmdId++)
ffe04dd8:	cc1b      	addi.n	a12, a12, 1
ffe04dda:	74c0c0        	extui	a12, a12, 0, 8
ffe04ddd:	ec5c66        	bnei	a12, 5, ffe04dcd <HAL_DMAECopyOneBlockLenLimit..B_1429880325+0x169>
ffe04de0:	ffa0c2        	movi	a12, 255
ffe04de3:	ffb006        	j	ffe04ca7 <HAL_DMAECopyOneBlockLenLimit..B_1429880325+0x43>

ffe04de6 <HAL_DMAECopyOneBlockLenLimit..B_1429880325+0x182>:
    case MCU0_ID:
        ucMCUSel = DMAE_SEL_MCU0;
        break;

    case MCU1_ID:
        ucMCUSel = DMAE_SEL_MCU1;
ffe04de6:	100c      	movi.n	a0, 1
        break;
ffe04de8:	ffdc46        	j	ffe04d5d <HAL_DMAECopyOneBlockLenLimit..B_1429880325+0xf9>

ffe04deb <HAL_DMAECopyOneBlockLenLimit..B_1429880325+0x187>:
	...

ffe04dec <HAL_DelayCycle>:
    20140903    Gavin   created
    20141028    Gavin   add "INLINE" attribute
    20141112    Gavin   change XT_NOP() to asm("nop") for compiler optimization issue
------------------------------------------------------------------------------*/
INLINE void HAL_DelayCycle(U32 ulCycleCnt)
{
ffe04dec:	000046        	j	ffe04df1 <HAL_DelayCycle+0x5>

ffe04def <HAL_DelayCycle+0x3>:
    while (ulCycleCnt--)
    {
        #ifndef SIM
            asm("nop"); // not use XT_NOP() to prevent compiler optimizing it
ffe04def:	f03d      	nop.n
    20141028    Gavin   add "INLINE" attribute
    20141112    Gavin   change XT_NOP() to asm("nop") for compiler optimization issue
------------------------------------------------------------------------------*/
INLINE void HAL_DelayCycle(U32 ulCycleCnt)
{
    while (ulCycleCnt--)
ffe04df1:	220b      	addi.n	a2, a2, -1
ffe04df3:	f80266        	bnei	a2, -1, ffe04def <HAL_DelayCycle+0x3>
        #ifndef SIM
            asm("nop"); // not use XT_NOP() to prevent compiler optimizing it
        #endif
    }

    return;
ffe04df6:	f00d      	ret.n

ffe04df8 <HAL_SpiSendCCmd..GB_1429880325>:
History:
    2014/11/17 Victor Zhang  reconstruct

*******************************************************************************/
LOCAL void HAL_SpiSendCCmd(U8 ucCmdType,U8 ucRespByteNum,U8 ucCContByteNum)
{
ffe04df8:	f2e851        	l32r	a5, ffe01998 <_bss_table_end+0x1c>
    l_pSpiRegSet->bsCCmdCode      = ucCmdType;    
ffe04dfb:	f33441        	l32r	a4, ffe01acc <_bss_table_end+0x150>
History:
    2014/11/17 Victor Zhang  reconstruct

*******************************************************************************/
LOCAL void HAL_SpiSendCCmd(U8 ucCmdType,U8 ucRespByteNum,U8 ucCContByteNum)
{
ffe04dfe:	070c      	movi.n	a7, 0
    l_pSpiRegSet->bsCCmdCode      = ucCmdType;    
ffe04e00:	3448      	l32i.n	a4, a4, 12
ffe04e02:	0020c0        	memw
ffe04e05:	0b4422        	s8i	a2, a4, 11
    l_pSpiRegSet->bsCRespNum      = ucRespByteNum;
ffe04e08:	f39761        	l32r	a6, ffe01c64 <_bss_table_end+0x2e8>
ffe04e0b:	0020c0        	memw
ffe04e0e:	2438      	l32i.n	a3, a4, 8
ffe04e10:	103360        	and	a3, a3, a6
ffe04e13:	0020c0        	memw
ffe04e16:	2439      	s32i.n	a3, a4, 8
    l_pSpiRegSet->bsCLength       = ucCContByteNum;
ffe04e18:	f394b1        	l32r	a11, ffe01c68 <_bss_table_end+0x2ec>
ffe04e1b:	0020c0        	memw
ffe04e1e:	24a8      	l32i.n	a10, a4, 8
ffe04e20:	10aab0        	and	a10, a10, a11
ffe04e23:	0020c0        	memw
ffe04e26:	24a9      	s32i.n	a10, a4, 8
    l_pSpiRegSet->bsAutoStp       = (0 != ucRespByteNum) ? TRUE : FALSE;
ffe04e28:	ffab92        	movi	a9, 0xfffffbff
ffe04e2b:	0020c0        	memw
ffe04e2e:	2488      	l32i.n	a8, a4, 8
ffe04e30:	108890        	and	a8, a8, a9
ffe04e33:	0020c0        	memw
ffe04e36:	2489      	s32i.n	a8, a4, 8
    l_pSpiRegSet->bsCCmdValid     = TRUE;
ffe04e38:	f2d981        	l32r	a8, ffe0199c <_bss_table_end+0x20>
ffe04e3b:	0020c0        	memw
ffe04e3e:	2468      	l32i.n	a6, a4, 8
ffe04e40:	106650        	and	a6, a6, a5
ffe04e43:	206680        	or	a6, a6, a8
ffe04e46:	0020c0        	memw
ffe04e49:	2469      	s32i.n	a6, a4, 8
    while(FALSE == l_pSpiRegSet->bsCRespValid)
ffe04e4b:	0020c0        	memw
ffe04e4e:	2438      	l32i.n	a3, a4, 8
ffe04e50:	07e377        	bbsi	a3, 7, ffe04e5b <HAL_SpiSendCCmd..GB_1429880325+0x63>

ffe04e53 <HAL_SpiSendCCmd..GB_1429880325+0x5b>:
ffe04e53:	0020c0        	memw
ffe04e56:	2468      	l32i.n	a6, a4, 8
ffe04e58:	f76677        	bbci	a6, 7, ffe04e53 <HAL_SpiSendCCmd..GB_1429880325+0x5b>
    {
        ;
    }
    l_pSpiRegSet->bsCRespValid    = FALSE;
ffe04e5b:	7fafa2        	movi	a10, -129
ffe04e5e:	0020c0        	memw
ffe04e61:	2498      	l32i.n	a9, a4, 8
ffe04e63:	1099a0        	and	a9, a9, a10
ffe04e66:	209970        	or	a9, a9, a7
ffe04e69:	0020c0        	memw
ffe04e6c:	2499      	s32i.n	a9, a4, 8
    l_pSpiRegSet->bsCCmdValid     = FALSE;
ffe04e6e:	0020c0        	memw
ffe04e71:	2488      	l32i.n	a8, a4, 8
ffe04e73:	108850        	and	a8, a8, a5
ffe04e76:	208870        	or	a8, a8, a7
ffe04e79:	0020c0        	memw
ffe04e7c:	2489      	s32i.n	a8, a4, 8
}
ffe04e7e:	f00d      	ret.n

ffe04e80 <HAL_SpiHWInit..OB_1429880325>:
****************************************************************************/
void COM_MemZero(U32* TargetAddr,U32 LengthDW)
{
    U32 i;

    for (i = 0 ; i < LengthDW; i++)
ffe04e80:	040c      	movi.n	a4, 0
*******************************************************************************/

LOCAL void HAL_SpiHWInit(void)
{
    COM_MemZero((U32 *) l_pSpiRegSet,sizeof(SPI_REG_SET)/sizeof(U32));  // reset first 7 dword
    l_pSpiRegSet->bsSnf       = TRUE;
ffe04e82:	f2d4a1        	l32r	a10, ffe019d4 <_bss_table_end+0x58>

*******************************************************************************/

LOCAL void HAL_SpiHWInit(void)
{
    COM_MemZero((U32 *) l_pSpiRegSet,sizeof(SPI_REG_SET)/sizeof(U32));  // reset first 7 dword
ffe04e85:	f31151        	l32r	a5, ffe01acc <_bss_table_end+0x150>
    l_pSpiRegSet->bsSnf       = TRUE;
ffe04e88:	f2ccb1        	l32r	a11, ffe019b8 <_bss_table_end+0x3c>

*******************************************************************************/

LOCAL void HAL_SpiHWInit(void)
{
    COM_MemZero((U32 *) l_pSpiRegSet,sizeof(SPI_REG_SET)/sizeof(U32));  // reset first 7 dword
ffe04e8b:	3558      	l32i.n	a5, a5, 12
ffe04e8d:	d20c      	movi.n	a2, 13
ffe04e8f:	053d      	mov.n	a3, a5
ffe04e91:	03a276        	loopgtz	a2, ffe04e98 <HAL_SpiHWInit..OB_1429880325+0x18>
    {
        *TargetAddr++ = 0;
ffe04e94:	0349      	s32i.n	a4, a3, 0
ffe04e96:	334b      	addi.n	a3, a3, 4

ffe04e98 <HAL_SpiHWInit..OB_1429880325+0x18>:
    l_pSpiRegSet->bsSnf       = TRUE;
ffe04e98:	0020c0        	memw
ffe04e9b:	0598      	l32i.n	a9, a5, 0
ffe04e9d:	1099b0        	and	a9, a9, a11
ffe04ea0:	2099a0        	or	a9, a9, a10
ffe04ea3:	0020c0        	memw
ffe04ea6:	0599      	s32i.n	a9, a5, 0
    l_pSpiRegSet->bsRCmdEn    = TRUE;   
ffe04ea8:	f2dd71        	l32r	a7, ffe01a1c <_bss_table_end+0xa0>
ffe04eab:	0020c0        	memw
ffe04eae:	1588      	l32i.n	a8, a5, 4
ffe04eb0:	e20874        	insbits	a7, a8, 0, 30
ffe04eb3:	0020c0        	memw
    l_ulCurrSpiMode = SPI_MODE;
ffe04eb6:	f2b361        	l32r	a6, ffe01984 <_bss_table_end+0x8>

LOCAL void HAL_SpiHWInit(void)
{
    COM_MemZero((U32 *) l_pSpiRegSet,sizeof(SPI_REG_SET)/sizeof(U32));  // reset first 7 dword
    l_pSpiRegSet->bsSnf       = TRUE;
    l_pSpiRegSet->bsRCmdEn    = TRUE;   
ffe04eb9:	1579      	s32i.n	a7, a5, 4
    l_ulCurrSpiMode = SPI_MODE;
ffe04ebb:	176642        	s32i	a4, a6, 92
}
ffe04ebe:	f00d      	ret.n

ffe04ec0 <dbg_printf>:
    rUART_TXR = c;
}


void dbg_printf(const char *fmt, ...)
{
ffe04ec0:	b0c112        	addi	a1, a1, -80
ffe04ec3:	d139      	s32i.n	a3, a1, 52
ffe04ec5:	e149      	s32i.n	a4, a1, 56
ffe04ec7:	f159      	s32i.n	a5, a1, 60
ffe04ec9:	106162        	s32i	a6, a1, 64
ffe04ecc:	116172        	s32i	a7, a1, 68
    if(TRUE == HAL_StrapUartEn())
ffe04ecf:	f2ad91        	l32r	a9, ffe01984 <_bss_table_end+0x8>
ffe04ed2:	0020c0        	memw
ffe04ed5:	180c      	movi.n	a8, 1
ffe04ed7:	e998      	l32i.n	a9, a9, 56
ffe04ed9:	0b0c      	movi.n	a11, 0
ffe04edb:	049290        	extui	a9, a9, 2, 1
ffe04ede:	83b890        	moveqz	a11, a8, a9
ffe04ee1:	571b66        	bnei	a11, 1, ffe04f3c <dbg_printf+0x7c>
    {
        const char *s;
        int d;
        char buf[16];
        va_list ap;
        va_start(ap, fmt);
ffe04ee4:	470c      	movi.n	a7, 4
        while (*fmt) {
ffe04ee6:	000252        	l8ui	a5, a2, 0
    {
        const char *s;
        int d;
        char buf[16];
        va_list ap;
        va_start(ap, fmt);
ffe04ee9:	30c142        	addi	a4, a1, 48
        while (*fmt) {
ffe04eec:	04c516        	beqz	a5, ffe04f3c <dbg_printf+0x7c>
ffe04eef:	f2fe61        	l32r	a6, ffe01ae8 <_bss_table_end+0x16c>
ffe04ef2:	8a1c      	movi.n	a10, 24
ffe04ef4:	532c      	movi.n	a3, 37
ffe04ef6:	f35db1        	l32r	a11, ffe01c6c <_bss_table_end+0x2f0>
ffe04ef9:	8149      	s32i.n	a4, a1, 32
ffe04efb:	11c182        	addi	a8, a1, 17
ffe04efe:	9189      	s32i.n	a8, a1, 36

ffe04f00 <dbg_printf+0x40>:
            if (*fmt != '%') {
ffe04f00:	0a1537        	beq	a5, a3, ffe04f0e <dbg_printf+0x4e>
                dbg_putchar(*fmt++);
ffe04f03:	221b      	addi.n	a2, a2, 1
}

static void dbg_putchar(char c)
{
    //    uart_putchar(c);
    rUART_TXR = c;
ffe04f05:	0020c0        	memw
ffe04f08:	844652        	s8i	a5, a6, 132
        va_list ap;
        va_start(ap, fmt);
        while (*fmt) {
            if (*fmt != '%') {
                dbg_putchar(*fmt++);
                continue;
ffe04f0b:	0009c6        	j	ffe04f36 <dbg_printf+0x76>

ffe04f0e <dbg_printf+0x4e>:
            }
            switch (*++fmt) {
ffe04f0e:	010242        	l8ui	a4, a2, 1
ffe04f11:	521b      	addi.n	a5, a2, 1
ffe04f13:	a159      	s32i.n	a5, a1, 40
ffe04f15:	30c122        	addi	a2, a1, 48
ffe04f18:	64a052        	movi	a5, 100
ffe04f1b:	221457        	beq	a4, a5, ffe04f41 <dbg_printf+0x81>
ffe04f1e:	8dc482        	addi	a8, a4, -115
ffe04f21:	0aa816        	beqz	a8, ffe04fcf <dbg_printf+0x10f>
ffe04f24:	88c432        	addi	a3, a4, -120
ffe04f27:	0d1316        	beqz	a3, ffe04ffc <dbg_printf+0x13c>
                        //    dbg_putchar(*s);
                    }
                    break;

                default:
                    rUART_TXR = *fmt;
ffe04f2a:	0020c0        	memw
ffe04f2d:	844642        	s8i	a4, a6, 132
                    //dbg_putchar(*fmt);
                    break;
            }
            fmt++;
ffe04f30:	a128      	l32i.n	a2, a1, 40
ffe04f32:	532c      	movi.n	a3, 37
ffe04f34:	221b      	addi.n	a2, a2, 1
        const char *s;
        int d;
        char buf[16];
        va_list ap;
        va_start(ap, fmt);
        while (*fmt) {
ffe04f36:	000252        	l8ui	a5, a2, 0
ffe04f39:	fc3556        	bnez	a5, ffe04f00 <dbg_printf+0x40>
    }  
    else  // if uart disabled 
    {
        // return 
    }
}
ffe04f3c:	50c112        	addi	a1, a1, 80
ffe04f3f:	f00d      	ret.n

ffe04f41 <dbg_printf+0x81>:
                        //    dbg_putchar(*s);    
                        rUART_TXR = *s;
                    }
                    break;
                case 'd':
                    d = va_arg(ap, int);
ffe04f41:	073d      	mov.n	a3, a7
ffe04f43:	774b      	addi.n	a7, a7, 4
ffe04f45:	06aa77        	bge	a10, a7, ffe04f4f <dbg_printf+0x8f>
ffe04f48:	012a37        	blt	a10, a3, ffe04f4d <dbg_printf+0x8d>
ffe04f4b:	472c      	movi.n	a7, 36
ffe04f4d:	8128      	l32i.n	a2, a1, 32
ffe04f4f:	272a      	add.n	a2, a7, a2
ffe04f51:	ffd222        	addmi	a2, a2, 0xffffff00
ffe04f54:	3f2222        	l32i	a2, a2, 252
ffe04f57:	023d      	mov.n	a3, a2
ffe04f59:	02dc      	bnez.n	a2, ffe04f6d <dbg_printf+0xad>
        return string;
    }

    if (!value)
    {
        *ptr++ = 0x30;
ffe04f5b:	023c      	movi.n	a2, 48
        *ptr = 0;
ffe04f5d:	030c      	movi.n	a3, 0
        return string;
    }

    if (!value)
    {
        *ptr++ = 0x30;
ffe04f5f:	10c142        	addi	a4, a1, 16
ffe04f62:	053c      	movi.n	a5, 48
ffe04f64:	004452        	s8i	a5, a4, 0
        *ptr = 0;
ffe04f67:	014432        	s8i	a3, a4, 1
ffe04f6a:	0011c6        	j	ffe04fb5 <dbg_printf+0xf5>

ffe04f6d <dbg_printf+0xad>:
        *ptr++ = '-';

        value *= -1;
    }

    for (i = 10000; i > 0; i /= 10)
ffe04f6d:	0b0c      	movi.n	a11, 0
        *ptr++ = 0x30;
        *ptr = 0;
        return string;
    }

    if (value < 0)
ffe04f6f:	00f2d6        	bgez	a2, ffe04f82 <dbg_printf+0xc2>
    {
        *ptr++ = '-';

        value *= -1;
ffe04f72:	603020        	neg	a3, a2
        return string;
    }

    if (value < 0)
    {
        *ptr++ = '-';
ffe04f75:	9148      	l32i.n	a4, a1, 36
ffe04f77:	10c192        	addi	a9, a1, 16
ffe04f7a:	d82c      	movi.n	a8, 45
ffe04f7c:	004982        	s8i	a8, a9, 0

        value *= -1;
ffe04f7f:	000086        	j	ffe04f85 <dbg_printf+0xc5>

ffe04f82 <dbg_printf+0xc2>:
ffe04f82:	10c142        	addi	a4, a1, 16
    }

    for (i = 10000; i > 0; i /= 10)
ffe04f85:	f33a21        	l32r	a2, ffe01c70 <_bss_table_end+0x2f4>
    {
        d = value / i;

        if (d || flag)
ffe04f88:	d25320        	quos	a5, a3, a2
ffe04f8b:	05cc      	bnez.n	a5, ffe04f8f <dbg_printf+0xcf>
ffe04f8d:	eb8c      	beqz.n	a11, ffe04f9f <dbg_printf+0xdf>
        {
            *ptr++ = (char)(d + 0x30);
            value -= (d * i);
ffe04f8f:	1b0c      	movi.n	a11, 1
    {
        d = value / i;

        if (d || flag)
        {
            *ptr++ = (char)(d + 0x30);
ffe04f91:	30c592        	addi	a9, a5, 48
            value -= (d * i);
ffe04f94:	828520        	mull	a8, a5, a2
    {
        d = value / i;

        if (d || flag)
        {
            *ptr++ = (char)(d + 0x30);
ffe04f97:	004492        	s8i	a9, a4, 0
ffe04f9a:	441b      	addi.n	a4, a4, 1
            value -= (d * i);
ffe04f9c:	c03380        	sub	a3, a3, a8
        *ptr++ = '-';

        value *= -1;
    }

    for (i = 10000; i > 0; i /= 10)
ffe04f9f:	a50c      	movi.n	a5, 10
ffe04fa1:	d22250        	quos	a2, a2, a5
ffe04fa4:	e012e6        	bgei	a2, 1, ffe04f88 <dbg_printf+0xc8>
            value -= (d * i);
            flag = 1;
        }
    }

    *ptr = 0;
ffe04fa7:	10c122        	addi	a2, a1, 16
ffe04faa:	030c      	movi.n	a3, 0
ffe04fac:	004432        	s8i	a3, a4, 0
ffe04faf:	000222        	l8ui	a2, a2, 0
ffe04fb2:	f32eb1        	l32r	a11, ffe01c6c <_bss_table_end+0x2f0>
                    }
                    break;
                case 'd':
                    d = va_arg(ap, int);
                    itoa(d, buf, 10);
                    for (s = buf; *s; s++) {
ffe04fb5:	f77216        	beqz	a2, ffe04f30 <dbg_printf+0x70>
ffe04fb8:	10c122        	addi	a2, a1, 16
                        //    dbg_putchar(*s);
                        rUART_TXR = *s;
ffe04fbb:	000252        	l8ui	a5, a2, 0
ffe04fbe:	0020c0        	memw
ffe04fc1:	844652        	s8i	a5, a6, 132
                    }
                    break;
                case 'd':
                    d = va_arg(ap, int);
                    itoa(d, buf, 10);
                    for (s = buf; *s; s++) {
ffe04fc4:	010242        	l8ui	a4, a2, 1
ffe04fc7:	221b      	addi.n	a2, a2, 1
ffe04fc9:	fee456        	bnez	a4, ffe04fbb <dbg_printf+0xfb>
ffe04fcc:	ffd806        	j	ffe04f30 <dbg_printf+0x70>

ffe04fcf <dbg_printf+0x10f>:
                dbg_putchar(*fmt++);
                continue;
            }
            switch (*++fmt) {
                case 's':
                    s = va_arg(ap, const char *);
ffe04fcf:	073d      	mov.n	a3, a7
ffe04fd1:	774b      	addi.n	a7, a7, 4
ffe04fd3:	06aa77        	bge	a10, a7, ffe04fdd <dbg_printf+0x11d>
ffe04fd6:	012a37        	blt	a10, a3, ffe04fdb <dbg_printf+0x11b>
ffe04fd9:	472c      	movi.n	a7, 36
ffe04fdb:	8128      	l32i.n	a2, a1, 32
ffe04fdd:	272a      	add.n	a2, a7, a2
ffe04fdf:	ffd222        	addmi	a2, a2, 0xffffff00
ffe04fe2:	3f2222        	l32i	a2, a2, 252
                    for ( ; *s; s++) {
ffe04fe5:	000232        	l8ui	a3, a2, 0
ffe04fe8:	f44316        	beqz	a3, ffe04f30 <dbg_printf+0x70>
                        //    dbg_putchar(*s);    
                        rUART_TXR = *s;
ffe04feb:	0020c0        	memw
ffe04fee:	844632        	s8i	a3, a6, 132
                continue;
            }
            switch (*++fmt) {
                case 's':
                    s = va_arg(ap, const char *);
                    for ( ; *s; s++) {
ffe04ff1:	010232        	l8ui	a3, a2, 1
ffe04ff4:	221b      	addi.n	a2, a2, 1
ffe04ff6:	ff1356        	bnez	a3, ffe04feb <dbg_printf+0x12b>
ffe04ff9:	ffccc6        	j	ffe04f30 <dbg_printf+0x70>

ffe04ffc <dbg_printf+0x13c>:
ffe04ffc:	850c      	movi.n	a5, 8
                        //    dbg_putchar(*s);
                        rUART_TXR = *s;
                    }
                    break;
                case 'x':
                    d = va_arg(ap, int);
ffe04ffe:	073d      	mov.n	a3, a7
ffe05000:	774b      	addi.n	a7, a7, 4
ffe05002:	06aa77        	bge	a10, a7, ffe0500c <dbg_printf+0x14c>
ffe05005:	012a37        	blt	a10, a3, ffe0500a <dbg_printf+0x14a>
ffe05008:	472c      	movi.n	a7, 36
ffe0500a:	8128      	l32i.n	a2, a1, 32
static char *utohex(unsigned int value, char *string, int radix)
{
    int i,p;
    int oupt;
    oupt = 0;
    for (i=0;i<32;i+=4)
ffe0500c:	c31c      	movi.n	a3, 28
                        //    dbg_putchar(*s);
                        rUART_TXR = *s;
                    }
                    break;
                case 'x':
                    d = va_arg(ap, int);
ffe0500e:	804720        	add	a4, a7, a2
    {
        p = (value >> (28 - i))&0xf;
        string[oupt++]=mc[p];
    }

    string[oupt]=NULL;
ffe05011:	00a092        	movi	a9, 0
static char *utohex(unsigned int value, char *string, int radix)
{
    int i,p;
    int oupt;
    oupt = 0;
    for (i=0;i<32;i+=4)
ffe05014:	10c122        	addi	a2, a1, 16
                        //    dbg_putchar(*s);
                        rUART_TXR = *s;
                    }
                    break;
                case 'x':
                    d = va_arg(ap, int);
ffe05017:	ffd442        	addmi	a4, a4, 0xffffff00
ffe0501a:	3f2442        	l32i	a4, a4, 252
ffe0501d:	15a576        	loopgtz	a5, ffe05036 <dbg_printf+0x176>
    int oupt;
    oupt = 0;
    for (i=0;i<32;i+=4)
    {
        p = (value >> (28 - i))&0xf;
        string[oupt++]=mc[p];
ffe05020:	400300        	ssr	a3
ffe05023:	915040        	srl	a5, a4
static char *utohex(unsigned int value, char *string, int radix)
{
    int i,p;
    int oupt;
    oupt = 0;
    for (i=0;i<32;i+=4)
ffe05026:	fcc332        	addi	a3, a3, -4
    {
        p = (value >> (28 - i))&0xf;
        string[oupt++]=mc[p];
ffe05029:	345050        	extui	a5, a5, 0, 4
ffe0502c:	5b5a      	add.n	a5, a11, a5
ffe0502e:	800552        	l8ui	a5, a5, 128
ffe05031:	004252        	s8i	a5, a2, 0
ffe05034:	221b      	addi.n	a2, a2, 1

ffe05036 <dbg_printf+0x176>:
    }

    string[oupt]=NULL;
ffe05036:	10c122        	addi	a2, a1, 16
                    }
                    break;
                case 'x':
                    d = va_arg(ap, int);
                    utohex(d, buf, 16);
                    for (s = buf; *s; s++) {
ffe05039:	000282        	l8ui	a8, a2, 0
    {
        p = (value >> (28 - i))&0xf;
        string[oupt++]=mc[p];
    }

    string[oupt]=NULL;
ffe0503c:	084292        	s8i	a9, a2, 8
                    }
                    break;
                case 'x':
                    d = va_arg(ap, int);
                    utohex(d, buf, 16);
                    for (s = buf; *s; s++) {
ffe0503f:	eed816        	beqz	a8, ffe04f30 <dbg_printf+0x70>

ffe05042 <dbg_printf+0x182>:
                        rUART_TXR = *s;
ffe05042:	000242        	l8ui	a4, a2, 0
ffe05045:	0020c0        	memw
ffe05048:	844642        	s8i	a4, a6, 132
                    }
                    break;
                case 'x':
                    d = va_arg(ap, int);
                    utohex(d, buf, 16);
                    for (s = buf; *s; s++) {
ffe0504b:	010232        	l8ui	a3, a2, 1
ffe0504e:	221b      	addi.n	a2, a2, 1
ffe05050:	fee356        	bnez	a3, ffe05042 <dbg_printf+0x182>
ffe05053:	ffb646        	j	ffe04f30 <dbg_printf+0x70>

ffe05056 <dbg_printf+0x196>:
	...

ffe05058 <HAL_MemCpy>:
ffe05058:	f03d      	nop.n
Description :
Others      :
Modify      :
****************************************************************************/
void HAL_MemCpy(U32* TargetAddr,U32* SrcAddr,U32 LengthDW)
{
ffe0505a:	079476        	loopnez	a4, ffe05065 <HAL_MemCpy+0xd>
    U32 i;

    for (i = 0 ; i < LengthDW; i++)
    {
        *TargetAddr++ = *SrcAddr++;
ffe0505d:	0348      	l32i.n	a4, a3, 0
ffe0505f:	0249      	s32i.n	a4, a2, 0
ffe05061:	334b      	addi.n	a3, a3, 4
ffe05063:	224b      	addi.n	a2, a2, 4

ffe05065 <HAL_MemCpy+0xd>:
    }
}
ffe05065:	f00d      	ret.n

ffe05067 <HAL_MemCpy+0xf>:
	...

ffe05068 <HAL_SpiDmaRead>:
    2014/11/17 Victor Zhang  reconstruct

*******************************************************************************/

GLOBAL void HAL_SpiDmaRead(U32 ulDst,U32 ulSrc,U32 ulLenB)
{
ffe05068:	e0c112        	addi	a1, a1, -32
ffe0506b:	31e9      	s32i.n	a14, a1, 12
ffe0506d:	0109      	s32i.n	a0, a1, 0
ffe0506f:	41f9      	s32i.n	a15, a1, 16
ffe05071:	11c9      	s32i.n	a12, a1, 4
ffe05073:	21d9      	s32i.n	a13, a1, 8
ffe05075:	03cd      	mov.n	a12, a3
ffe05077:	02dd      	mov.n	a13, a2
ffe05079:	04fd      	mov.n	a15, a4
ffe0507b:	d49c      	beqz.n	a4, ffe0509c <HAL_SpiDmaRead+0x34>
    U32 ulCurSrcAddr = ulSrcAddr;
    U32 ulRemainLen = ulBlockLenInByte;

    while (ulRemainLen > 0)
    {
        if ( ulRemainLen >= DMAE_ENTRY_MAX_LENGTH_IN_BYTE)
ffe0507d:	f2bee1        	l32r	a14, ffe01b78 <_bss_table_end+0x1fc>

ffe05080 <HAL_SpiDmaRead+0x18>:
ffe05080:	63efe0        	minu	a14, a15, a14
        else
        {
            ulCurCopyLen = ulRemainLen;
        }

        while (FALSE == HAL_DMAECopyOneBlockLenLimit(ulCurDesAddr, ulCurSrcAddr, ulCurCopyLen))
ffe05083:	0d2d      	mov.n	a2, a13
ffe05085:	0c3d      	mov.n	a3, a12
ffe05087:	0e4d      	mov.n	a4, a14
ffe05089:	ffbd85        	call0	ffe04c64 <HAL_DMAECopyOneBlockLenLimit..B_1429880325>
ffe0508c:	ff3216        	beqz	a2, ffe05083 <HAL_SpiDmaRead+0x1b>
        {
        }

        ulRemainLen -= ulCurCopyLen;
        ulCurDesAddr += ulCurCopyLen;
ffe0508f:	deda      	add.n	a13, a14, a13
        ulCurSrcAddr += ulCurCopyLen;
ffe05091:	ceca      	add.n	a12, a14, a12

        while (FALSE == HAL_DMAECopyOneBlockLenLimit(ulCurDesAddr, ulCurSrcAddr, ulCurCopyLen))
        {
        }

        ulRemainLen -= ulCurCopyLen;
ffe05093:	c0ffe0        	sub	a15, a15, a14
    U32 ulCurSrcAddr = ulSrcAddr;
    U32 ulRemainLen = ulBlockLenInByte;

    while (ulRemainLen > 0)
    {
        if ( ulRemainLen >= DMAE_ENTRY_MAX_LENGTH_IN_BYTE)
ffe05096:	f2b8e1        	l32r	a14, ffe01b78 <_bss_table_end+0x1fc>
    U32 ulCurCopyLen;
    U32 ulCurDesAddr = ulDesAddr;
    U32 ulCurSrcAddr = ulSrcAddr;
    U32 ulRemainLen = ulBlockLenInByte;

    while (ulRemainLen > 0)
ffe05099:	fe3f56        	bnez	a15, ffe05080 <HAL_SpiDmaRead+0x18>
    HAL_DMAECopyOneBlock((const U32)ulDst,(const U32)ulSrc,ulLenB);    
}
ffe0509c:	11c8      	l32i.n	a12, a1, 4
ffe0509e:	21d8      	l32i.n	a13, a1, 8
ffe050a0:	31e8      	l32i.n	a14, a1, 12
ffe050a2:	41f8      	l32i.n	a15, a1, 16
ffe050a4:	0108      	l32i.n	a0, a1, 0
ffe050a6:	20c112        	addi	a1, a1, 32
ffe050a9:	f00d      	ret.n

ffe050ab <HAL_SpiDmaRead+0x43>:
	...

ffe050ac <HAL_FlashBoot>:
        <2> start pcie/sata if required then execute bootloader 
        <3> accumulate pu then try <1> 
*************************************************/

void HAL_FlashBoot(void)
{
ffe050ac:	d0c112        	addi	a1, a1, -48
ffe050af:	11c9      	s32i.n	a12, a1, 4
ffe050b1:	21d9      	s32i.n	a13, a1, 8
ffe050b3:	0109      	s32i.n	a0, a1, 0
ffe050b5:	f23301        	l32r	a0, ffe01984 <_bss_table_end+0x8>
ffe050b8:	31e9      	s32i.n	a14, a1, 12
    U32 ulPu,ulFuncId,ulStatus,ulBootFuncNum;

    for (ulPu=0;ulPu<l_ucCeMax;ulPu++)
ffe050ba:	000002        	l8ui	a0, a0, 0
        <2> start pcie/sata if required then execute bootloader 
        <3> accumulate pu then try <1> 
*************************************************/

void HAL_FlashBoot(void)
{
ffe050bd:	41f9      	s32i.n	a15, a1, 16
    U32 ulPu,ulFuncId,ulStatus,ulBootFuncNum;

    for (ulPu=0;ulPu<l_ucCeMax;ulPu++)
ffe050bf:	055016        	beqz	a0, ffe05118 <HAL_FlashBoot+0x6c>
ffe050c2:	0f0c      	movi.n	a15, 0
ffe050c4:	f2ed51        	l32r	a5, ffe01c78 <_bss_table_end+0x2fc>
ffe050c7:	f2eb61        	l32r	a6, ffe01c74 <_bss_table_end+0x2f8>
ffe050ca:	6169      	s32i.n	a6, a1, 24
ffe050cc:	7159      	s32i.n	a5, a1, 28

ffe050ce <HAL_FlashBoot+0x22>:
    {
        for (ulFuncId=0;ulFuncId<FUNC_INDEX_NUM;ulFuncId++)
ffe050ce:	0e0c      	movi.n	a14, 0
ffe050d0:	f27fd1        	l32r	a13, ffe01acc <_bss_table_end+0x150>
ffe050d3:	61c8      	l32i.n	a12, a1, 24
ffe050d5:	7470f0        	extui	a7, a15, 0, 8
ffe050d8:	5179      	s32i.n	a7, a1, 20
        {
            DBG_TRACE(TRACE_NFC_PRO(ulFuncId) + ulPu);
ffe050da:	0020c0        	memw
ffe050dd:	f27221        	l32r	a2, ffe01aa8 <_bss_table_end+0x12c>
            ulStatus = l_pNFBoot[ulFuncId](ulPu);
ffe050e0:	8d08      	l32i.n	a0, a13, 32

    for (ulPu=0;ulPu<l_ucCeMax;ulPu++)
    {
        for (ulFuncId=0;ulFuncId<FUNC_INDEX_NUM;ulFuncId++)
        {
            DBG_TRACE(TRACE_NFC_PRO(ulFuncId) + ulPu);
ffe050e2:	a062c2        	s32i	a12, a2, 0x280
            ulStatus = l_pNFBoot[ulFuncId](ulPu);
ffe050e5:	5128      	l32i.n	a2, a1, 20
ffe050e7:	0000c0        	callx0	a0
ffe050ea:	020d      	mov.n	a0, a2
ffe050ec:	8129      	s32i.n	a2, a1, 32
            if (FAIL == ulStatus)
ffe050ee:	52bc      	beqz.n	a2, ffe05127 <HAL_FlashBoot+0x7b>
{
    U32 ulPu,ulFuncId,ulStatus,ulBootFuncNum;

    for (ulPu=0;ulPu<l_ucCeMax;ulPu++)
    {
        for (ulFuncId=0;ulFuncId<FUNC_INDEX_NUM;ulFuncId++)
ffe050f0:	dd4b      	addi.n	a13, a13, 4
ffe050f2:	ee1b      	addi.n	a14, a14, 1
ffe050f4:	f2e241        	l32r	a4, ffe01c7c <_bss_table_end+0x300>
ffe050f7:	7138      	l32i.n	a3, a1, 28
ffe050f9:	cc4a      	add.n	a12, a12, a4
ffe050fb:	db9c37        	bne	a12, a3, ffe050da <HAL_FlashBoot+0x2e>
                DBG_Printf("PU %d %s failed\n",ulPu,BootString[ulFuncId]);
                break;
            }
        }

        if (SUCCESS == ulStatus)
ffe050fe:	3d1026        	beqi	a0, 1, ffe0513f <HAL_FlashBoot+0x93>

void HAL_FlashBoot(void)
{
    U32 ulPu,ulFuncId,ulStatus,ulBootFuncNum;

    for (ulPu=0;ulPu<l_ucCeMax;ulPu++)
ffe05101:	ff1b      	addi.n	a15, a15, 1
ffe05103:	7168      	l32i.n	a6, a1, 28
ffe05105:	f21f51        	l32r	a5, ffe01984 <_bss_table_end+0x8>
ffe05108:	6178      	l32i.n	a7, a1, 24
ffe0510a:	000552        	l8ui	a5, a5, 0
ffe0510d:	771b      	addi.n	a7, a7, 1
ffe0510f:	661b      	addi.n	a6, a6, 1
ffe05111:	7169      	s32i.n	a6, a1, 28
ffe05113:	6179      	s32i.n	a7, a1, 24
ffe05115:	b53f57        	bltu	a15, a5, ffe050ce <HAL_FlashBoot+0x22>
            HAL_StrapResetHostIF();
            DBG_Printf("Flash Boot successfully , boot entry is 0x%x\n",l_pBootEntry);
            break;
        }
    }
}
ffe05118:	11c8      	l32i.n	a12, a1, 4
ffe0511a:	21d8      	l32i.n	a13, a1, 8
ffe0511c:	31e8      	l32i.n	a14, a1, 12
ffe0511e:	41f8      	l32i.n	a15, a1, 16
ffe05120:	0108      	l32i.n	a0, a1, 0
ffe05122:	30c112        	addi	a1, a1, 48
ffe05125:	f00d      	ret.n

ffe05127 <HAL_FlashBoot+0x7b>:
        {
            DBG_TRACE(TRACE_NFC_PRO(ulFuncId) + ulPu);
            ulStatus = l_pNFBoot[ulFuncId](ulPu);
            if (FAIL == ulStatus)
            {
                DBG_Printf("PU %d %s failed\n",ulPu,BootString[ulFuncId]);
ffe05127:	f2d621        	l32r	a2, ffe01c80 <_bss_table_end+0x304>
ffe0512a:	0f3d      	mov.n	a3, a15
ffe0512c:	f26841        	l32r	a4, ffe01acc <_bss_table_end+0x150>
ffe0512f:	115ec0        	slli	a5, a14, 4
ffe05132:	445a      	add.n	a4, a4, a5
ffe05134:	30c442        	addi	a4, a4, 48
ffe05137:	ffd885        	call0	ffe04ec0 <dbg_printf>
ffe0513a:	8108      	l32i.n	a0, a1, 32
                break;
ffe0513c:	ffef86        	j	ffe050fe <HAL_FlashBoot+0x52>

ffe0513f <HAL_FlashBoot+0x93>:
            }
        }

        if (SUCCESS == ulStatus)
        {
            DBG_TRACE(TRACE_SUCCESS);
ffe0513f:	f22091        	l32r	a9, ffe019c0 <_bss_table_end+0x44>
ffe05142:	0020c0        	memw
            l_pBootEntry = (PFUNC)HAL_NfcGetBootLoaderEntry();
ffe05145:	f2cf71        	l32r	a7, ffe01c84 <_bss_table_end+0x308>
            }
        }

        if (SUCCESS == ulStatus)
        {
            DBG_TRACE(TRACE_SUCCESS);
ffe05148:	f258a1        	l32r	a10, ffe01aa8 <_bss_table_end+0x12c>

*************************************************/

void HAL_StrapResetHostIF(void)
{
    if(TRUE == HAL_StrapIsSetHwFrEfuse())
ffe0514b:	f20e81        	l32r	a8, ffe01984 <_bss_table_end+0x8>
ffe0514e:	a06a92        	s32i	a9, a10, 0x280
ffe05151:	d868      	l32i.n	a6, a8, 52
            l_pBootEntry = (PFUNC)HAL_NfcGetBootLoaderEntry();
ffe05153:	1879      	s32i.n	a7, a8, 4
ffe05155:	4d1666        	bnei	a6, 1, ffe051a6 <HAL_FlashBoot+0xfa>
    {
        if (1 == l_pEfuseFile->bsHostIF_Reset)
ffe05158:	f20bb1        	l32r	a11, ffe01984 <_bss_table_end+0x8>
ffe0515b:	f292c1        	l32r	a12, ffe01ba4 <_bss_table_end+0x228>
ffe0515e:	cbb8      	l32i.n	a11, a11, 48
ffe05160:	0020c0        	memw
ffe05163:	3bb8      	l32i.n	a11, a11, 12
ffe05165:	10bbc0        	and	a11, a11, a12
ffe05168:	85b7b0        	extui	a11, a11, 23, 9
ffe0516b:	371b66        	bnei	a11, 1, ffe051a6 <HAL_FlashBoot+0xfa>
        {
            if (TRUE == HAL_StrapIsPcie())
ffe0516e:	0020c0        	memw
ffe05171:	f204c1        	l32r	a12, ffe01984 <_bss_table_end+0x8>
ffe05174:	ecc8      	l32i.n	a12, a12, 56
ffe05176:	176c37        	bbci	a12, 3, ffe05191 <HAL_FlashBoot+0xe5>
            {
                rGLB(0x18) &= ~(1<<29); 
ffe05179:	f213f1        	l32r	a15, ffe019c8 <_bss_table_end+0x4c>
ffe0517c:	0020c0        	memw
ffe0517f:	f24ae1        	l32r	a14, ffe01aa8 <_bss_table_end+0x12c>
ffe05182:	862ed2        	l32i	a13, a14, 0x218
ffe05185:	10ddf0        	and	a13, a13, a15
ffe05188:	0020c0        	memw
ffe0518b:	866ed2        	s32i	a13, a14, 0x218
ffe0518e:	000506        	j	ffe051a6 <HAL_FlashBoot+0xfa>

ffe05191 <HAL_FlashBoot+0xe5>:
            }
            else
            {
                rGLB(0x18) &= ~(0xf<<8);
ffe05191:	f27831        	l32r	a3, ffe01b74 <_bss_table_end+0x1f8>
ffe05194:	0020c0        	memw
ffe05197:	f24421        	l32r	a2, ffe01aa8 <_bss_table_end+0x12c>
ffe0519a:	862202        	l32i	a0, a2, 0x218
ffe0519d:	100030        	and	a0, a0, a3
ffe051a0:	0020c0        	memw
ffe051a3:	866202        	s32i	a0, a2, 0x218
            HAL_StrapResetHostIF();
            DBG_Printf("Flash Boot successfully , boot entry is 0x%x\n",l_pBootEntry);
ffe051a6:	f2b821        	l32r	a2, ffe01c88 <_bss_table_end+0x30c>
ffe051a9:	f2b631        	l32r	a3, ffe01c84 <_bss_table_end+0x308>
ffe051ac:	ffd105        	call0	ffe04ec0 <dbg_printf>
            break;
ffe051af:	ffd946        	j	ffe05118 <HAL_FlashBoot+0x6c>

ffe051b2 <HAL_FlashBoot+0x106>:
	...

ffe051b4 <HAL_HwInit>:

*/
void HAL_StrapCheckEfuse(void)
{
    l_bIsEfuseMode = FALSE;
    l_bSetHwFrEfuse = FALSE;
ffe051b4:	060c      	movi.n	a6, 0
    1. check efuse be valid and set HW if valid
    2. Init NFC module
*************************************************/

void HAL_HwInit(void)
{
ffe051b6:	170c      	movi.n	a7, 1
ffe051b8:	f0c112        	addi	a1, a1, -16
ffe051bb:	21d9      	s32i.n	a13, a1, 8
ffe051bd:	11c9      	s32i.n	a12, a1, 4
ffe051bf:	0109      	s32i.n	a0, a1, 0
    l_bIsEfuseMode = TRUE;
    l_bSetHwFrEfuse = TRUE;
    HAL_StrapEfuseSetHW();
#else 
    // check if the efuse be programed 
    if (TRUE == l_pEfuseRegSet->bsProgramed)
ffe051c1:	f24201        	l32r	a0, ffe01acc <_bss_table_end+0x150>
ffe051c4:	f1f0c1        	l32r	a12, ffe01984 <_bss_table_end+0x8>
ffe051c7:	2008      	l32i.n	a0, a0, 8
ffe051c9:	0020c0        	memw
ffe051cc:	102022        	l32i	a2, a0, 64
ffe051cf:	d47c      	movi.n	a4, -3
ffe051d1:	416207        	bbci	a2, 0, ffe05216 <HAL_HwInit+0x62>
ffe051d4:	230c      	movi.n	a3, 2

ffe051d6 <HAL_HwInit+0x22>:
        l_bIsEfuseMode = TRUE;    

        // try to read the efuse
        do
        {
            l_pEfuseRegSet->bsDataValid = TRUE;
ffe051d6:	0020c0        	memw
ffe051d9:	102052        	l32i	a5, a0, 64
ffe051dc:	105540        	and	a5, a5, a4
ffe051df:	205530        	or	a5, a5, a3
ffe051e2:	0020c0        	memw
ffe051e5:	106052        	s32i	a5, a0, 64
        }while (FALSE == l_pEfuseRegSet->bsDataValid);
ffe051e8:	0020c0        	memw
ffe051eb:	102022        	l32i	a2, a0, 64
ffe051ee:	e46217        	bbci	a2, 1, ffe051d6 <HAL_HwInit+0x22>
        
        l_pEfuseFile = (volatile EFUSE_FILE *)(REG_BASE_EFUSE);
ffe051f1:	f2a601        	l32r	a0, ffe01c8c <_bss_table_end+0x310>
ffe051f4:	cc09      	s32i.n	a0, a12, 48

BOOL HAL_StrapEfuseCheckSum(void)
{
    U8 *pBuf = (U8*)l_pEfuseFile;
    U8 ucCheckSum,i;
    ucCheckSum = l_pEfuseFile->bsCheckSum;
ffe051f6:	0020c0        	memw
ffe051f9:	1f0032        	l8ui	a3, a0, 31
    for (i = 0;i<(EFUSE_WDATA_DEPTH*sizeof(U32)-1);i++)
ffe051fc:	040c      	movi.n	a4, 0
ffe051fe:	f2a451        	l32r	a5, ffe01c90 <_bss_table_end+0x314>
ffe05201:	f81c      	movi.n	a8, 31
ffe05203:	0ca876        	loopgtz	a8, ffe05213 <HAL_HwInit+0x5f>
ffe05206:	a41b      	addi.n	a10, a4, 1
    {
        ucCheckSum ^= pBuf[i];
ffe05208:	945a      	add.n	a9, a4, a5
ffe0520a:	800992        	l8ui	a9, a9, 128
BOOL HAL_StrapEfuseCheckSum(void)
{
    U8 *pBuf = (U8*)l_pEfuseFile;
    U8 ucCheckSum,i;
    ucCheckSum = l_pEfuseFile->bsCheckSum;
    for (i = 0;i<(EFUSE_WDATA_DEPTH*sizeof(U32)-1);i++)
ffe0520d:	7440a0        	extui	a4, a10, 0, 8
    {
        ucCheckSum ^= pBuf[i];
ffe05210:	303930        	xor	a3, a9, a3

ffe05213 <HAL_HwInit+0x5f>:
            l_pEfuseRegSet->bsDataValid = TRUE;
        }while (FALSE == l_pEfuseRegSet->bsDataValid);
        
        l_pEfuseFile = (volatile EFUSE_FILE *)(REG_BASE_EFUSE);

        if(FAIL == HAL_StrapEfuseCheckSum())
ffe05213:	074316        	beqz	a3, ffe0528b <HAL_HwInit+0xd7>

ffe05216 <HAL_HwInit+0x62>:
ffe05216:	dc69      	s32i.n	a6, a12, 52
ffe05218:	000046        	j	ffe0521d <HAL_HwInit+0x69>

ffe0521b <HAL_HwInit+0x67>:

        // check the data be valid for HW init
        if (TRUE == l_pEfuseFile->bsIsEfuseSet)    
        {   
            l_bSetHwFrEfuse = TRUE;
            HAL_StrapEfuseSetHW();   // init HW 
ffe0521b:	dc69      	s32i.n	a6, a12, 52
*************************************************/

LOCAL void HalNfcInitInterface(void)
{
    pNFCQDptr   =   (volatile NFCQ_DPTR*)   DPTR_BASE_ADDRESS;   
    pNFCQArray  =   (volatile NFCQ_ARRAY *) CQ_ENTRY_BASE;
ffe0521d:	f29e01        	l32r	a0, ffe01c98 <_bss_table_end+0x31c>
    pPrcqArray  =   (volatile PRCQ_ARRAY *) PRCQ_ENTRY_BASE;
    //pRedEntry   =   (volatile RED_ENTRY *)  RED_BASE_ADDRESS; 
    pNfcTrigger =   (volatile NFCQ_TRIGGER_REG *) REG_BASE_NDC_TRIG;
    pNfcQEEntry =   (volatile QEE_ENTRY_REG*)PRCQ_QEE_BASE;
ffe05220:	f2a1a1        	l32r	a10, ffe01ca4 <_bss_table_end+0x328>
{
    pNFCQDptr   =   (volatile NFCQ_DPTR*)   DPTR_BASE_ADDRESS;   
    pNFCQArray  =   (volatile NFCQ_ARRAY *) CQ_ENTRY_BASE;
    pPrcqArray  =   (volatile PRCQ_ARRAY *) PRCQ_ENTRY_BASE;
    //pRedEntry   =   (volatile RED_ENTRY *)  RED_BASE_ADDRESS; 
    pNfcTrigger =   (volatile NFCQ_TRIGGER_REG *) REG_BASE_NDC_TRIG;
ffe05223:	f29fb1        	l32r	a11, ffe01ca0 <_bss_table_end+0x324>

LOCAL void HalNfcInitInterface(void)
{
    pNFCQDptr   =   (volatile NFCQ_DPTR*)   DPTR_BASE_ADDRESS;   
    pNFCQArray  =   (volatile NFCQ_ARRAY *) CQ_ENTRY_BASE;
    pPrcqArray  =   (volatile PRCQ_ARRAY *) PRCQ_ENTRY_BASE;
ffe05226:	f29dd1        	l32r	a13, ffe01c9c <_bss_table_end+0x320>
    Initialize pointers.
*************************************************/

LOCAL void HalNfcInitInterface(void)
{
    pNFCQDptr   =   (volatile NFCQ_DPTR*)   DPTR_BASE_ADDRESS;   
ffe05229:	f29a21        	l32r	a2, ffe01c94 <_bss_table_end+0x318>
ffe0522c:	4c29      	s32i.n	a2, a12, 16
    pNFCQArray  =   (volatile NFCQ_ARRAY *) CQ_ENTRY_BASE;
    pPrcqArray  =   (volatile PRCQ_ARRAY *) PRCQ_ENTRY_BASE;
ffe0522e:	7cd9      	s32i.n	a13, a12, 28
    //pRedEntry   =   (volatile RED_ENTRY *)  RED_BASE_ADDRESS; 
    pNfcTrigger =   (volatile NFCQ_TRIGGER_REG *) REG_BASE_NDC_TRIG;
ffe05230:	8cb9      	s32i.n	a11, a12, 32
    pNfcQEEntry =   (volatile QEE_ENTRY_REG*)PRCQ_QEE_BASE;
ffe05232:	9ca9      	s32i.n	a10, a12, 36
*************************************************/

LOCAL void HalNfcInitInterface(void)
{
    pNFCQDptr   =   (volatile NFCQ_DPTR*)   DPTR_BASE_ADDRESS;   
    pNFCQArray  =   (volatile NFCQ_ARRAY *) CQ_ENTRY_BASE;
ffe05234:	6c09      	s32i.n	a0, a12, 24

GLOBAL void HAL_NfcInit(void)
{
      
    HalNfcInitInterface();  
    HalFlashCmdTableInit();
ffe05236:	ff9645        	call0	ffe04b9c <HalFlashCmdTableInit..I_1429880325>
    HalFlashQEEInit();
ffe05239:	ff9185        	call0	ffe04b54 <HalFlashQEEInit..J_1429880325>
    HAL_NormalDsgInit();
ffe0523c:	ff8e85        	call0	ffe04b28 <HAL_NormalDsgInit>
    
    if((FALSE == HAL_StrapNfcIsOnfi())&&(FALSE == HAL_StrapNfcIsAsync()))
ffe0523f:	0020c0        	memw
ffe05242:	ec38      	l32i.n	a3, a12, 56
ffe05244:	35e367        	bbsi	a3, 6, ffe0527d <HAL_HwInit+0xc9>
ffe05247:	0020c0        	memw
ffe0524a:	150c      	movi.n	a5, 1
ffe0524c:	ec68      	l32i.n	a6, a12, 56
ffe0524e:	040c      	movi.n	a4, 0
ffe05250:	046460        	extui	a6, a6, 4, 1
ffe05253:	834560        	moveqz	a4, a5, a6
ffe05256:	34ec      	bnez.n	a4, ffe0527d <HAL_HwInit+0xc9>
    {
        U32 ulPu;
        U32 ulMaxPu = (32 << HAL_StrapNfcIs16CeMode());
ffe05258:	0020c0        	memw
ffe0525b:	ec08      	l32i.n	a0, a12, 56
        for (ulPu=0;ulPu<ulMaxPu;ulPu++)
ffe0525d:	0d2c      	movi.n	a13, 32
    HAL_NormalDsgInit();
    
    if((FALSE == HAL_StrapNfcIsOnfi())&&(FALSE == HAL_StrapNfcIsAsync()))
    {
        U32 ulPu;
        U32 ulMaxPu = (32 << HAL_StrapNfcIs16CeMode());
ffe0525f:	040900        	extui	a0, a0, 9, 1
        for (ulPu=0;ulPu<ulMaxPu;ulPu++)
ffe05262:	401000        	ssl	a0
ffe05265:	a1dd00        	sll	a13, a13
ffe05268:	bd8c      	beqz.n	a13, ffe05277 <HAL_HwInit+0xc3>
ffe0526a:	0c0c      	movi.n	a12, 0
        {
            HAL_NfcResetPu(ulPu);
ffe0526c:	7420c0        	extui	a2, a12, 0, 8
ffe0526f:	ff84c5        	call0	ffe04abc <HAL_NfcResetPu>
    
    if((FALSE == HAL_StrapNfcIsOnfi())&&(FALSE == HAL_StrapNfcIsAsync()))
    {
        U32 ulPu;
        U32 ulMaxPu = (32 << HAL_StrapNfcIs16CeMode());
        for (ulPu=0;ulPu<ulMaxPu;ulPu++)
ffe05272:	cc1b      	addi.n	a12, a12, 1
ffe05274:	f49dc7        	bne	a13, a12, ffe0526c <HAL_HwInit+0xb8>
        {
            HAL_NfcResetPu(ulPu);
        } 
        HAL_DelayCycle(400000);
ffe05277:	f28c21        	l32r	a2, ffe01ca8 <_bss_table_end+0x32c>
ffe0527a:	ffb705        	call0	ffe04dec <HAL_DelayCycle>
    HAL_StrapCheckEfuse();    
    HAL_NfcInit();
}
ffe0527d:	11c8      	l32i.n	a12, a1, 4
ffe0527f:	21d8      	l32i.n	a13, a1, 8
    }
    
    HalNfcTimingInit();
ffe05281:	ff6c05        	call0	ffe04944 <HalNfcTimingInit..G_1429880325>
ffe05284:	0108      	l32i.n	a0, a1, 0
ffe05286:	10c112        	addi	a1, a1, 16
ffe05289:	f00d      	ret.n

ffe0528b <HAL_HwInit+0xd7>:
        {
            return;
        }

        // check the data be valid for HW init
        if (TRUE == l_pEfuseFile->bsIsEfuseSet)    
ffe0528b:	0020c0        	memw
ffe0528e:	2028      	l32i.n	a2, a0, 8
        {   
            l_bSetHwFrEfuse = TRUE;
ffe05290:	f24431        	l32r	a3, ffe01ba0 <_bss_table_end+0x224>
ffe05293:	042220        	extui	a2, a2, 2, 1
ffe05296:	f81216        	beqz	a2, ffe0521b <HAL_HwInit+0x67>
ffe05299:	dc79      	s32i.n	a7, a12, 52
ffe0529b:	f1c741        	l32r	a4, ffe019b8 <_bss_table_end+0x3c>
ffe0529e:	f22471        	l32r	a7, ffe01b30 <_bss_table_end+0x1b4>
    volatile NFC_REG_08 *pNfc08 = (volatile NFC_REG_08 *)&rNFC(0x08);
    volatile NFC_REG_80 *pNfc80 = (volatile NFC_REG_80 *)&rNFC(0x80);
    volatile NFC_REG_88 *pNfc88 = (volatile NFC_REG_88 *)&rNFC(0x88);

    // set NFC 
    pNfc00->IS_MICRON  = l_pEfuseFile->bsIsONFI;
ffe052a1:	0020c0        	memw
ffe052a4:	0768      	l32i.n	a6, a7, 0
ffe052a6:	0020c0        	memw
ffe052a9:	2088      	l32i.n	a8, a0, 8
ffe052ab:	048380        	extui	a8, a8, 3, 1
ffe052ae:	d08864        	insbits	a6, a8, 24, 24
ffe052b1:	0020c0        	memw
ffe052b4:	0769      	s32i.n	a6, a7, 0
    
    if (0 == l_pEfuseFile->bsIsASYNC)
ffe052b6:	0020c0        	memw
ffe052b9:	2058      	l32i.n	a5, a0, 8
    {
        rNFC(0x2C) = 0x3f;
ffe052bb:	fa3c      	movi.n	a10, 63
    volatile NFC_REG_88 *pNfc88 = (volatile NFC_REG_88 *)&rNFC(0x88);

    // set NFC 
    pNfc00->IS_MICRON  = l_pEfuseFile->bsIsONFI;
    
    if (0 == l_pEfuseFile->bsIsASYNC)
ffe052bd:	1ce547        	bbsi	a5, 4, ffe052dd <HAL_HwInit+0x129>
    {
        rNFC(0x2C) = 0x3f;
ffe052c0:	0020c0        	memw
ffe052c3:	8b63a2        	s32i	a10, a3, 0x22c
        if (0 ==  l_pEfuseFile->bsIsONFI)
ffe052c6:	0020c0        	memw
ffe052c9:	2098      	l32i.n	a9, a0, 8
ffe052cb:	0ee937        	bbsi	a9, 3, ffe052dd <HAL_HwInit+0x129>
        {
            rNFC(0x88) &= ~(1<<23);
ffe052ce:	0020c0        	memw
ffe052d1:	a223b2        	l32i	a11, a3, 0x288
ffe052d4:	10bb40        	and	a11, a11, a4
ffe052d7:	0020c0        	memw
ffe052da:	a263b2        	s32i	a11, a3, 0x288
ffe052dd:	f27381        	l32r	a8, ffe01cac <_bss_table_end+0x330>
ffe052e0:	f27461        	l32r	a6, ffe01cb0 <_bss_table_end+0x334>
ffe052e3:	ffa0d2        	movi	a13, 255
ffe052e6:	f27321        	l32r	a2, ffe01cb4 <_bss_table_end+0x338>
ffe052e9:	f273b1        	l32r	a11, ffe01cb8 <_bss_table_end+0x33c>
        }
    }
    
    pNfc00->ECC_SELECT = l_pEfuseFile->bsNFC_ECCMode;
ffe052ec:	0020c0        	memw
ffe052ef:	07a8      	l32i.n	a10, a7, 0
ffe052f1:	0020c0        	memw
ffe052f4:	2058      	l32i.n	a5, a0, 8
ffe052f6:	145550        	extui	a5, a5, 5, 2
ffe052f9:	2255a4        	insbits	a10, a5, 5, 6
ffe052fc:	0020c0        	memw
ffe052ff:	07a9      	s32i.n	a10, a7, 0
    pNfc00->CL_ADDR_BYTE = l_pEfuseFile->bsNFC_CLAddrByte;
ffe05301:	0020c0        	memw
ffe05304:	0758      	l32i.n	a5, a7, 0
ffe05306:	0020c0        	memw
ffe05309:	2098      	l32i.n	a9, a0, 8
ffe0530b:	049790        	extui	a9, a9, 7, 1
ffe0530e:	204954        	insbits	a5, a9, 4, 4
ffe05311:	0020c0        	memw
ffe05314:	0759      	s32i.n	a5, a7, 0
    pNfc00->PG_SIZE = l_pEfuseFile->bsNFC_PageSize;
ffe05316:	0020c0        	memw
ffe05319:	0798      	l32i.n	a9, a7, 0
ffe0531b:	0020c0        	memw
ffe0531e:	20a8      	l32i.n	a10, a0, 8
ffe05320:	14a8a0        	extui	a10, a10, 8, 2
ffe05323:	010a94        	insbits	a9, a10, 0, 1
ffe05326:	0020c0        	memw
ffe05329:	0799      	s32i.n	a9, a7, 0
    pNfc04->TWHRLD = l_pEfuseFile->bsNFC_TWHRLD;
ffe0532b:	0020c0        	memw
ffe0532e:	02a8      	l32i.n	a10, a2, 0
ffe05330:	0020c0        	memw
ffe05333:	2058      	l32i.n	a5, a0, 8
ffe05335:	245a50        	extui	a5, a5, 10, 3
ffe05338:	f2c5a4        	insbits	a10, a5, 28, 30
ffe0533b:	0020c0        	memw
ffe0533e:	02a9      	s32i.n	a10, a2, 0
    pNfc04->TDBS = l_pEfuseFile->bsNFC_TDBS;
ffe05340:	0020c0        	memw
ffe05343:	0258      	l32i.n	a5, a2, 0
ffe05345:	0020c0        	memw
ffe05348:	2098      	l32i.n	a9, a0, 8
ffe0534a:	149d90        	extui	a9, a9, 13, 2
ffe0534d:	d3a954        	insbits	a5, a9, 26, 27
ffe05350:	0020c0        	memw
ffe05353:	0259      	s32i.n	a5, a2, 0
    pNfc04->TCAD_3 = l_pEfuseFile->bsNFC_TCAD_3;
ffe05355:	0020c0        	memw
ffe05358:	0298      	l32i.n	a9, a2, 0
ffe0535a:	0020c0        	memw
ffe0535d:	20a8      	l32i.n	a10, a0, 8
ffe0535f:	04afa0        	extui	a10, a10, 15, 1
ffe05362:	d19a94        	insbits	a9, a10, 25, 25
ffe05365:	0020c0        	memw
ffe05368:	0299      	s32i.n	a9, a2, 0

    pNfc04->TCS = l_pEfuseFile->bsNFC_TCS;
ffe0536a:	0020c0        	memw
ffe0536d:	f25351        	l32r	a5, ffe01cbc <_bss_table_end+0x340>
ffe05370:	0298      	l32i.n	a9, a2, 0
ffe05372:	0020c0        	memw
ffe05375:	20a8      	l32i.n	a10, a0, 8
ffe05377:	10aa50        	and	a10, a10, a5
ffe0537a:	f5a0a0        	extui	a10, a10, 16, 16
ffe0537d:	d08a94        	insbits	a9, a10, 24, 24
ffe05380:	0020c0        	memw
ffe05383:	0299      	s32i.n	a9, a2, 0
    pNfc04->TCLHZ = l_pEfuseFile->bsNFC_TCLHZ;
ffe05385:	0020c0        	memw
ffe05388:	f24e51        	l32r	a5, ffe01cc0 <_bss_table_end+0x344>
ffe0538b:	0298      	l32i.n	a9, a2, 0
ffe0538d:	0020c0        	memw
ffe05390:	20a8      	l32i.n	a10, a0, 8
ffe05392:	10aa50        	and	a10, a10, a5
ffe05395:	e5a1a0        	extui	a10, a10, 17, 15
ffe05398:	b14a94        	insbits	a9, a10, 20, 21
ffe0539b:	0020c0        	memw
ffe0539e:	0299      	s32i.n	a9, a2, 0
    pNfc04->RDRPH = l_pEfuseFile->bsNFC_RDRPH;
ffe053a0:	0020c0        	memw
ffe053a3:	02a8      	l32i.n	a10, a2, 0
ffe053a5:	0020c0        	memw
ffe053a8:	2058      	l32i.n	a5, a0, 8
ffe053aa:	105560        	and	a5, a5, a6
ffe053ad:	c55350        	extui	a5, a5, 19, 13
ffe053b0:	9315a4        	insbits	a10, a5, 17, 19
ffe053b3:	0020c0        	memw
ffe053b6:	02a9      	s32i.n	a10, a2, 0
    pNfc04->TRPST = l_pEfuseFile->bsNFC_TRPST;
ffe053b8:	0020c0        	memw
ffe053bb:	f1fa91        	l32r	a9, ffe01ba4 <_bss_table_end+0x228>
ffe053be:	02a8      	l32i.n	a10, a2, 0
ffe053c0:	0020c0        	memw
ffe053c3:	2058      	l32i.n	a5, a0, 8
ffe053c5:	105590        	and	a5, a5, a9
ffe053c8:	955650        	extui	a5, a5, 22, 10
ffe053cb:	63e5a4        	insbits	a10, a5, 14, 15
ffe053ce:	0020c0        	memw
ffe053d1:	02a9      	s32i.n	a10, a2, 0
    pNfc04->TRPSTH = l_pEfuseFile->bsNFC_TRPSTH;
ffe053d3:	0020c0        	memw
ffe053d6:	f23b91        	l32r	a9, ffe01cc4 <_bss_table_end+0x348>
ffe053d9:	02a8      	l32i.n	a10, a2, 0
ffe053db:	0020c0        	memw
ffe053de:	2058      	l32i.n	a5, a0, 8
ffe053e0:	105590        	and	a5, a5, a9
ffe053e3:	755850        	extui	a5, a5, 24, 8
ffe053e6:	9005a4        	insbits	a10, a5, 16, 16
ffe053e9:	0020c0        	memw
ffe053ec:	02a9      	s32i.n	a10, a2, 0
    pNfc04->TCAD = l_pEfuseFile->bsNFC_TCAD;
ffe053ee:	0020c0        	memw
ffe053f1:	f1c191        	l32r	a9, ffe01af8 <_bss_table_end+0x17c>
ffe053f4:	02a8      	l32i.n	a10, a2, 0
ffe053f6:	0020c0        	memw
ffe053f9:	2058      	l32i.n	a5, a0, 8
ffe053fb:	105590        	and	a5, a5, a9
ffe053fe:	655950        	extui	a5, a5, 25, 7
ffe05401:	4175a4        	insbits	a10, a5, 7, 9
ffe05404:	0020c0        	memw
ffe05407:	02a9      	s32i.n	a10, a2, 0
    pNfc04->TCCS_LDV = l_pEfuseFile->bsNFC_TCCS_LDV;
ffe05409:	0020c0        	memw
ffe0540c:	0258      	l32i.n	a5, a2, 0
ffe0540e:	0020c0        	memw
ffe05411:	2098      	l32i.n	a9, a0, 8
ffe05413:	359c90        	extui	a9, a9, 28, 4
ffe05416:	223954        	insbits	a5, a9, 3, 6
ffe05419:	0020c0        	memw
ffe0541c:	0259      	s32i.n	a5, a2, 0

    pNfc04->TRPRE = l_pEfuseFile->bsNFC_TRPRE;
ffe0541e:	0020c0        	memw
ffe05421:	0298      	l32i.n	a9, a2, 0
ffe05423:	0020c0        	memw
ffe05426:	30a8      	l32i.n	a10, a0, 12
ffe05428:	14a0a0        	extui	a10, a10, 0, 2
ffe0542b:	61ca94        	insbits	a9, a10, 12, 13
ffe0542e:	0020c0        	memw
ffe05431:	0299      	s32i.n	a9, a2, 0
    pNfc04->SLOWRD = l_pEfuseFile->bsNFC_SlowRead;
ffe05433:	0020c0        	memw
ffe05436:	02a8      	l32i.n	a10, a2, 0
ffe05438:	0020c0        	memw
ffe0543b:	3058      	l32i.n	a5, a0, 12
ffe0543d:	045250        	extui	a5, a5, 2, 1
ffe05440:	0005a4        	insbits	a10, a5, 0, 0
ffe05443:	0020c0        	memw
ffe05446:	02a9      	s32i.n	a10, a2, 0
    pNfc08->TRHWLD = l_pEfuseFile->bsNFC_TRHWLD;
ffe05448:	0020c0        	memw
ffe0544b:	0b58      	l32i.n	a5, a11, 0
ffe0544d:	0020c0        	memw
ffe05450:	3098      	l32i.n	a9, a0, 12
ffe05452:	449390        	extui	a9, a9, 3, 5
ffe05455:	f3b954        	insbits	a5, a9, 27, 31
ffe05458:	0020c0        	memw
ffe0545b:	0b59      	s32i.n	a5, a11, 0
    pNfc08->DDR_CFG = l_pEfuseFile->bsNFC_DDR_CFG;
ffe0545d:	0020c0        	memw
ffe05460:	0ba8      	l32i.n	a10, a11, 0
ffe05462:	0020c0        	memw
ffe05465:	3028      	l32i.n	a2, a0, 12
ffe05467:	042820        	extui	a2, a2, 8, 1
ffe0546a:	b372a4        	insbits	a10, a2, 23, 23
ffe0546d:	0020c0        	memw
ffe05470:	0ba9      	s32i.n	a10, a11, 0
    pNfc08->DDR_HF_CFG = l_pEfuseFile->bsNFC_DDR_HF_CFG;
ffe05472:	0020c0        	memw
ffe05475:	0b58      	l32i.n	a5, a11, 0
ffe05477:	0020c0        	memw
ffe0547a:	3098      	l32i.n	a9, a0, 12
ffe0547c:	049990        	extui	a9, a9, 9, 1
ffe0547f:	b26954        	insbits	a5, a9, 22, 22
ffe05482:	0020c0        	memw
ffe05485:	0b59      	s32i.n	a5, a11, 0
    pNfc08->TDQSRE  = l_pEfuseFile->bsNFC_TDQSRE;
ffe05487:	0020c0        	memw
ffe0548a:	0ba8      	l32i.n	a10, a11, 0
ffe0548c:	0020c0        	memw
ffe0548f:	3028      	l32i.n	a2, a0, 12
ffe05491:	242a20        	extui	a2, a2, 10, 3
ffe05494:	0202a4        	insbits	a10, a2, 0, 2
ffe05497:	0020c0        	memw
ffe0549a:	0ba9      	s32i.n	a10, a11, 0
    pNfc88->DQSHZ_TH = l_pEfuseFile->bsNFC_DQSHZ_TH;
ffe0549c:	0020c0        	memw
ffe0549f:	0858      	l32i.n	a5, a8, 0
ffe054a1:	0020c0        	memw
ffe054a4:	3098      	l32i.n	a9, a0, 12
ffe054a6:	249d90        	extui	a9, a9, 13, 3
ffe054a9:	d39954        	insbits	a5, a9, 25, 27
ffe054ac:	0020c0        	memw
ffe054af:	0859      	s32i.n	a5, a8, 0
    
    if (1 == l_pEfuseFile->bsIsONFI)
ffe054b1:	0020c0        	memw
ffe054b4:	2028      	l32i.n	a2, a0, 8
ffe054b6:	2b6237        	bbci	a2, 3, ffe054e5 <HAL_HwInit+0x331>
    {
        if (1 == l_pEfuseFile->bsNFC_DDR_HF_CFG)
ffe054b9:	0020c0        	memw
ffe054bc:	3078      	l32i.n	a7, a0, 12
ffe054be:	116797        	bbci	a7, 9, ffe054d3 <HAL_HwInit+0x31f>
        {
            rNFC(0x88) &= ~(1<<23);
ffe054c1:	0020c0        	memw
ffe054c4:	a22382        	l32i	a8, a3, 0x288
ffe054c7:	108840        	and	a8, a8, a4
ffe054ca:	0020c0        	memw
ffe054cd:	a26382        	s32i	a8, a3, 0x288
ffe054d0:	000446        	j	ffe054e5 <HAL_HwInit+0x331>

ffe054d3 <HAL_HwInit+0x31f>:
        }
        else
        {
            rNFC(0x88) |= (1<<23);
ffe054d3:	f140a1        	l32r	a10, ffe019d4 <_bss_table_end+0x58>
ffe054d6:	0020c0        	memw
ffe054d9:	a22392        	l32i	a9, a3, 0x288
ffe054dc:	2099a0        	or	a9, a9, a10
ffe054df:	0020c0        	memw
ffe054e2:	a26392        	s32i	a9, a3, 0x288
ffe054e5:	f16531        	l32r	a3, ffe01a7c <_bss_table_end+0x100>
ffe054e8:	f1f881        	l32r	a8, ffe01cc8 <_bss_table_end+0x34c>
        }
    }
    
    pNfc80->CH0NFCKGCMPCNT = l_pEfuseFile->bsNFC_CHxNFCKGCMPCNT;
ffe054eb:	0020c0        	memw
ffe054ee:	0858      	l32i.n	a5, a8, 0
ffe054f0:	0020c0        	memw
ffe054f3:	3078      	l32i.n	a7, a0, 12
ffe054f5:	107760        	and	a7, a7, a6
ffe054f8:	f57070        	extui	a7, a7, 16, 16
ffe054fb:	221754        	insbits	a5, a7, 1, 6
ffe054fe:	0020c0        	memw
ffe05501:	0859      	s32i.n	a5, a8, 0
    pNfc80->CH1NFCKGCMPCNT = l_pEfuseFile->bsNFC_CHxNFCKGCMPCNT;
ffe05503:	0020c0        	memw
ffe05506:	0828      	l32i.n	a2, a8, 0
ffe05508:	0020c0        	memw
ffe0550b:	3048      	l32i.n	a4, a0, 12
ffe0550d:	104460        	and	a4, a4, a6
ffe05510:	f54040        	extui	a4, a4, 16, 16
ffe05513:	629424        	insbits	a2, a4, 9, 14
ffe05516:	0020c0        	memw
ffe05519:	0829      	s32i.n	a2, a8, 0
    pNfc80->CH2NFCKGCMPCNT = l_pEfuseFile->bsNFC_CHxNFCKGCMPCNT;
ffe0551b:	0020c0        	memw
ffe0551e:	08a8      	l32i.n	a10, a8, 0
ffe05520:	0020c0        	memw
ffe05523:	30b8      	l32i.n	a11, a0, 12
ffe05525:	10bb60        	and	a11, a11, a6
ffe05528:	f5b0b0        	extui	a11, a11, 16, 16
ffe0552b:	b21ba4        	insbits	a10, a11, 17, 22
ffe0552e:	0020c0        	memw
ffe05531:	08a9      	s32i.n	a10, a8, 0
    pNfc80->CH3NFCKGCMPCNT = l_pEfuseFile->bsNFC_CHxNFCKGCMPCNT;
ffe05533:	0020c0        	memw
ffe05536:	0878      	l32i.n	a7, a8, 0
ffe05538:	0020c0        	memw
ffe0553b:	3098      	l32i.n	a9, a0, 12
ffe0553d:	109960        	and	a9, a9, a6
ffe05540:	f59090        	extui	a9, a9, 16, 16
ffe05543:	f29974        	insbits	a7, a9, 25, 30
ffe05546:	0020c0        	memw
ffe05549:	0879      	s32i.n	a7, a8, 0

    rPMU(0x20) &= ~(0x3<<6);
ffe0554b:	3faf62        	movi	a6, -193
ffe0554e:	0020c0        	memw
ffe05551:	482352        	l32i	a5, a3, 0x120
ffe05554:	105560        	and	a5, a5, a6
ffe05557:	0020c0        	memw
ffe0555a:	486352        	s32i	a5, a3, 0x120
    rPMU(0x20) |= (l_pEfuseFile->bsPMU_NFCLKSEL << 6);        // Set this field to 0x1ff81f20[7:6]  
ffe0555d:	0020c0        	memw
ffe05560:	2048      	l32i.n	a4, a0, 8
ffe05562:	144040        	extui	a4, a4, 0, 2
ffe05565:	1144a0        	slli	a4, a4, 6
ffe05568:	0020c0        	memw
ffe0556b:	482322        	l32i	a2, a3, 0x120
ffe0556e:	202240        	or	a2, a2, a4
ffe05571:	0020c0        	memw

    
    // set EPHY 
    for (i=0;i<EPHY_REG_NUM;i++)
ffe05574:	f1d761        	l32r	a6, ffe01cd0 <_bss_table_end+0x354>
ffe05577:	f1d751        	l32r	a5, ffe01cd4 <_bss_table_end+0x358>
ffe0557a:	7b0c      	movi.n	a11, 7
    pNfc80->CH1NFCKGCMPCNT = l_pEfuseFile->bsNFC_CHxNFCKGCMPCNT;
    pNfc80->CH2NFCKGCMPCNT = l_pEfuseFile->bsNFC_CHxNFCKGCMPCNT;
    pNfc80->CH3NFCKGCMPCNT = l_pEfuseFile->bsNFC_CHxNFCKGCMPCNT;

    rPMU(0x20) &= ~(0x3<<6);
    rPMU(0x20) |= (l_pEfuseFile->bsPMU_NFCLKSEL << 6);        // Set this field to 0x1ff81f20[7:6]  
ffe0557c:	486322        	s32i	a2, a3, 0x120

    
    // set EPHY 
    for (i=0;i<EPHY_REG_NUM;i++)
ffe0557f:	f1d331        	l32r	a3, ffe01ccc <_bss_table_end+0x350>
ffe05582:	64ab76        	loopgtz	a11, ffe055ea <HAL_HwInit+0x436>
    {
        if(TRUE == l_pEfuseFile->usEPHY_REG[i].bsValid)
ffe05585:	0020c0        	memw
ffe05588:	800382        	l8ui	a8, a3, 128
ffe0558b:	418780        	srli	a8, a8, 7
ffe0558e:	561866        	bnei	a8, 1, ffe055e8 <HAL_HwInit+0x434>
        {
            if(0x7 == (l_pEfuseFile->usEPHY_REG[i].bsAddr >> 4))  // Addr[6:4] == 3'b111
ffe05591:	0020c0        	memw
ffe05594:	800392        	l8ui	a9, a3, 128
ffe05597:	649090        	extui	a9, a9, 0, 7
ffe0559a:	219490        	srai	a9, a9, 4
ffe0559d:	197966        	bnei	a9, 7, ffe055ba <HAL_HwInit+0x406>
            {
                SET_EPHY_REG(REG_BASE_EPHY,l_pEfuseFile->usEPHY_REG[i].bsAddr) = l_pEfuseFile->usEPHY_REG[i].bsData;
ffe055a0:	0020c0        	memw
ffe055a3:	8003b2        	l8ui	a11, a3, 128
ffe055a6:	64b0b0        	extui	a11, a11, 0, 7
ffe055a9:	bb6a      	add.n	a11, a11, a6
ffe055ab:	0020c0        	memw
ffe055ae:	8103a2        	l8ui	a10, a3, 129
ffe055b1:	0020c0        	memw
ffe055b4:	804ba2        	s8i	a10, a11, 128
ffe055b7:	000b46        	j	ffe055e8 <HAL_HwInit+0x434>

ffe055ba <HAL_HwInit+0x406>:
            }
            else
            {
                SET_EPHY_REG(REG_BASE_EPHY_LANE0,l_pEfuseFile->usEPHY_REG[i].bsAddr & 0xf ) = l_pEfuseFile->usEPHY_REG[i].bsData;
ffe055ba:	0020c0        	memw
ffe055bd:	800382        	l8ui	a8, a3, 128
ffe055c0:	348080        	extui	a8, a8, 0, 4
ffe055c3:	885a      	add.n	a8, a8, a5
ffe055c5:	0020c0        	memw
ffe055c8:	810372        	l8ui	a7, a3, 129
ffe055cb:	0020c0        	memw
ffe055ce:	204872        	s8i	a7, a8, 32
                SET_EPHY_REG(REG_BASE_EPHY_LANE1,l_pEfuseFile->usEPHY_REG[i].bsAddr & 0xf ) = l_pEfuseFile->usEPHY_REG[i].bsData;
ffe055d1:	0020c0        	memw
ffe055d4:	800342        	l8ui	a4, a3, 128
ffe055d7:	344040        	extui	a4, a4, 0, 4
ffe055da:	445a      	add.n	a4, a4, a5
ffe055dc:	0020c0        	memw
ffe055df:	810322        	l8ui	a2, a3, 129
ffe055e2:	0020c0        	memw
ffe055e5:	c84422        	s8i	a2, a4, 200
    rPMU(0x20) &= ~(0x3<<6);
    rPMU(0x20) |= (l_pEfuseFile->bsPMU_NFCLKSEL << 6);        // Set this field to 0x1ff81f20[7:6]  

    
    // set EPHY 
    for (i=0;i<EPHY_REG_NUM;i++)
ffe055e8:	332b      	addi.n	a3, a3, 2

ffe055ea <HAL_HwInit+0x436>:
            }
        }
    }

    // set glb register if required debug 
    if (0xff != l_pEfuseFile->bsNormal_REG0_ADDR)
ffe055ea:	0020c0        	memw
ffe055ed:	1e0092        	l8ui	a9, a0, 30
ffe055f0:	c099d0        	sub	a9, a9, a13
ffe055f3:	c26916        	beqz	a9, ffe0521d <HAL_HwInit+0x69>
    {
        rGLB(l_pEfuseFile->bsNormal_REG0_ADDR) = l_pEfuseFile->bsNormal_REG0_DATA;
ffe055f6:	0020c0        	memw
ffe055f9:	1e00b2        	l8ui	a11, a0, 30
ffe055fc:	0020c0        	memw
ffe055ff:	f1b6d1        	l32r	a13, ffe01cd8 <_bss_table_end+0x35c>
ffe05602:	0f00a2        	l8ui	a10, a0, 15
ffe05605:	bbda      	add.n	a11, a11, a13
ffe05607:	0020c0        	memw
ffe0560a:	0ba9      	s32i.n	a10, a11, 0
ffe0560c:	ff0346        	j	ffe0521d <HAL_HwInit+0x69>

ffe0560f <HAL_HwInit+0x45b>:
	...

ffe05610 <main>:
        <2> start pcie/sata if required then execute bootloader 
        <3> accumulate pu then try <1>        
        
*************************************************/
int main(void)
{    
ffe05610:	c0c112        	addi	a1, a1, -64
ffe05613:	c1d9      	s32i.n	a13, a1, 48
ffe05615:	e1f9      	s32i.n	a15, a1, 56
ffe05617:	a109      	s32i.n	a0, a1, 40
ffe05619:	b1c9      	s32i.n	a12, a1, 44
ffe0561b:	d1e9      	s32i.n	a14, a1, 52

*******************************************************************************/
void HAL_RomInit(void)
{
	g_ulDbgEnable = 'V';
    rGLB(0x24) = 0x2f; // enable entire OTFB
ffe0561d:	f92c      	movi.n	a9, 47
        <2> start pcie/sata if required then execute bootloader 
        <3> accumulate pu then try <1>        
        
*************************************************/
int main(void)
{    
ffe0561f:	f0d9e1        	l32r	a14, ffe01984 <_bss_table_end+0x8>
ffe05622:	f121c1        	l32r	a12, ffe01aa8 <_bss_table_end+0x12c>

*******************************************************************************/
void HAL_RomInit(void)
{
	g_ulDbgEnable = 'V';
    rGLB(0x24) = 0x2f; // enable entire OTFB
ffe05625:	0020c0        	memw
ffe05628:	896c92        	s32i	a9, a12, 0x224
{
#ifdef JTAG_DEBUG
    U32 ulStrapReg1 = *(U32*)(0xfff20000);
    U32 ulStrapReg2 = *(U32*)(0xfff20000);
#else
    U32 ulStrapReg1 = rGLB(0x40);
ffe0562b:	0020c0        	memw
ffe0562e:	902c62        	l32i	a6, a12, 0x240
    U32 ulStrapReg2 = rGLB(0x00);
ffe05631:	0020c0        	memw
ffe05634:	802c22        	l32i	a2, a12, 0x200
#endif
    l_tStrapPin.bsBootSrc0        = (ulStrapReg1     )  & 0x1;
ffe05637:	0020c0        	memw
ffe0563a:	ee88      	l32i.n	a8, a14, 56
ffe0563c:	000684        	insbits	a8, a6, 0, 0
ffe0563f:	0020c0        	memw
ffe05642:	ee89      	s32i.n	a8, a14, 56
    l_tStrapPin.bsBootSrc1        = (ulStrapReg1 >> 1)  & 0x1;
ffe05644:	0020c0        	memw
ffe05647:	ee58      	l32i.n	a5, a14, 56
ffe05649:	417160        	srli	a7, a6, 1
ffe0564c:	011754        	insbits	a5, a7, 1, 1
ffe0564f:	0020c0        	memw
ffe05652:	ee59      	s32i.n	a5, a14, 56
    l_tStrapPin.bsBootSrc2        = (ulStrapReg1 >> 2)  & 0x1;
ffe05654:	0020c0        	memw
ffe05657:	ee38      	l32i.n	a3, a14, 56
ffe05659:	414260        	srli	a4, a6, 2
ffe0565c:	022434        	insbits	a3, a4, 2, 2
ffe0565f:	0020c0        	memw
ffe05662:	ee39      	s32i.n	a3, a14, 56
    l_tStrapPin.bsSataPcieSel     = (ulStrapReg1 >> 3)  & 0x1;
ffe05664:	0020c0        	memw
ffe05667:	eef8      	l32i.n	a15, a14, 56
ffe05669:	410360        	srli	a0, a6, 3
ffe0566c:	0330f4        	insbits	a15, a0, 3, 3
ffe0566f:	0020c0        	memw
ffe05672:	eef9      	s32i.n	a15, a14, 56
    l_tStrapPin.bsAsyncSyncSel    = (ulStrapReg1 >> 4)  & 0x1;
ffe05674:	0020c0        	memw
ffe05677:	eeb8      	l32i.n	a11, a14, 56
ffe05679:	41d460        	srli	a13, a6, 4
ffe0567c:	204db4        	insbits	a11, a13, 4, 4
ffe0567f:	0020c0        	memw
ffe05682:	eeb9      	s32i.n	a11, a14, 56
    l_tStrapPin.bsTlcMlcSel       = (ulStrapReg1 >> 5)  & 0x1;
ffe05684:	0020c0        	memw
ffe05687:	ee98      	l32i.n	a9, a14, 56
ffe05689:	41a560        	srli	a10, a6, 5
ffe0568c:	215a94        	insbits	a9, a10, 5, 5
ffe0568f:	0020c0        	memw
ffe05692:	ee99      	s32i.n	a9, a14, 56
    l_tStrapPin.bsToggleOnfiSel   = (ulStrapReg1 >> 6)  & 0x1;
ffe05694:	0020c0        	memw
ffe05697:	ee78      	l32i.n	a7, a14, 56
ffe05699:	418660        	srli	a8, a6, 6
ffe0569c:	226874        	insbits	a7, a8, 6, 6
ffe0569f:	0020c0        	memw
ffe056a2:	ee79      	s32i.n	a7, a14, 56
    l_tStrapPin.bsNvmeAhciSel     = (ulStrapReg1 >> 7)  & 0x1;
ffe056a4:	0020c0        	memw
ffe056a7:	ee58      	l32i.n	a5, a14, 56
ffe056a9:	416760        	srli	a6, a6, 7
ffe056ac:	237654        	insbits	a5, a6, 7, 7
ffe056af:	0020c0        	memw
ffe056b2:	ee59      	s32i.n	a5, a14, 56
#ifdef VT3514_C0    
    l_tStrapPin.bsEPRomSel        = (ulStrapReg2 >> 17) & 0x1;
ffe056b4:	0020c0        	memw
ffe056b7:	ee38      	l32i.n	a3, a14, 56
ffe056b9:	e54120        	extui	a4, a2, 17, 15
ffe056bc:	408434        	insbits	a3, a4, 8, 8
ffe056bf:	0020c0        	memw
ffe056c2:	ee39      	s32i.n	a3, a14, 56
    l_tStrapPin.bs16CeMode        = (ulStrapReg2 >> 19) & 0x1;
ffe056c4:	0020c0        	memw
ffe056c7:	ee08      	l32i.n	a0, a14, 56
ffe056c9:	c52320        	extui	a2, a2, 19, 13
ffe056cc:	419204        	insbits	a0, a2, 9, 9
ffe056cf:	0020c0        	memw
}

U32 uart_init(void)
{
    U32 ulBautRate;
    HAL_MemZero((U32*)&l_tTxPack,UART_PACKET_SIZE);
ffe056d2:	60ce22        	addi	a2, a14, 96
ffe056d5:	430c      	movi.n	a3, 4
ffe056d7:	ee09      	s32i.n	a0, a14, 56
ffe056d9:	ff2285        	call0	ffe04904 <HAL_MemZero>
    HAL_MemZero((U32*)&l_tRxPack,UART_PACKET_SIZE);
ffe056dc:	f18021        	l32r	a2, ffe01cdc <_bss_table_end+0x360>
ffe056df:	430c      	movi.n	a3, 4
ffe056e1:	ff2205        	call0	ffe04904 <HAL_MemZero>
    HAL_MemZero((U32*)&l_tMgr,sizeof(UART_MP_MGR)/sizeof(U32));
ffe056e4:	f17f21        	l32r	a2, ffe01ce0 <_bss_table_end+0x364>
ffe056e7:	430c      	movi.n	a3, 4
ffe056e9:	ff2185        	call0	ffe04904 <HAL_MemZero>
ffe056ec:	f0f8f1        	l32r	a15, ffe01acc <_bss_table_end+0x150>
ffe056ef:	0d0c      	movi.n	a13, 0
ffe056f1:	f0f891        	l32r	a9, ffe01ad4 <_bss_table_end+0x158>
    rUART_ENABLE |= 1 << 12; 
}

void HAL_UartSetBautRate(U32 ulMode)
{
    rUART_LCR = 0;
ffe056f4:	0020c0        	memw
ffe056f7:	8369d2        	s32i	a13, a9, 0x20c
    {
        rUART_LCR = 0x1d0000;
    }
    else
    {
        rUART_LCR = 0x1200000;
ffe056fa:	f17a81        	l32r	a8, ffe01ce4 <_bss_table_end+0x368>
ffe056fd:	0020c0        	memw
ffe05700:	836982        	s32i	a8, a9, 0x20c
LOCAL volatile UART_LCR_REG * const l_pUartLcrReg = (volatile UART_LCR_REG *)&rUART_LCR;


void HAL_UartByteMode(BOOL bEnable)
{
    l_pUartLcrReg->READ_BYTE_MODE = bEnable;
ffe05703:	ffab72        	movi	a7, 0xfffffbff
ffe05706:	00a462        	movi	a6, 0x400
ffe05709:	4f28      	l32i.n	a2, a15, 16
ffe0570b:	0020c0        	memw
ffe0570e:	0258      	l32i.n	a5, a2, 0
ffe05710:	105570        	and	a5, a5, a7
ffe05713:	205560        	or	a5, a5, a6
ffe05716:	0020c0        	memw
ffe05719:	0259      	s32i.n	a5, a2, 0
    l_pUartLcrReg->READ_TRIG_MODE = bEnable;
ffe0571b:	ffad42        	movi	a4, 0xfffffdff
ffe0571e:	00a232        	movi	a3, 0x200
ffe05721:	0020c0        	memw
ffe05724:	0208      	l32i.n	a0, a2, 0
ffe05726:	100040        	and	a0, a0, a4
ffe05729:	200030        	or	a0, a0, a3
ffe0572c:	0020c0        	memw
ffe0572f:	0209      	s32i.n	a0, a2, 0
}

void HAL_UartEnable(void)
{
    rUART_ENABLE |= 1 << 12; 
ffe05731:	f113b1        	l32r	a11, ffe01b80 <_bss_table_end+0x204>
ffe05734:	0020c0        	memw
ffe05737:	9a2ca2        	l32i	a10, a12, 0x268
ffe0573a:	20aab0        	or	a10, a10, a11
ffe0573d:	0020c0        	memw
ffe05740:	9a6ca2        	s32i	a10, a12, 0x268
        rGLB(0x1f1c) |= (1<<24);
    }
#endif 

    uart_init();           
    DBG_Printf("VT3514 C0 ROM BOOT PROCESSING ...\n");
ffe05743:	f16921        	l32r	a2, ffe01ce8 <_bss_table_end+0x36c>
ffe05746:	ff7785        	call0	ffe04ec0 <dbg_printf>
    DBG_Printf("UART enabled\n");
ffe05749:	f16821        	l32r	a2, ffe01cec <_bss_table_end+0x370>
ffe0574c:	ff7705        	call0	ffe04ec0 <dbg_printf>
    U32 ulPCEndAddr;
    BOOL bInvert;
    U8 * pTraxFileBuff;
    TRAX_CONTEXT tTraxContext;

    ulDelayCount = 0;
ffe0574f:	01d9      	s32i.n	a13, a1, 0
    ucUnitType = 0;
ffe05751:	0441d2        	s8i	a13, a1, 4
    if (MCU0_ID == ulMcuId)
    {
        HAL_CofigTraceBuffMutiMcu();
ffe05754:	ff1945        	call0	ffe048ec <HAL_CofigTraceBuffMutiMcu>
    }

    HAL_TraxInitERI(&tTraxContext);
ffe05757:	218b      	addi.n	a2, a1, 8
ffe05759:	ff1305        	call0	ffe0488c <HAL_TraxInitERI>
{
    U16 usSizDw;

    usSizDw = usRamSizeByte>>2;

    *pStartAddr = (ulMcuId - MCU0_ID)*usSizDw;
ffe0575c:	1051d2        	s16i	a13, a1, 32

    /* logic designed TraceBuff is 8k or 32k */
    ulTraceRamSize = TRACE_RAM_SIZE_MULTICORE;//8<<10;
    HalCalTracBuffRange(ulMcuId, ulTraceRamSize, &usStartAddr, &usEndAddr);

    HAL_TraxSetRamBoundary(&tTraxContext, usStartAddr, usEndAddr);
ffe0575f:	218b      	addi.n	a2, a1, 8
ffe05761:	030c      	movi.n	a3, 0
    if (MCU0_ID == ulMcuId)
    {
        HAL_CofigTraceBuffMutiMcu();
    }

    HAL_TraxInitERI(&tTraxContext);
ffe05763:	ffa142        	movi	a4, 0x1ff
    U16 usSizDw;

    usSizDw = usRamSizeByte>>2;

    *pStartAddr = (ulMcuId - MCU0_ID)*usSizDw;
    *pEndAddr = (*pStartAddr + usSizDw) - 1;
ffe05766:	115142        	s16i	a4, a1, 34

    /* logic designed TraceBuff is 8k or 32k */
    ulTraceRamSize = TRACE_RAM_SIZE_MULTICORE;//8<<10;
    HalCalTracBuffRange(ulMcuId, ulTraceRamSize, &usStartAddr, &usEndAddr);

    HAL_TraxSetRamBoundary(&tTraxContext, usStartAddr, usEndAddr);
ffe05769:	ff08c5        	call0	ffe047f8 <HAL_TraxSetRamBoundary>
    usStartAddr = 0xff;
    usEndAddr = 0xff;
    HAL_TraxGetRamBoundary(&usStartAddr, &usEndAddr);
ffe0576c:	20c122        	addi	a2, a1, 32
ffe0576f:	22c132        	addi	a3, a1, 34
    /* logic designed TraceBuff is 8k or 32k */
    ulTraceRamSize = TRACE_RAM_SIZE_MULTICORE;//8<<10;
    HalCalTracBuffRange(ulMcuId, ulTraceRamSize, &usStartAddr, &usEndAddr);

    HAL_TraxSetRamBoundary(&tTraxContext, usStartAddr, usEndAddr);
    usStartAddr = 0xff;
ffe05772:	ffa0a2        	movi	a10, 255
ffe05775:	1051a2        	s16i	a10, a1, 32
    usEndAddr = 0xff;
ffe05778:	1151a2        	s16i	a10, a1, 34
    HAL_TraxGetRamBoundary(&usStartAddr, &usEndAddr);
ffe0577b:	ff0605        	call0	ffe047dc <HAL_TraxGetRamBoundary>
    DBG_Printf("Ram Boundary Start 0x%x; End 0x%x\n", usStartAddr, usEndAddr);
ffe0577e:	f15c21        	l32r	a2, ffe01cf0 <_bss_table_end+0x374>
ffe05781:	101132        	l16ui	a3, a1, 32
ffe05784:	111142        	l16ui	a4, a1, 34
ffe05787:	ff7385        	call0	ffe04ec0 <dbg_printf>

    HAL_TraxSetSMPER(ulTraceRamSize);
ffe0578a:	f08421        	l32r	a2, ffe0199c <_bss_table_end+0x20>
ffe0578d:	feff85        	call0	ffe04788 <HAL_TraxSetSMPER>

    HAL_TraxSetPostSize(&tTraxContext, ulDelayCount, ucUnitType);
ffe05790:	218b      	addi.n	a2, a1, 8
ffe05792:	0138      	l32i.n	a3, a1, 0
ffe05794:	040142        	l8ui	a4, a1, 4
ffe05797:	fef405        	call0	ffe046d8 <HAL_TraxSetPostSize>
    ulDelayCount = 0;
ffe0579a:	01d9      	s32i.n	a13, a1, 0
ffe0579c:	012d      	mov.n	a2, a1
    ucUnitType = 0xff;
    HAL_TraxGetPostSize(&ulDelayCount, &ucUnitType);
ffe0579e:	314b      	addi.n	a3, a1, 4

    HAL_TraxSetSMPER(ulTraceRamSize);

    HAL_TraxSetPostSize(&tTraxContext, ulDelayCount, ucUnitType);
    ulDelayCount = 0;
    ucUnitType = 0xff;
ffe057a0:	ffa0b2        	movi	a11, 255
ffe057a3:	0441b2        	s8i	a11, a1, 4
    HAL_TraxGetPostSize(&ulDelayCount, &ucUnitType);
ffe057a6:	feefc5        	call0	ffe046a4 <HAL_TraxGetPostSize>
    DBG_Printf("PostSize DelayCount 0x%x; ucUnitType 0x%x\n", ulDelayCount, ucUnitType);
ffe057a9:	f15221        	l32r	a2, ffe01cf4 <_bss_table_end+0x378>
ffe057ac:	0138      	l32i.n	a3, a1, 0
ffe057ae:	040142        	l8ui	a4, a1, 4
ffe057b1:	ff70c5        	call0	ffe04ec0 <dbg_printf>

    HAL_TraxStart();
ffe057b4:	feea85        	call0	ffe04660 <HAL_TraxStart>
        rGLB(0x3c48) = 0x0c6c0000  ;
        rGLB(0x3c4c) = 0x092       ;
        rGLB(0x3c54) = 0xa050ffff  ;
    }
#else
    if(FALSE == HAL_StrapIsPcie())
ffe057b7:	0020c0        	memw
ffe057ba:	ee08      	l32i.n	a0, a14, 56
ffe057bc:	040300        	extui	a0, a0, 3, 1
ffe057bf:	08f056        	bnez	a0, ffe05852 <main+0x242>
    {
        rGLB(0x3c60) = 0x30000     ;
ffe057c2:	f14e81        	l32r	a8, ffe01cfc <_bss_table_end+0x380>
ffe057c5:	f14c51        	l32r	a5, ffe01cf8 <_bss_table_end+0x37c>
ffe057c8:	f0ac31        	l32r	a3, ffe01a78 <_bss_table_end+0xfc>
ffe057cb:	0020c0        	memw
ffe057ce:	986352        	s32i	a5, a3, 0x260
        rGLB(0x3c64) = 0xe60023    ;
ffe057d1:	f14b41        	l32r	a4, ffe01d00 <_bss_table_end+0x384>
ffe057d4:	0020c0        	memw
ffe057d7:	996342        	s32i	a4, a3, 0x264
        rGLB(0x3c68) = 0x157003f   ;
ffe057da:	f14a21        	l32r	a2, ffe01d04 <_bss_table_end+0x388>
ffe057dd:	0020c0        	memw
ffe057e0:	9a6322        	s32i	a2, a3, 0x268
        rGLB(0x3c10) = 0x44000055  ;
ffe057e3:	f14901        	l32r	a0, ffe01d08 <_bss_table_end+0x38c>
ffe057e6:	0020c0        	memw
ffe057e9:	846302        	s32i	a0, a3, 0x210

        rGLB(0x3c14) = 0x0f80e808  ;
ffe057ec:	f148b1        	l32r	a11, ffe01d0c <_bss_table_end+0x390>
ffe057ef:	0020c0        	memw
ffe057f2:	8563b2        	s32i	a11, a3, 0x214

        rGLB(0x3c20) = 0x0c6c0000  ;
ffe057f5:	0020c0        	memw
ffe057f8:	886382        	s32i	a8, a3, 0x220
        rGLB(0x3c24) = 0x0         ;
ffe057fb:	0020c0        	memw
ffe057fe:	8963d2        	s32i	a13, a3, 0x224
        rGLB(0x3c2c) = 0xf550c5fa  ;
ffe05801:	f143a1        	l32r	a10, ffe01d10 <_bss_table_end+0x394>
ffe05804:	0020c0        	memw
ffe05807:	8b63a2        	s32i	a10, a3, 0x22c

        rGLB(0x3c34) = 0x0c6c0000  ;
ffe0580a:	0020c0        	memw
ffe0580d:	8d6382        	s32i	a8, a3, 0x234
        rGLB(0x3c38) = 0x0         ;
ffe05810:	0020c0        	memw
ffe05813:	8e63d2        	s32i	a13, a3, 0x238
        rGLB(0x3c40) = 0xa550faaa  ;
ffe05816:	f13f91        	l32r	a9, ffe01d14 <_bss_table_end+0x398>
ffe05819:	0020c0        	memw
ffe0581c:	906392        	s32i	a9, a3, 0x240

        rGLB(0x3c48) = 0x0c6c0000  ;
ffe0581f:	0020c0        	memw
ffe05822:	926382        	s32i	a8, a3, 0x248
        rGLB(0x3c4c) = 0x092       ;
ffe05825:	92a072        	movi	a7, 146
ffe05828:	0020c0        	memw
ffe0582b:	936372        	s32i	a7, a3, 0x24c
        rGLB(0x3c54) = 0xa050ffff  ;
ffe0582e:	f13a61        	l32r	a6, ffe01d18 <_bss_table_end+0x39c>
ffe05831:	0020c0        	memw
ffe05834:	956362        	s32i	a6, a3, 0x254

        rGLB(0x3c28) = 0x44335544  ;
ffe05837:	f13951        	l32r	a5, ffe01d1c <_bss_table_end+0x3a0>
ffe0583a:	0020c0        	memw
ffe0583d:	8a6352        	s32i	a5, a3, 0x228
        rGLB(0x3c3c) = 0x44334444  ;
ffe05840:	f13841        	l32r	a4, ffe01d20 <_bss_table_end+0x3a4>
ffe05843:	0020c0        	memw
ffe05846:	8f6342        	s32i	a4, a3, 0x23c
        rGLB(0x3c50) = 0x44333344  ;
ffe05849:	f13621        	l32r	a2, ffe01d24 <_bss_table_end+0x3a8>
ffe0584c:	0020c0        	memw
ffe0584f:	946322        	s32i	a2, a3, 0x250

ffe05852 <main+0x242>:
    
#ifdef VT3514_C0
    HAL_Trax3CoreConfig(MCU0_ID);
#endif
    HAL_SetEPHY();
    l_ucCeMax = (TRUE == HAL_StrapNfcIs16CeMode())?CE_MAX*2:CE_MAX;
ffe05852:	f08a21        	l32r	a2, ffe01a7c <_bss_table_end+0x100>
ffe05855:	032c      	movi.n	a3, 32
ffe05857:	0020c0        	memw
ffe0585a:	ee58      	l32i.n	a5, a14, 56
ffe0585c:	044c      	movi.n	a4, 64
ffe0585e:	045950        	extui	a5, a5, 9, 1
ffe05861:	550b      	addi.n	a5, a5, -1
ffe05863:	833450        	moveqz	a3, a4, a5
ffe05866:	004e32        	s8i	a3, a14, 0

*************************************************/

void HAL_WarmBoot(void)
{
    l_pBootEntry = (PFUNC)HAL_StrapGetWarmBootEntry();
ffe05869:	0020c0        	memw
ffe0586c:	492222        	l32i	a2, a2, 0x124
ffe0586f:	1e29      	s32i.n	a2, a14, 4
ffe05871:	729c      	beqz.n	a2, ffe0588c <main+0x27c>

    if (NULL != l_pBootEntry)
    {   
        DBG_TRACE(TRACE_WARM_BOOT);
ffe05873:	f12d71        	l32r	a7, ffe01d28 <_bss_table_end+0x3ac>
ffe05876:	0020c0        	memw
ffe05879:	a06c72        	s32i	a7, a12, 0x280
void HAL_ActivateDRAM(void)
{
    U32 ulAddr = DRAM_START_ADDRESS;
    U32 i;
//#if 1  //ndef COSIM    
    for (i=0;i<4;i++)
ffe0587c:	f12c01        	l32r	a0, ffe01d2c <_bss_table_end+0x3b0>
ffe0587f:	460c      	movi.n	a6, 4
ffe05881:	04a676        	loopgtz	a6, ffe05889 <main+0x279>
    {
        *(U32*)(ulAddr + i*4) = 0;
ffe05884:	8060d2        	s32i	a13, a0, 0x200
void HAL_ActivateDRAM(void)
{
    U32 ulAddr = DRAM_START_ADDRESS;
    U32 i;
//#if 1  //ndef COSIM    
    for (i=0;i<4;i++)
ffe05887:	004b      	addi.n	a0, a0, 4

ffe05889 <main+0x279>:
    return;
}

void HAL_Jump(void)
{
    l_pBootEntry();
ffe05889:	0002c0        	callx0	a2

ffe0588c <main+0x27c>:

*************************************************/

void HAL_SpiBoot(void)
{
    if (TRUE == HAL_StrapSpiBoot())
ffe0588c:	0020c0        	memw
ffe0588f:	ee88      	l32i.n	a8, a14, 56
ffe05891:	048880        	extui	a8, a8, 8, 1
ffe05894:	16c816        	beqz	a8, ffe05a04 <main+0x3f4>

LOCAL volatile SPI_FLASH_FILE_HEAD l_tSpiRomHead;

void HAL_SpiBootProcess(void)
{
    DBG_TRACE(TRACE_SPI_BOOT);
ffe05897:	f127a1        	l32r	a10, ffe01d34 <_bss_table_end+0x3b8>
    {
        HAL_SpiBootProcess();
ffe0589a:	f12531        	l32r	a3, ffe01d30 <_bss_table_end+0x3b4>
ffe0589d:	f04fb1        	l32r	a11, ffe019dc <_bss_table_end+0x60>
ffe058a0:	0020c0        	memw
    GLB_IO_ENABLE *pGLB68 = (GLB_IO_ENABLE *)(0x1ff80000 + 0x68);
    pGLB68->RSPI_NEW = 1;
    pGLB68->RNEWSPI_MODE = 2;
    pGLB68->RSPI_EN = 1;
    pGLB68->RSPI_DIS = 0;
    pGLB68->RSPI_CKG_EN = 0;
ffe058a3:	bfaf22        	movi	a2, -65
{
    GLB_IO_ENABLE *pGLB68 = (GLB_IO_ENABLE *)(0x1ff80000 + 0x68);
    pGLB68->RSPI_NEW = 1;
    pGLB68->RNEWSPI_MODE = 2;
    pGLB68->RSPI_EN = 1;
    pGLB68->RSPI_DIS = 0;
ffe058a6:	ffae42        	movi	a4, 0xfffffeff
void HAL_SpiInit(void)
{
    GLB_IO_ENABLE *pGLB68 = (GLB_IO_ENABLE *)(0x1ff80000 + 0x68);
    pGLB68->RSPI_NEW = 1;
    pGLB68->RNEWSPI_MODE = 2;
    pGLB68->RSPI_EN = 1;
ffe058a9:	f03c61        	l32r	a6, ffe0199c <_bss_table_end+0x20>

void HAL_SpiInit(void)
{
    GLB_IO_ENABLE *pGLB68 = (GLB_IO_ENABLE *)(0x1ff80000 + 0x68);
    pGLB68->RSPI_NEW = 1;
    pGLB68->RNEWSPI_MODE = 2;
ffe058ac:	f04571        	l32r	a7, ffe019c0 <_bss_table_end+0x44>
*******************************************************************************/

void HAL_SpiInit(void)
{
    GLB_IO_ENABLE *pGLB68 = (GLB_IO_ENABLE *)(0x1ff80000 + 0x68);
    pGLB68->RSPI_NEW = 1;
ffe058af:	f0a591        	l32r	a9, ffe01b44 <_bss_table_end+0x1c8>
ffe058b2:	a06ca2        	s32i	a10, a12, 0x280
ffe058b5:	0358      	l32i.n	a5, a3, 0
    pGLB68->RNEWSPI_MODE = 2;
ffe058b7:	f12081        	l32r	a8, ffe01d38 <_bss_table_end+0x3bc>
*******************************************************************************/

void HAL_SpiInit(void)
{
    GLB_IO_ENABLE *pGLB68 = (GLB_IO_ENABLE *)(0x1ff80000 + 0x68);
    pGLB68->RSPI_NEW = 1;
ffe058ba:	205590        	or	a5, a5, a9
ffe058bd:	0359      	s32i.n	a5, a3, 0
    pGLB68->RNEWSPI_MODE = 2;
ffe058bf:	105580        	and	a5, a5, a8
ffe058c2:	205570        	or	a5, a5, a7
ffe058c5:	0359      	s32i.n	a5, a3, 0
    pGLB68->RSPI_EN = 1;
ffe058c7:	205560        	or	a5, a5, a6
ffe058ca:	0359      	s32i.n	a5, a3, 0
    pGLB68->RSPI_DIS = 0;
ffe058cc:	104540        	and	a4, a5, a4
    pGLB68->RSPI_CKG_EN = 0;
ffe058cf:	102420        	and	a2, a4, a2
{
    GLB_IO_ENABLE *pGLB68 = (GLB_IO_ENABLE *)(0x1ff80000 + 0x68);
    pGLB68->RSPI_NEW = 1;
    pGLB68->RNEWSPI_MODE = 2;
    pGLB68->RSPI_EN = 1;
    pGLB68->RSPI_DIS = 0;
ffe058d2:	0349      	s32i.n	a4, a3, 0
    pGLB68->RSPI_CKG_EN = 0;
ffe058d4:	0329      	s32i.n	a2, a3, 0
History:
20140912    Kristin    Coding style uniform
------------------------------------------------------------------------------*/
void DMAE_TEXT_ATTR HAL_DMAEInit(void)
{
    rDMAE_REQ_PRIORITY &=  (~MASK_DMAE_REQ_PRIORITY);
ffe058d6:	c07c      	movi.n	a0, -4
ffe058d8:	0020c0        	memw
ffe058db:	c02bd2        	l32i	a13, a11, 0x300
ffe058de:	10dd00        	and	a13, a13, a0
ffe058e1:	0020c0        	memw
ffe058e4:	c06bd2        	s32i	a13, a11, 0x300
    rDMAE_REQ_PRIORITY |= DMAE_REQ_PRIORITY_LOW;
ffe058e7:	0020c0        	memw
ffe058ea:	c02ba2        	l32i	a10, a11, 0x300
ffe058ed:	0020c0        	memw
ffe058f0:	c06ba2        	s32i	a10, a11, 0x300

    HAL_DMAEInit();
    HAL_SpiHWInit();
ffe058f3:	ff58c5        	call0	ffe04e80 <HAL_SpiHWInit..OB_1429880325>
    HAL_SpiSoftReset();
ffe058f6:	66a022        	movi	a2, 102
ffe058f9:	ff4fc5        	call0	ffe04df8 <HAL_SpiSendCCmd..GB_1429880325>
ffe058fc:	99a022        	movi	a2, 153
ffe058ff:	ff4f85        	call0	ffe04df8 <HAL_SpiSendCCmd..GB_1429880325>

LOCAL void HAL_SpiWaitRstFsh(void)
{
    //Delay_us(30);
#ifndef FPGA
    HAL_DelayCycle(8000);   // 266M
ffe05902:	f10e21        	l32r	a2, ffe01d3c <_bss_table_end+0x3c0>
ffe05905:	ff4e45        	call0	ffe04dec <HAL_DelayCycle>
void HAL_SpiSoftReset(void)
{
    HAL_SpiSendCCmd(SPI_CMD_RSTEN,0,0);
    HAL_SpiSendCCmd(SPI_CMD_RST,0,0);  
    HAL_SpiWaitRstFsh();
    HAL_SpiHWInit();
ffe05908:	ff5745        	call0	ffe04e80 <HAL_SpiHWInit..OB_1429880325>

*******************************************************************************/

GLOBAL void HAL_SpiSetWCmd(U32 ulIndex)
{
    l_aSetSpiMode[l_aWCmdTable[ulIndex].bsSpiMode]();
ffe0590b:	902fd2        	l32i	a13, a15, 0x240
ffe0590e:	0408d0        	extui	a0, a13, 8, 1
ffe05911:	a000f0        	addx4	a0, a0, a15
ffe05914:	822002        	l32i	a0, a0, 0x208
ffe05917:	0000c0        	callx0	a0
    l_aSetAddrMode[l_aWCmdTable[ulIndex].bsAddrMode]();
ffe0591a:	040bd0        	extui	a0, a13, 11, 1
ffe0591d:	a000f0        	addx4	a0, a0, a15
ffe05920:	8c2002        	l32i	a0, a0, 0x230
ffe05923:	0000c0        	callx0	a0
    l_pSpiRegSet->bsWCmdCode = l_aWCmdTable[ulIndex].bsCmdCode;
ffe05926:	3f38      	l32i.n	a3, a15, 12
ffe05928:	9139      	s32i.n	a3, a1, 36
ffe0592a:	f10541        	l32r	a4, ffe01d40 <_bss_table_end+0x3c4>
ffe0592d:	800452        	l8ui	a5, a4, 128
ffe05930:	0020c0        	memw
ffe05933:	014352        	s8i	a5, a3, 1
    l_pSpiRegSet->bsWIOMode  = l_aWCmdTable[ulIndex].bsCmdIO;
ffe05936:	202442        	l32i	a4, a4, 128
ffe05939:	0020c0        	memw
ffe0593c:	0358      	l32i.n	a5, a3, 0
ffe0593e:	416c40        	srli	a6, a4, 12
ffe05941:	236654        	insbits	a5, a6, 6, 7
ffe05944:	0020c0        	memw
ffe05947:	0359      	s32i.n	a5, a3, 0
    l_pSpiRegSet->bsWSpiGen  = l_aWCmdTable[ulIndex].bsDataIO;
ffe05949:	0020c0        	memw
ffe0594c:	0328      	l32i.n	a2, a3, 0
ffe0594e:	414940        	srli	a4, a4, 9
ffe05951:	214424        	insbits	a2, a4, 4, 5
ffe05954:	0020c0        	memw

*******************************************************************************/

GLOBAL void HAL_SpiSetRCmd(U32 ulIndex)
{
    l_aSetSpiMode[l_aRCmdTable[ulIndex].bsSpiMode]();
ffe05957:	842fd2        	l32i	a13, a15, 0x210
ffe0595a:	0408d0        	extui	a0, a13, 8, 1
ffe0595d:	a000f0        	addx4	a0, a0, a15
ffe05960:	822002        	l32i	a0, a0, 0x208
{
    l_aSetSpiMode[l_aWCmdTable[ulIndex].bsSpiMode]();
    l_aSetAddrMode[l_aWCmdTable[ulIndex].bsAddrMode]();
    l_pSpiRegSet->bsWCmdCode = l_aWCmdTable[ulIndex].bsCmdCode;
    l_pSpiRegSet->bsWIOMode  = l_aWCmdTable[ulIndex].bsCmdIO;
    l_pSpiRegSet->bsWSpiGen  = l_aWCmdTable[ulIndex].bsDataIO;
ffe05963:	0329      	s32i.n	a2, a3, 0

*******************************************************************************/

GLOBAL void HAL_SpiSetRCmd(U32 ulIndex)
{
    l_aSetSpiMode[l_aRCmdTable[ulIndex].bsSpiMode]();
ffe05965:	0000c0        	callx0	a0
    l_aSetAddrMode[l_aRCmdTable[ulIndex].bsAddrMode]();
ffe05968:	040bd0        	extui	a0, a13, 11, 1
ffe0596b:	a000f0        	addx4	a0, a0, a15
ffe0596e:	8c2002        	l32i	a0, a0, 0x230
ffe05971:	0000c0        	callx0	a0
    l_pSpiRegSet->bsRCmdCode = l_aRCmdTable[ulIndex].bsCmdCode;
ffe05974:	f0f421        	l32r	a2, ffe01d44 <_bss_table_end+0x3c8>
ffe05977:	800242        	l8ui	a4, a2, 128
ffe0597a:	0020c0        	memw
ffe0597d:	9138      	l32i.n	a3, a1, 36
ffe0597f:	054342        	s8i	a4, a3, 5
    l_pSpiRegSet->bsRIOMode  = l_aRCmdTable[ulIndex].bsCmdIO;
ffe05982:	202222        	l32i	a2, a2, 128
ffe05985:	0020c0        	memw
ffe05988:	1368      	l32i.n	a6, a3, 4
ffe0598a:	417c20        	srli	a7, a2, 12
ffe0598d:	f2d764        	insbits	a6, a7, 29, 30
ffe05990:	0020c0        	memw
ffe05993:	1369      	s32i.n	a6, a3, 4
    l_pSpiRegSet->bsRSpiGen  = l_aRCmdTable[ulIndex].bsDataIO;
ffe05995:	0020c0        	memw
ffe05998:	1348      	l32i.n	a4, a3, 4
ffe0599a:	415920        	srli	a5, a2, 9
ffe0599d:	f0b544        	insbits	a4, a5, 27, 28
ffe059a0:	0020c0        	memw
ffe059a3:	1349      	s32i.n	a4, a3, 4
    l_pSpiRegSet->bsDummy    = l_aRCmdTable[ulIndex].bsDummy;
ffe059a5:	412e20        	srli	a2, a2, 14
ffe059a8:	0020c0        	memw
ffe059ab:	044322        	s8i	a2, a3, 4
    HAL_SpiInit();

    HAL_SpiDmaRead((U32)OTFB_START_ADDRESS,(U32)SPI_FLASH_FILE_HEAD_ADDR,sizeof(SPI_FLASH_FILE_HEAD));
ffe059ae:	042c      	movi.n	a4, 32
ffe059b0:	f07621        	l32r	a2, ffe01b88 <_bss_table_end+0x20c>
ffe059b3:	f0e531        	l32r	a3, ffe01d48 <_bss_table_end+0x3cc>
ffe059b6:	ff6b05        	call0	ffe05068 <HAL_SpiDmaRead>
    HAL_MemCpy((U32*)&l_tSpiRomHead,(U32*)OTFB_START_ADDRESS,sizeof(SPI_FLASH_FILE_HEAD)/sizeof(U32));
ffe059b9:	f0e421        	l32r	a2, ffe01d4c <_bss_table_end+0x3d0>
ffe059bc:	f07331        	l32r	a3, ffe01b88 <_bss_table_end+0x20c>
ffe059bf:	840c      	movi.n	a4, 8
ffe059c1:	ff6945        	call0	ffe05058 <HAL_MemCpy>

    if(l_tSpiRomHead.ulSignature != 0x3514)
ffe059c4:	f0e361        	l32r	a6, ffe01d50 <_bss_table_end+0x3d4>
ffe059c7:	0020c0        	memw
ffe059ca:	fe58      	l32i.n	a5, a14, 60
ffe059cc:	349567        	bne	a5, a6, ffe05a04 <main+0x3f4>
    {
        return ;
    }

    HAL_SpiDmaRead(l_tSpiRomHead.ulTargetAddr,SPI_START_ADDRESS + l_tSpiRomHead.ulSegOffset,l_tSpiRomHead.ulSegLength);
ffe059cf:	0020c0        	memw
ffe059d2:	f0dd41        	l32r	a4, ffe01d48 <_bss_table_end+0x3cc>
ffe059d5:	122e22        	l32i	a2, a14, 72
ffe059d8:	0020c0        	memw
ffe059db:	102e32        	l32i	a3, a14, 64
ffe059de:	334a      	add.n	a3, a3, a4
ffe059e0:	0020c0        	memw
ffe059e3:	112e42        	l32i	a4, a14, 68
ffe059e6:	ff6805        	call0	ffe05068 <HAL_SpiDmaRead>
    DBG_Printf("GET bootloader succ.\n");
ffe059e9:	f0da21        	l32r	a2, ffe01d54 <_bss_table_end+0x3d8>
ffe059ec:	ff4d05        	call0	ffe04ec0 <dbg_printf>
    DBG_Printf("EXE ENTRY is 0x%x.\n",l_tSpiRomHead.ulExecEntry);
ffe059ef:	f0da21        	l32r	a2, ffe01d58 <_bss_table_end+0x3dc>
ffe059f2:	0020c0        	memw
ffe059f5:	132e32        	l32i	a3, a14, 76
ffe059f8:	ff4c45        	call0	ffe04ec0 <dbg_printf>
    ((PFUNC)l_tSpiRomHead.ulExecEntry)();
ffe059fb:	0020c0        	memw
ffe059fe:	132e02        	l32i	a0, a14, 76
ffe05a01:	0000c0        	callx0	a0
            <1> select mp entry 
*************************************************/

void HAL_SelMpEntry(void)
{
    if (TRUE == HAL_StrapIsPcie())
ffe05a04:	0020c0        	memw
ffe05a07:	ee28      	l32i.n	a2, a14, 56
ffe05a09:	042320        	extui	a2, a2, 3, 1
ffe05a0c:	0f5216        	beqz	a2, ffe05b05 <main+0x4f5>
    {
        l_pBootEntry = HAL_MpPcieMain;
ffe05a0f:	f0d321        	l32r	a2, ffe01d5c <_bss_table_end+0x3e0>
ffe05a12:	1e29      	s32i.n	a2, a14, 4
BOOL HAL_StrapMpBoot(void)
{
#ifndef VT3514_C0   // B0
    return (BOOL)l_tStrapPin.bsTlcMlcSel;    
#else
    if ((1 == l_tStrapPin.bsBootSrc1) && (1 == l_tStrapPin.bsBootSrc0))
ffe05a14:	0020c0        	memw
ffe05a17:	ee38      	l32i.n	a3, a14, 56
ffe05a19:	0c6317        	bbci	a3, 1, ffe05a29 <main+0x419>
ffe05a1c:	0020c0        	memw
ffe05a1f:	ee48      	l32i.n	a4, a14, 56
ffe05a21:	046407        	bbci	a4, 0, ffe05a29 <main+0x419>
ffe05a24:	100c      	movi.n	a0, 1
ffe05a26:	000046        	j	ffe05a2b <main+0x41b>

ffe05a29 <main+0x419>:
ffe05a29:	000c      	movi.n	a0, 0

ffe05a2b <main+0x41b>:
         jump to mp entry if force to mp 
*************************************************/

void HAL_ForceMpBoot(void)
{
    if (TRUE == HAL_StrapMpBoot())
ffe05a2b:	021066        	bnei	a0, 1, ffe05a31 <main+0x421>
    return;
}

void HAL_Jump(void)
{
    l_pBootEntry();
ffe05a2e:	0002c0        	callx0	a2

*/
void HAL_StrapCheckEfuse(void)
{
    l_bIsEfuseMode = FALSE;
    l_bSetHwFrEfuse = FALSE;
ffe05a31:	060c      	movi.n	a6, 0
    l_bIsEfuseMode = TRUE;
    l_bSetHwFrEfuse = TRUE;
    HAL_StrapEfuseSetHW();
#else 
    // check if the efuse be programed 
    if (TRUE == l_pEfuseRegSet->bsProgramed)
ffe05a33:	2f08      	l32i.n	a0, a15, 8
ffe05a35:	0020c0        	memw
ffe05a38:	102052        	l32i	a5, a0, 64
ffe05a3b:	436507        	bbci	a5, 0, ffe05a82 <main+0x472>
ffe05a3e:	d47c      	movi.n	a4, -3
ffe05a40:	220c      	movi.n	a2, 2
        l_bIsEfuseMode = TRUE;    

        // try to read the efuse
        do
        {
            l_pEfuseRegSet->bsDataValid = TRUE;
ffe05a42:	0020c0        	memw
ffe05a45:	102082        	l32i	a8, a0, 64
ffe05a48:	108840        	and	a8, a8, a4
ffe05a4b:	208820        	or	a8, a8, a2
ffe05a4e:	0020c0        	memw
ffe05a51:	106082        	s32i	a8, a0, 64
        }while (FALSE == l_pEfuseRegSet->bsDataValid);
ffe05a54:	0020c0        	memw
ffe05a57:	102072        	l32i	a7, a0, 64
ffe05a5a:	e46717        	bbci	a7, 1, ffe05a42 <main+0x432>
        
        l_pEfuseFile = (volatile EFUSE_FILE *)(REG_BASE_EFUSE);
ffe05a5d:	f08b01        	l32r	a0, ffe01c8c <_bss_table_end+0x310>
ffe05a60:	ce09      	s32i.n	a0, a14, 48

BOOL HAL_StrapEfuseCheckSum(void)
{
    U8 *pBuf = (U8*)l_pEfuseFile;
    U8 ucCheckSum,i;
    ucCheckSum = l_pEfuseFile->bsCheckSum;
ffe05a62:	0020c0        	memw
ffe05a65:	1f0022        	l8ui	a2, a0, 31
    for (i = 0;i<(EFUSE_WDATA_DEPTH*sizeof(U32)-1);i++)
ffe05a68:	040c      	movi.n	a4, 0
ffe05a6a:	f08951        	l32r	a5, ffe01c90 <_bss_table_end+0x314>
ffe05a6d:	f91c      	movi.n	a9, 31
ffe05a6f:	0ca976        	loopgtz	a9, ffe05a7f <main+0x46f>
ffe05a72:	b41b      	addi.n	a11, a4, 1
    {
        ucCheckSum ^= pBuf[i];
ffe05a74:	a45a      	add.n	a10, a4, a5
ffe05a76:	800aa2        	l8ui	a10, a10, 128
BOOL HAL_StrapEfuseCheckSum(void)
{
    U8 *pBuf = (U8*)l_pEfuseFile;
    U8 ucCheckSum,i;
    ucCheckSum = l_pEfuseFile->bsCheckSum;
    for (i = 0;i<(EFUSE_WDATA_DEPTH*sizeof(U32)-1);i++)
ffe05a79:	7440b0        	extui	a4, a11, 0, 8
    {
        ucCheckSum ^= pBuf[i];
ffe05a7c:	302a20        	xor	a2, a10, a2

ffe05a7f <main+0x46f>:
            l_pEfuseRegSet->bsDataValid = TRUE;
        }while (FALSE == l_pEfuseRegSet->bsDataValid);
        
        l_pEfuseFile = (volatile EFUSE_FILE *)(REG_BASE_EFUSE);

        if(FAIL == HAL_StrapEfuseCheckSum())
ffe05a7f:	088216        	beqz	a2, ffe05b0b <main+0x4fb>

ffe05a82 <main+0x472>:
ffe05a82:	de69      	s32i.n	a6, a14, 52
ffe05a84:	000046        	j	ffe05a89 <main+0x479>

ffe05a87 <main+0x477>:

        // check the data be valid for HW init
        if (TRUE == l_pEfuseFile->bsIsEfuseSet)    
        {   
            l_bSetHwFrEfuse = TRUE;
            HAL_StrapEfuseSetHW();   // init HW 
ffe05a87:	de69      	s32i.n	a6, a14, 52
    Initialize pointers.
*************************************************/

LOCAL void HalNfcInitInterface(void)
{
    pNFCQDptr   =   (volatile NFCQ_DPTR*)   DPTR_BASE_ADDRESS;   
ffe05a89:	f08201        	l32r	a0, ffe01c94 <_bss_table_end+0x318>
    pNFCQArray  =   (volatile NFCQ_ARRAY *) CQ_ENTRY_BASE;
    pPrcqArray  =   (volatile PRCQ_ARRAY *) PRCQ_ENTRY_BASE;
    //pRedEntry   =   (volatile RED_ENTRY *)  RED_BASE_ADDRESS; 
    pNfcTrigger =   (volatile NFCQ_TRIGGER_REG *) REG_BASE_NDC_TRIG;
    pNfcQEEntry =   (volatile QEE_ENTRY_REG*)PRCQ_QEE_BASE;
ffe05a8c:	f086b1        	l32r	a11, ffe01ca4 <_bss_table_end+0x328>
{
    pNFCQDptr   =   (volatile NFCQ_DPTR*)   DPTR_BASE_ADDRESS;   
    pNFCQArray  =   (volatile NFCQ_ARRAY *) CQ_ENTRY_BASE;
    pPrcqArray  =   (volatile PRCQ_ARRAY *) PRCQ_ENTRY_BASE;
    //pRedEntry   =   (volatile RED_ENTRY *)  RED_BASE_ADDRESS; 
    pNfcTrigger =   (volatile NFCQ_TRIGGER_REG *) REG_BASE_NDC_TRIG;
ffe05a8f:	f084c1        	l32r	a12, ffe01ca0 <_bss_table_end+0x324>

LOCAL void HalNfcInitInterface(void)
{
    pNFCQDptr   =   (volatile NFCQ_DPTR*)   DPTR_BASE_ADDRESS;   
    pNFCQArray  =   (volatile NFCQ_ARRAY *) CQ_ENTRY_BASE;
    pPrcqArray  =   (volatile PRCQ_ARRAY *) PRCQ_ENTRY_BASE;
ffe05a92:	f082d1        	l32r	a13, ffe01c9c <_bss_table_end+0x320>
*************************************************/

LOCAL void HalNfcInitInterface(void)
{
    pNFCQDptr   =   (volatile NFCQ_DPTR*)   DPTR_BASE_ADDRESS;   
    pNFCQArray  =   (volatile NFCQ_ARRAY *) CQ_ENTRY_BASE;
ffe05a95:	f080f1        	l32r	a15, ffe01c98 <_bss_table_end+0x31c>
ffe05a98:	6ef9      	s32i.n	a15, a14, 24
    pPrcqArray  =   (volatile PRCQ_ARRAY *) PRCQ_ENTRY_BASE;
ffe05a9a:	7ed9      	s32i.n	a13, a14, 28
    //pRedEntry   =   (volatile RED_ENTRY *)  RED_BASE_ADDRESS; 
    pNfcTrigger =   (volatile NFCQ_TRIGGER_REG *) REG_BASE_NDC_TRIG;
ffe05a9c:	8ec9      	s32i.n	a12, a14, 32
    pNfcQEEntry =   (volatile QEE_ENTRY_REG*)PRCQ_QEE_BASE;
ffe05a9e:	9eb9      	s32i.n	a11, a14, 36
    Initialize pointers.
*************************************************/

LOCAL void HalNfcInitInterface(void)
{
    pNFCQDptr   =   (volatile NFCQ_DPTR*)   DPTR_BASE_ADDRESS;   
ffe05aa0:	4e09      	s32i.n	a0, a14, 16

GLOBAL void HAL_NfcInit(void)
{
      
    HalNfcInitInterface();  
    HalFlashCmdTableInit();
ffe05aa2:	ff0f85        	call0	ffe04b9c <HalFlashCmdTableInit..I_1429880325>
    HalFlashQEEInit();
ffe05aa5:	ff0ac5        	call0	ffe04b54 <HalFlashQEEInit..J_1429880325>
    HAL_NormalDsgInit();
ffe05aa8:	ff07c5        	call0	ffe04b28 <HAL_NormalDsgInit>
    
    if((FALSE == HAL_StrapNfcIsOnfi())&&(FALSE == HAL_StrapNfcIsAsync()))
ffe05aab:	0020c0        	memw
ffe05aae:	ee28      	l32i.n	a2, a14, 56
ffe05ab0:	35e267        	bbsi	a2, 6, ffe05ae9 <main+0x4d9>
ffe05ab3:	0020c0        	memw
ffe05ab6:	140c      	movi.n	a4, 1
ffe05ab8:	ee58      	l32i.n	a5, a14, 56
ffe05aba:	030c      	movi.n	a3, 0
ffe05abc:	045450        	extui	a5, a5, 4, 1
ffe05abf:	833450        	moveqz	a3, a4, a5
ffe05ac2:	33ec      	bnez.n	a3, ffe05ae9 <main+0x4d9>
    {
        U32 ulPu;
        U32 ulMaxPu = (32 << HAL_StrapNfcIs16CeMode());
ffe05ac4:	0020c0        	memw
ffe05ac7:	eef8      	l32i.n	a15, a14, 56
        for (ulPu=0;ulPu<ulMaxPu;ulPu++)
ffe05ac9:	0d2c      	movi.n	a13, 32
    HAL_NormalDsgInit();
    
    if((FALSE == HAL_StrapNfcIsOnfi())&&(FALSE == HAL_StrapNfcIsAsync()))
    {
        U32 ulPu;
        U32 ulMaxPu = (32 << HAL_StrapNfcIs16CeMode());
ffe05acb:	04f9f0        	extui	a15, a15, 9, 1
        for (ulPu=0;ulPu<ulMaxPu;ulPu++)
ffe05ace:	401f00        	ssl	a15
ffe05ad1:	a1dd00        	sll	a13, a13
ffe05ad4:	bd8c      	beqz.n	a13, ffe05ae3 <main+0x4d3>
ffe05ad6:	0c0c      	movi.n	a12, 0
        {
            HAL_NfcResetPu(ulPu);
ffe05ad8:	7420c0        	extui	a2, a12, 0, 8
ffe05adb:	fefe05        	call0	ffe04abc <HAL_NfcResetPu>
    
    if((FALSE == HAL_StrapNfcIsOnfi())&&(FALSE == HAL_StrapNfcIsAsync()))
    {
        U32 ulPu;
        U32 ulMaxPu = (32 << HAL_StrapNfcIs16CeMode());
        for (ulPu=0;ulPu<ulMaxPu;ulPu++)
ffe05ade:	cc1b      	addi.n	a12, a12, 1
ffe05ae0:	f49dc7        	bne	a13, a12, ffe05ad8 <main+0x4c8>
        {
            HAL_NfcResetPu(ulPu);
        } 
        HAL_DelayCycle(400000);
ffe05ae3:	f07121        	l32r	a2, ffe01ca8 <_bss_table_end+0x32c>
ffe05ae6:	ff3045        	call0	ffe04dec <HAL_DelayCycle>
    }
    
    HalNfcTimingInit();
ffe05ae9:	fee585        	call0	ffe04944 <HalNfcTimingInit..G_1429880325>

    HAL_ForceMpBoot();

    HAL_HwInit();
    
    HAL_FlashBoot();
ffe05aec:	ff5bc5        	call0	ffe050ac <HAL_FlashBoot>
    return;
}

void HAL_Jump(void)
{
    l_pBootEntry();
ffe05aef:	1e08      	l32i.n	a0, a14, 4
ffe05af1:	0000c0        	callx0	a0
    HAL_HwInit();
    
    HAL_FlashBoot();

    HAL_Jump();
    return 0;
ffe05af4:	020c      	movi.n	a2, 0
ffe05af6:	b1c8      	l32i.n	a12, a1, 44
ffe05af8:	c1d8      	l32i.n	a13, a1, 48
ffe05afa:	d1e8      	l32i.n	a14, a1, 52
ffe05afc:	e1f8      	l32i.n	a15, a1, 56
ffe05afe:	a108      	l32i.n	a0, a1, 40
ffe05b00:	40c112        	addi	a1, a1, 64
ffe05b03:	f00d      	ret.n

ffe05b05 <main+0x4f5>:
    {
        l_pBootEntry = HAL_MpPcieMain;
    }
    else    
    {
        l_pBootEntry = HAL_MpSataMain;
ffe05b05:	f09621        	l32r	a2, ffe01d60 <_bss_table_end+0x3e4>
ffe05b08:	ffc186        	j	ffe05a12 <main+0x402>

ffe05b0b <main+0x4fb>:
        {
            return;
        }

        // check the data be valid for HW init
        if (TRUE == l_pEfuseFile->bsIsEfuseSet)    
ffe05b0b:	0020c0        	memw
ffe05b0e:	2028      	l32i.n	a2, a0, 8
ffe05b10:	042220        	extui	a2, a2, 2, 1
ffe05b13:	f70216        	beqz	a2, ffe05a87 <main+0x477>
        {   
            l_bSetHwFrEfuse = TRUE;
ffe05b16:	180c      	movi.n	a8, 1
ffe05b18:	de89      	s32i.n	a8, a14, 52
ffe05b1a:	f02121        	l32r	a2, ffe01ba0 <_bss_table_end+0x224>
ffe05b1d:	efa641        	l32r	a4, ffe019b8 <_bss_table_end+0x3c>
ffe05b20:	f00451        	l32r	a5, ffe01b30 <_bss_table_end+0x1b4>
    volatile NFC_REG_08 *pNfc08 = (volatile NFC_REG_08 *)&rNFC(0x08);
    volatile NFC_REG_80 *pNfc80 = (volatile NFC_REG_80 *)&rNFC(0x80);
    volatile NFC_REG_88 *pNfc88 = (volatile NFC_REG_88 *)&rNFC(0x88);

    // set NFC 
    pNfc00->IS_MICRON  = l_pEfuseFile->bsIsONFI;
ffe05b23:	0020c0        	memw
ffe05b26:	0568      	l32i.n	a6, a5, 0
ffe05b28:	0020c0        	memw
ffe05b2b:	2078      	l32i.n	a7, a0, 8
ffe05b2d:	047370        	extui	a7, a7, 3, 1
ffe05b30:	d08764        	insbits	a6, a7, 24, 24
ffe05b33:	0020c0        	memw
ffe05b36:	0569      	s32i.n	a6, a5, 0
    
    if (0 == l_pEfuseFile->bsIsASYNC)
ffe05b38:	0020c0        	memw
ffe05b3b:	2038      	l32i.n	a3, a0, 8
ffe05b3d:	1ee347        	bbsi	a3, 4, ffe05b5f <main+0x54f>
    {
        rNFC(0x2C) = 0x3f;
ffe05b40:	fa3c      	movi.n	a10, 63
ffe05b42:	0020c0        	memw
ffe05b45:	8b62a2        	s32i	a10, a2, 0x22c
        if (0 ==  l_pEfuseFile->bsIsONFI)
ffe05b48:	0020c0        	memw
ffe05b4b:	2098      	l32i.n	a9, a0, 8
ffe05b4d:	0ee937        	bbsi	a9, 3, ffe05b5f <main+0x54f>
        {
            rNFC(0x88) &= ~(1<<23);
ffe05b50:	0020c0        	memw
ffe05b53:	a222b2        	l32i	a11, a2, 0x288
ffe05b56:	10bb40        	and	a11, a11, a4
ffe05b59:	0020c0        	memw
ffe05b5c:	a262b2        	s32i	a11, a2, 0x288
ffe05b5f:	f05681        	l32r	a8, ffe01cb8 <_bss_table_end+0x33c>
ffe05b62:	f054d1        	l32r	a13, ffe01cb4 <_bss_table_end+0x338>
ffe05b65:	f052a1        	l32r	a10, ffe01cb0 <_bss_table_end+0x334>
ffe05b68:	f05131        	l32r	a3, ffe01cac <_bss_table_end+0x330>
        }
    }
    
    pNfc00->ECC_SELECT = l_pEfuseFile->bsNFC_ECCMode;
ffe05b6b:	0020c0        	memw
ffe05b6e:	0578      	l32i.n	a7, a5, 0
ffe05b70:	0020c0        	memw
ffe05b73:	2098      	l32i.n	a9, a0, 8
ffe05b75:	149590        	extui	a9, a9, 5, 2
ffe05b78:	225974        	insbits	a7, a9, 5, 6
ffe05b7b:	0020c0        	memw
ffe05b7e:	0579      	s32i.n	a7, a5, 0
    pNfc00->CL_ADDR_BYTE = l_pEfuseFile->bsNFC_CLAddrByte;
ffe05b80:	0020c0        	memw
ffe05b83:	05f8      	l32i.n	a15, a5, 0
ffe05b85:	0020c0        	memw
ffe05b88:	2068      	l32i.n	a6, a0, 8
ffe05b8a:	046760        	extui	a6, a6, 7, 1
ffe05b8d:	2046f4        	insbits	a15, a6, 4, 4
ffe05b90:	0020c0        	memw
ffe05b93:	05f9      	s32i.n	a15, a5, 0
    pNfc00->PG_SIZE = l_pEfuseFile->bsNFC_PageSize;
ffe05b95:	0020c0        	memw
ffe05b98:	0598      	l32i.n	a9, a5, 0
ffe05b9a:	0020c0        	memw
ffe05b9d:	20b8      	l32i.n	a11, a0, 8
ffe05b9f:	14b8b0        	extui	a11, a11, 8, 2
ffe05ba2:	010b94        	insbits	a9, a11, 0, 1
ffe05ba5:	0020c0        	memw
ffe05ba8:	0599      	s32i.n	a9, a5, 0
    pNfc04->TWHRLD = l_pEfuseFile->bsNFC_TWHRLD;
ffe05baa:	0020c0        	memw
ffe05bad:	0d68      	l32i.n	a6, a13, 0
ffe05baf:	0020c0        	memw
ffe05bb2:	2078      	l32i.n	a7, a0, 8
ffe05bb4:	247a70        	extui	a7, a7, 10, 3
ffe05bb7:	f2c764        	insbits	a6, a7, 28, 30
ffe05bba:	0020c0        	memw
ffe05bbd:	0d69      	s32i.n	a6, a13, 0
    pNfc04->TDBS = l_pEfuseFile->bsNFC_TDBS;
ffe05bbf:	0020c0        	memw
ffe05bc2:	0db8      	l32i.n	a11, a13, 0
ffe05bc4:	0020c0        	memw
ffe05bc7:	20f8      	l32i.n	a15, a0, 8
ffe05bc9:	14fdf0        	extui	a15, a15, 13, 2
ffe05bcc:	d3afb4        	insbits	a11, a15, 26, 27
ffe05bcf:	0020c0        	memw
ffe05bd2:	0db9      	s32i.n	a11, a13, 0
    pNfc04->TCAD_3 = l_pEfuseFile->bsNFC_TCAD_3;
ffe05bd4:	0020c0        	memw
ffe05bd7:	0d78      	l32i.n	a7, a13, 0
ffe05bd9:	0020c0        	memw
ffe05bdc:	2098      	l32i.n	a9, a0, 8
ffe05bde:	049f90        	extui	a9, a9, 15, 1
ffe05be1:	d19974        	insbits	a7, a9, 25, 25
ffe05be4:	0020c0        	memw
ffe05be7:	0d79      	s32i.n	a7, a13, 0

    pNfc04->TCS = l_pEfuseFile->bsNFC_TCS;
ffe05be9:	0020c0        	memw
ffe05bec:	f03461        	l32r	a6, ffe01cbc <_bss_table_end+0x340>
ffe05bef:	0db8      	l32i.n	a11, a13, 0
ffe05bf1:	0020c0        	memw
ffe05bf4:	20f8      	l32i.n	a15, a0, 8
ffe05bf6:	10ff60        	and	a15, a15, a6
ffe05bf9:	f5f0f0        	extui	a15, a15, 16, 16
ffe05bfc:	d08fb4        	insbits	a11, a15, 24, 24
ffe05bff:	0020c0        	memw
ffe05c02:	0db9      	s32i.n	a11, a13, 0
    pNfc04->TCLHZ = l_pEfuseFile->bsNFC_TCLHZ;
ffe05c04:	0020c0        	memw
ffe05c07:	f02e91        	l32r	a9, ffe01cc0 <_bss_table_end+0x344>
ffe05c0a:	0d68      	l32i.n	a6, a13, 0
ffe05c0c:	0020c0        	memw
ffe05c0f:	2078      	l32i.n	a7, a0, 8
ffe05c11:	107790        	and	a7, a7, a9
ffe05c14:	e57170        	extui	a7, a7, 17, 15
ffe05c17:	b14764        	insbits	a6, a7, 20, 21
ffe05c1a:	0020c0        	memw
ffe05c1d:	0d69      	s32i.n	a6, a13, 0
    pNfc04->RDRPH = l_pEfuseFile->bsNFC_RDRPH;
ffe05c1f:	0020c0        	memw
ffe05c22:	0db8      	l32i.n	a11, a13, 0
ffe05c24:	0020c0        	memw
ffe05c27:	20f8      	l32i.n	a15, a0, 8
ffe05c29:	10ffa0        	and	a15, a15, a10
ffe05c2c:	c5f3f0        	extui	a15, a15, 19, 13
ffe05c2f:	931fb4        	insbits	a11, a15, 17, 19
ffe05c32:	0020c0        	memw
ffe05c35:	0db9      	s32i.n	a11, a13, 0
    pNfc04->TRPST = l_pEfuseFile->bsNFC_TRPST;
ffe05c37:	0020c0        	memw
ffe05c3a:	efda91        	l32r	a9, ffe01ba4 <_bss_table_end+0x228>
ffe05c3d:	0d68      	l32i.n	a6, a13, 0
ffe05c3f:	0020c0        	memw
ffe05c42:	2078      	l32i.n	a7, a0, 8
ffe05c44:	107790        	and	a7, a7, a9
ffe05c47:	957670        	extui	a7, a7, 22, 10
ffe05c4a:	63e764        	insbits	a6, a7, 14, 15
ffe05c4d:	0020c0        	memw
ffe05c50:	0d69      	s32i.n	a6, a13, 0
    pNfc04->TRPSTH = l_pEfuseFile->bsNFC_TRPSTH;
ffe05c52:	0020c0        	memw
ffe05c55:	f01bf1        	l32r	a15, ffe01cc4 <_bss_table_end+0x348>
ffe05c58:	0d98      	l32i.n	a9, a13, 0
ffe05c5a:	0020c0        	memw
ffe05c5d:	20b8      	l32i.n	a11, a0, 8
ffe05c5f:	10bbf0        	and	a11, a11, a15
ffe05c62:	75b8b0        	extui	a11, a11, 24, 8
ffe05c65:	900b94        	insbits	a9, a11, 16, 16
ffe05c68:	0020c0        	memw
ffe05c6b:	0d99      	s32i.n	a9, a13, 0
    pNfc04->TCAD = l_pEfuseFile->bsNFC_TCAD;
ffe05c6d:	0020c0        	memw
ffe05c70:	efa271        	l32r	a7, ffe01af8 <_bss_table_end+0x17c>
ffe05c73:	0df8      	l32i.n	a15, a13, 0
ffe05c75:	0020c0        	memw
ffe05c78:	2068      	l32i.n	a6, a0, 8
ffe05c7a:	106670        	and	a6, a6, a7
ffe05c7d:	656960        	extui	a6, a6, 25, 7
ffe05c80:	4176f4        	insbits	a15, a6, 7, 9
ffe05c83:	0020c0        	memw
ffe05c86:	0df9      	s32i.n	a15, a13, 0
    pNfc04->TCCS_LDV = l_pEfuseFile->bsNFC_TCCS_LDV;
ffe05c88:	0020c0        	memw
ffe05c8b:	0d98      	l32i.n	a9, a13, 0
ffe05c8d:	0020c0        	memw
ffe05c90:	20b8      	l32i.n	a11, a0, 8
ffe05c92:	35bcb0        	extui	a11, a11, 28, 4
ffe05c95:	223b94        	insbits	a9, a11, 3, 6
ffe05c98:	0020c0        	memw
ffe05c9b:	0d99      	s32i.n	a9, a13, 0

    pNfc04->TRPRE = l_pEfuseFile->bsNFC_TRPRE;
ffe05c9d:	0020c0        	memw
ffe05ca0:	0d68      	l32i.n	a6, a13, 0
ffe05ca2:	0020c0        	memw
ffe05ca5:	3078      	l32i.n	a7, a0, 12
ffe05ca7:	147070        	extui	a7, a7, 0, 2
ffe05caa:	61c764        	insbits	a6, a7, 12, 13
ffe05cad:	0020c0        	memw
ffe05cb0:	0d69      	s32i.n	a6, a13, 0
    pNfc04->SLOWRD = l_pEfuseFile->bsNFC_SlowRead;
ffe05cb2:	0020c0        	memw
ffe05cb5:	0db8      	l32i.n	a11, a13, 0
ffe05cb7:	0020c0        	memw
ffe05cba:	30f8      	l32i.n	a15, a0, 12
ffe05cbc:	04f2f0        	extui	a15, a15, 2, 1
ffe05cbf:	000fb4        	insbits	a11, a15, 0, 0
ffe05cc2:	0020c0        	memw
ffe05cc5:	0db9      	s32i.n	a11, a13, 0
    pNfc08->TRHWLD = l_pEfuseFile->bsNFC_TRHWLD;
ffe05cc7:	0020c0        	memw
ffe05cca:	0878      	l32i.n	a7, a8, 0
ffe05ccc:	0020c0        	memw
ffe05ccf:	3098      	l32i.n	a9, a0, 12
ffe05cd1:	449390        	extui	a9, a9, 3, 5
ffe05cd4:	f3b974        	insbits	a7, a9, 27, 31
ffe05cd7:	0020c0        	memw
ffe05cda:	0879      	s32i.n	a7, a8, 0
    pNfc08->DDR_CFG = l_pEfuseFile->bsNFC_DDR_CFG;
ffe05cdc:	0020c0        	memw
ffe05cdf:	08f8      	l32i.n	a15, a8, 0
ffe05ce1:	0020c0        	memw
ffe05ce4:	3068      	l32i.n	a6, a0, 12
ffe05ce6:	046860        	extui	a6, a6, 8, 1
ffe05ce9:	b376f4        	insbits	a15, a6, 23, 23
ffe05cec:	0020c0        	memw
ffe05cef:	08f9      	s32i.n	a15, a8, 0
    pNfc08->DDR_HF_CFG = l_pEfuseFile->bsNFC_DDR_HF_CFG;
ffe05cf1:	0020c0        	memw
ffe05cf4:	08b8      	l32i.n	a11, a8, 0
ffe05cf6:	0020c0        	memw
ffe05cf9:	30d8      	l32i.n	a13, a0, 12
ffe05cfb:	04d9d0        	extui	a13, a13, 9, 1
ffe05cfe:	b26db4        	insbits	a11, a13, 22, 22
ffe05d01:	0020c0        	memw
ffe05d04:	08b9      	s32i.n	a11, a8, 0
    pNfc08->TDQSRE  = l_pEfuseFile->bsNFC_TDQSRE;
ffe05d06:	0020c0        	memw
ffe05d09:	0878      	l32i.n	a7, a8, 0
ffe05d0b:	0020c0        	memw
ffe05d0e:	3098      	l32i.n	a9, a0, 12
ffe05d10:	249a90        	extui	a9, a9, 10, 3
ffe05d13:	020974        	insbits	a7, a9, 0, 2
ffe05d16:	0020c0        	memw
ffe05d19:	0879      	s32i.n	a7, a8, 0
    pNfc88->DQSHZ_TH = l_pEfuseFile->bsNFC_DQSHZ_TH;
ffe05d1b:	0020c0        	memw
ffe05d1e:	03f8      	l32i.n	a15, a3, 0
ffe05d20:	0020c0        	memw
ffe05d23:	3068      	l32i.n	a6, a0, 12
ffe05d25:	246d60        	extui	a6, a6, 13, 3
ffe05d28:	d396f4        	insbits	a15, a6, 25, 27
ffe05d2b:	0020c0        	memw
ffe05d2e:	03f9      	s32i.n	a15, a3, 0
    
    if (1 == l_pEfuseFile->bsIsONFI)
ffe05d30:	0020c0        	memw
ffe05d33:	20d8      	l32i.n	a13, a0, 8
ffe05d35:	2b6d37        	bbci	a13, 3, ffe05d64 <main+0x754>
    {
        if (1 == l_pEfuseFile->bsNFC_DDR_HF_CFG)
ffe05d38:	0020c0        	memw
ffe05d3b:	30b8      	l32i.n	a11, a0, 12
ffe05d3d:	116b97        	bbci	a11, 9, ffe05d52 <main+0x742>
        {
            rNFC(0x88) &= ~(1<<23);
ffe05d40:	0020c0        	memw
ffe05d43:	a222d2        	l32i	a13, a2, 0x288
ffe05d46:	10dd40        	and	a13, a13, a4
ffe05d49:	0020c0        	memw
ffe05d4c:	a262d2        	s32i	a13, a2, 0x288
ffe05d4f:	000446        	j	ffe05d64 <main+0x754>

ffe05d52 <main+0x742>:
        }
        else
        {
            rNFC(0x88) |= (1<<23);
ffe05d52:	ef2031        	l32r	a3, ffe019d4 <_bss_table_end+0x58>
ffe05d55:	0020c0        	memw
ffe05d58:	a222f2        	l32i	a15, a2, 0x288
ffe05d5b:	20ff30        	or	a15, a15, a3
ffe05d5e:	0020c0        	memw
ffe05d61:	a262f2        	s32i	a15, a2, 0x288
ffe05d64:	efd9f1        	l32r	a15, ffe01cc8 <_bss_table_end+0x34c>
        }
    }
    
    pNfc80->CH0NFCKGCMPCNT = l_pEfuseFile->bsNFC_CHxNFCKGCMPCNT;
ffe05d67:	0020c0        	memw
ffe05d6a:	0f78      	l32i.n	a7, a15, 0
ffe05d6c:	0020c0        	memw
ffe05d6f:	3088      	l32i.n	a8, a0, 12
ffe05d71:	1088a0        	and	a8, a8, a10
ffe05d74:	f58080        	extui	a8, a8, 16, 16
ffe05d77:	221874        	insbits	a7, a8, 1, 6
ffe05d7a:	0020c0        	memw
ffe05d7d:	0f79      	s32i.n	a7, a15, 0
    pNfc80->CH1NFCKGCMPCNT = l_pEfuseFile->bsNFC_CHxNFCKGCMPCNT;
ffe05d7f:	0020c0        	memw
ffe05d82:	0f58      	l32i.n	a5, a15, 0
ffe05d84:	0020c0        	memw
ffe05d87:	3068      	l32i.n	a6, a0, 12
ffe05d89:	1066a0        	and	a6, a6, a10
ffe05d8c:	f56060        	extui	a6, a6, 16, 16
ffe05d8f:	629654        	insbits	a5, a6, 9, 14
ffe05d92:	0020c0        	memw
ffe05d95:	0f59      	s32i.n	a5, a15, 0
    pNfc80->CH2NFCKGCMPCNT = l_pEfuseFile->bsNFC_CHxNFCKGCMPCNT;
ffe05d97:	0020c0        	memw
ffe05d9a:	0f38      	l32i.n	a3, a15, 0
ffe05d9c:	0020c0        	memw
ffe05d9f:	3048      	l32i.n	a4, a0, 12
ffe05da1:	1044a0        	and	a4, a4, a10
ffe05da4:	f54040        	extui	a4, a4, 16, 16
ffe05da7:	b21434        	insbits	a3, a4, 17, 22
ffe05daa:	0020c0        	memw
ffe05dad:	0f39      	s32i.n	a3, a15, 0
    pNfc80->CH3NFCKGCMPCNT = l_pEfuseFile->bsNFC_CHxNFCKGCMPCNT;
ffe05daf:	0020c0        	memw
ffe05db2:	0fd8      	l32i.n	a13, a15, 0
ffe05db4:	0020c0        	memw
ffe05db7:	3028      	l32i.n	a2, a0, 12
ffe05db9:	1022a0        	and	a2, a2, a10
ffe05dbc:	f52020        	extui	a2, a2, 16, 16
ffe05dbf:	f292d4        	insbits	a13, a2, 25, 30
ffe05dc2:	0020c0        	memw
ffe05dc5:	0fd9      	s32i.n	a13, a15, 0

    rPMU(0x20) &= ~(0x3<<6);
ffe05dc7:	3fafb2        	movi	a11, -193
ffe05dca:	0020c0        	memw
ffe05dcd:	ef2b71        	l32r	a7, ffe01a7c <_bss_table_end+0x100>
ffe05dd0:	482792        	l32i	a9, a7, 0x120
ffe05dd3:	1099b0        	and	a9, a9, a11
ffe05dd6:	0020c0        	memw
ffe05dd9:	486792        	s32i	a9, a7, 0x120
    rPMU(0x20) |= (l_pEfuseFile->bsPMU_NFCLKSEL << 6);        // Set this field to 0x1ff81f20[7:6]  
ffe05ddc:	0020c0        	memw
ffe05ddf:	2088      	l32i.n	a8, a0, 8
ffe05de1:	148080        	extui	a8, a8, 0, 2
ffe05de4:	1188a0        	slli	a8, a8, 6
ffe05de7:	0020c0        	memw
ffe05dea:	482762        	l32i	a6, a7, 0x120
ffe05ded:	206680        	or	a6, a6, a8
ffe05df0:	0020c0        	memw

    
    // set EPHY 
    for (i=0;i<EPHY_REG_NUM;i++)
ffe05df3:	efb621        	l32r	a2, ffe01ccc <_bss_table_end+0x350>
ffe05df6:	efb741        	l32r	a4, ffe01cd4 <_bss_table_end+0x358>
    pNfc80->CH1NFCKGCMPCNT = l_pEfuseFile->bsNFC_CHxNFCKGCMPCNT;
    pNfc80->CH2NFCKGCMPCNT = l_pEfuseFile->bsNFC_CHxNFCKGCMPCNT;
    pNfc80->CH3NFCKGCMPCNT = l_pEfuseFile->bsNFC_CHxNFCKGCMPCNT;

    rPMU(0x20) &= ~(0x3<<6);
    rPMU(0x20) |= (l_pEfuseFile->bsPMU_NFCLKSEL << 6);        // Set this field to 0x1ff81f20[7:6]  
ffe05df9:	486762        	s32i	a6, a7, 0x120
ffe05dfc:	750c      	movi.n	a5, 7

    
    // set EPHY 
    for (i=0;i<EPHY_REG_NUM;i++)
ffe05dfe:	efb461        	l32r	a6, ffe01cd0 <_bss_table_end+0x354>
ffe05e01:	64a576        	loopgtz	a5, ffe05e69 <main+0x859>
    {
        if(TRUE == l_pEfuseFile->usEPHY_REG[i].bsValid)
ffe05e04:	0020c0        	memw
ffe05e07:	800292        	l8ui	a9, a2, 128
ffe05e0a:	419790        	srli	a9, a9, 7
ffe05e0d:	561966        	bnei	a9, 1, ffe05e67 <main+0x857>
        {
            if(0x7 == (l_pEfuseFile->usEPHY_REG[i].bsAddr >> 4))  // Addr[6:4] == 3'b111
ffe05e10:	0020c0        	memw
ffe05e13:	8002a2        	l8ui	a10, a2, 128
ffe05e16:	64a0a0        	extui	a10, a10, 0, 7
ffe05e19:	21a4a0        	srai	a10, a10, 4
ffe05e1c:	197a66        	bnei	a10, 7, ffe05e39 <main+0x829>
            {
                SET_EPHY_REG(REG_BASE_EPHY,l_pEfuseFile->usEPHY_REG[i].bsAddr) = l_pEfuseFile->usEPHY_REG[i].bsData;
ffe05e1f:	0020c0        	memw
ffe05e22:	8002d2        	l8ui	a13, a2, 128
ffe05e25:	64d0d0        	extui	a13, a13, 0, 7
ffe05e28:	dd6a      	add.n	a13, a13, a6
ffe05e2a:	0020c0        	memw
ffe05e2d:	8102b2        	l8ui	a11, a2, 129
ffe05e30:	0020c0        	memw
ffe05e33:	804db2        	s8i	a11, a13, 128
ffe05e36:	000b46        	j	ffe05e67 <main+0x857>

ffe05e39 <main+0x829>:
            }
            else
            {
                SET_EPHY_REG(REG_BASE_EPHY_LANE0,l_pEfuseFile->usEPHY_REG[i].bsAddr & 0xf ) = l_pEfuseFile->usEPHY_REG[i].bsData;
ffe05e39:	0020c0        	memw
ffe05e3c:	800272        	l8ui	a7, a2, 128
ffe05e3f:	347070        	extui	a7, a7, 0, 4
ffe05e42:	774a      	add.n	a7, a7, a4
ffe05e44:	0020c0        	memw
ffe05e47:	810252        	l8ui	a5, a2, 129
ffe05e4a:	0020c0        	memw
ffe05e4d:	204752        	s8i	a5, a7, 32
                SET_EPHY_REG(REG_BASE_EPHY_LANE1,l_pEfuseFile->usEPHY_REG[i].bsAddr & 0xf ) = l_pEfuseFile->usEPHY_REG[i].bsData;
ffe05e50:	0020c0        	memw
ffe05e53:	800232        	l8ui	a3, a2, 128
ffe05e56:	343030        	extui	a3, a3, 0, 4
ffe05e59:	334a      	add.n	a3, a3, a4
ffe05e5b:	0020c0        	memw
ffe05e5e:	8102f2        	l8ui	a15, a2, 129
ffe05e61:	0020c0        	memw
ffe05e64:	c843f2        	s8i	a15, a3, 200
    rPMU(0x20) &= ~(0x3<<6);
    rPMU(0x20) |= (l_pEfuseFile->bsPMU_NFCLKSEL << 6);        // Set this field to 0x1ff81f20[7:6]  

    
    // set EPHY 
    for (i=0;i<EPHY_REG_NUM;i++)
ffe05e67:	222b      	addi.n	a2, a2, 2

ffe05e69 <main+0x859>:
            }
        }
    }

    // set glb register if required debug 
    if (0xff != l_pEfuseFile->bsNormal_REG0_ADDR)
ffe05e69:	0020c0        	memw
ffe05e6c:	1e0082        	l8ui	a8, a0, 30
ffe05e6f:	ffa092        	movi	a9, 255
ffe05e72:	c08890        	sub	a8, a8, a9
ffe05e75:	c10816        	beqz	a8, ffe05a89 <main+0x479>
    {
        rGLB(l_pEfuseFile->bsNormal_REG0_ADDR) = l_pEfuseFile->bsNormal_REG0_DATA;
ffe05e78:	0020c0        	memw
ffe05e7b:	1e00b2        	l8ui	a11, a0, 30
ffe05e7e:	bbca      	add.n	a11, a11, a12
ffe05e80:	0020c0        	memw
ffe05e83:	0f00a2        	l8ui	a10, a0, 15
ffe05e86:	0020c0        	memw
ffe05e89:	806ba2        	s32i	a10, a11, 0x200
ffe05e8c:	fefe46        	j	ffe05a89 <main+0x479>

ffe05e8f <main+0x87f>:
	...

ffe05e90 <_start>:
ffe05e90:	000c      	movi.n	a0, 0
ffe05e92:	efb411        	l32r	a1, ffe01d64 <_bss_table_end+0x3e8>
ffe05e95:	032c      	movi.n	a3, 32
ffe05e97:	13e630        	wsr.ps	a3
ffe05e9a:	002010        	rsync
ffe05e9d:	ff7705        	call0	ffe05610 <main>

ffe05ea0 <_start+0x10>:
ffe05ea0:	0041f0        	break	1, 15
ffe05ea3:	fffe46        	j	ffe05ea0 <_start+0x10>

ffe05ea6 <_start+0x16>:
	...

ffe05ea8 <READ_PS>:
ffe05ea8:	03e620        	rsr.ps	a2
ffe05eab:	f00d      	ret.n

ffe05ead <READ_PS+0x5>:
ffe05ead:	000000                                        ...

ffe05eb0 <_xtos_syscall_handler>:
ffe05eb0:	03b130        	rsr.epc1	a3
ffe05eb3:	030120        	rsr.lend	a2
ffe05eb6:	333b      	addi.n	a3, a3, 3
ffe05eb8:	0c9237        	bne	a2, a3, ffe05ec8 <_xtos_syscall_handler+0x18>
ffe05ebb:	030220        	rsr.lcount	a2
ffe05ebe:	628c      	beqz.n	a2, ffe05ec8 <_xtos_syscall_handler+0x18>
ffe05ec0:	220b      	addi.n	a2, a2, -1
ffe05ec2:	130220        	wsr.lcount	a2
ffe05ec5:	030030        	rsr.lbeg	a3

ffe05ec8 <_xtos_syscall_handler+0x18>:
ffe05ec8:	5128      	l32i.n	a2, a1, 20
ffe05eca:	13b130        	wsr.epc1	a3
ffe05ecd:	6138      	l32i.n	a3, a1, 24
ffe05ecf:	f27c      	movi.n	a2, -1
ffe05ed1:	01d112        	addmi	a1, a1, 0x100
ffe05ed4:	003000        	rfe

Disassembly of section rom_func_table:

ffe05fc0 <aRomFunc>:
ffe05fc0:	ffe04164 ffe04430 ffe051b4              dA..0D...Q..

Disassembly of section .debug_aranges:

00000000 <.debug_aranges>:
   0:	0000001c 00000002 00040000 00000000     ................
  10:	ffe01d68 00004127 00000000 00000000     h...'A..........
  20:	0000001c 10370002 00040000 00000000     ......7.........
  30:	ffe05eb0 00000027 00000000 00000000     .^..'...........
  40:	0000001c 110b0002 00040000 00000000     ................
  50:	ffe00a40 00000006 00000000 00000000     @...............
  60:	0000001c 11d80002 00040000 00000000     ................
  70:	ffe00a80 0000000b 00000000 00000000     ................
  80:	0000001c 12a50002 00040000 00000000     ................
  90:	ffe00bd0 00000006 00000000 00000000     ................
  a0:	0000001c 13730002 00040000 00000000     ......s.........
  b0:	ffe00b00 00000006 00000000 00000000     ................
  c0:	0000001c 14410002 00040000 00000000     ......A.........
  d0:	ffe00ac0 00000003 00000000 00000000     ................

Disassembly of section .debug_pubnames:

00000000 <.debug_pubnames>:
   0:	0000071c 00000002 10370000 00a20000     ..........7.....
  10:	41480000 61535f4c 6f436174 7274736e     ..HAL_SataConstr
  20:	41746375 6553646e 4950646e 7465534f     uctAndSendPIOSet
  30:	49467075 00de0053 314c0000 7465475f     upFIS.....L1_Get
  40:	42515244 654c6b6c 0105006e 41480000     DRQBlkLen.....HA
  50:	61535f4c 65536174 7553646e 73656363     L_SataSendSucces
  60:	61745373 00737574 00000137 5f4c4148     sStatus.7...HAL_
  70:	67697254 53726567 44617461 60006773     TriggerSataDsg.`
  80:	48000001 475f4c41 75437465 74615372     ...HAL_GetCurSat
  90:	67734461 00018800 4c414800 6573555f     aDsg.....HAL_Use
  a0:	74615364 47534461 0001af00 4c414800     dSataDSG.....HAL
  b0:	7465475f 61746153 41677344 00726464     _GetSataDsgAddr.
  c0:	000001d8 475f314c 70537465 61696365     ....L1_GetSpecia
  d0:	6165526c 47534464 00020400 5f314c00     lReadDSG.....L1_
  e0:	6b736154 61746153 2c004f49 4c000002     TaskSataIO.,...L
  f0:	70535f31 4874696c 00444d43 00000251     1_SplitHCMD.Q...
 100:	5f4c4148 61746153 646e6553 726f6241     HAL_SataSendAbor
 110:	61745374 00737574 00000281 535f314c     tStatus.....L1_S
 120:	43617461 6b636568 4d4f4950 69746c75     ataCheckPIOMulti
 130:	45656c70 6c62616e 02b60065 314c0000     pleEnable.....L1
 140:	7361545f 6863536b 6c756465 6e6f4e65     _TaskScheduleNon
 150:	74614465 02e50061 314c0000 736f485f     eData.....L1_Hos
 160:	444d4374 656c6553 0d007463 4c000003     tCMDSelect.....L
 170:	61545f31 76456b73 48746e65 6c646e61     1_TaskEventHandl
 180:	03380065 6f430000 68436d6d 456b6365     e.8...CommCheckE
 190:	746e6576 00035d00 5f314c00 6b736154     vent.]...L1_Task
 1a0:	65686353 656c7564 00038400 6f6f4200     Schedule.....Boo
 1b0:	00705574 000003a1 5f4c4148 6153704d     tUp.....HAL_MpSa
 1c0:	614d6174 c8006e69 48000003 555f4c41     taMain.....HAL_U
 1d0:	50747261 44636f72 7257414d 61746144     artProcDMAWrData
 1e0:	0003f500 4c414800 7261555f 6f725074     .....HAL_UartPro
 1f0:	414d4463 704f7257 00042000 4c414800     cDMAWrOp. ...HAL
 200:	7261555f 6f725074 6e694663 00687369     _UartProcFinish.
 210:	0000044a 5f4c4148 74726155 636f7250     J...HAL_UartProc
 220:	79636552 00656c63 00000475 5f4c4148     Recycle.u...HAL_
 230:	74726155 636f7250 74697257 049e0065     UartProcWrite...
 240:	41480000 61555f4c 72507472 6552636f     ..HAL_UartProcRe
 250:	c6006461 48000004 555f4c41 50747261     ad.....HAL_UartP
 260:	4a636f72 00706d75 000004ee 5f4c4148     rocJump.....HAL_
 270:	74726155 50657250 50636f72 006b6361     UartPreProcPack.
 280:	00000519 5f4c4148 74726155 636f7250     ....HAL_UartProc
 290:	00676953 00000541 5f4c4148 74726155     Sig.A...HAL_Uart
 2a0:	61507854 68006b63 48000005 555f4c41     TxPack.h...HAL_U
 2b0:	52747261 63615078 058f006b 41480000     artRxPack.....HA
 2c0:	61555f4c 72507472 6c43636f 54726165     L_UartProcClearT
 2d0:	66754278 0005bd00 4c414800 7261555f     xBuf.....HAL_Uar
 2e0:	6f725074 72724563 7700726f 48000006     tProcError.w...H
 2f0:	535f4c41 70617274 52746547 50646165     AL_StrapGetReadP
 300:	00514352 000006cc 5f4c4148 4e746547     RCQ.....HAL_GetN
 310:	616d726f 6773446c 72646441 0006f700     ormalDsgAddr....
 320:	4c414800 7465475f 6d726f4e 73446c61     .HAL_GetNormalDs
 330:	071f0067 41480000 664e5f4c 61655263     g.....HAL_NfcRea
 340:	6f6f4264 616f6c74 00726564 0000074d     dBootloader.M...
 350:	5f4c4148 74696e49 65746e49 70757272     HAL_InitInterrup
 360:	07760074 41480000 61555f4c 42447472     t.v...HAL_UartDB
 370:	07990047 41480000 704d5f4c 65696350     G.....HAL_MpPcie
 380:	6e69614d 0007bf00 4c414800 616c465f     Main.....HAL_Fla
 390:	6e496873 746e4574 e7007972 48000007     shIntEntry.....H
 3a0:	535f4c41 49617461 53494673 72656658     AL_SataIsFISXfer
 3b0:	69617641 6c62616c 08190065 41480000     Available.....HA
 3c0:	61535f4c 6e496174 61697469 657a696c     L_SataInitialize
 3d0:	00084200 4c414800 7461535f 6e655361     .B...HAL_SataSen
 3e0:	6f6f4764 61745364 00737574 00000871     dGoodStatus.q...
 3f0:	5f4c4148 61746153 64656546 6b636162     HAL_SataFeedback
 400:	57486f74 00089d00 4c414800 7461535f     toHW.....HAL_Sat
 410:	74655361 6e617254 72656673 61726150     aSetTransferPara
 420:	0038346d 000008cf 5f4c4148 61746153     m48.....HAL_Sata
 430:	54746553 736e6172 50726566 6d617261     SetTransferParam
 440:	01003832 48000009 535f4c41 49415441     28.....HAL_SATAI
 450:	6e45746e 00797274 00000929 5f4c4148     ntEntry.)...HAL_
 460:	6954344c 4972656d 6e45746e 00797274     L4TimerIntEntry.
 470:	00000953 5f4c4148 72657355 70637845     S...HAL_UserExcp
 480:	72746e45 097c0079 45540000 465f5453     Entry.|...TEST_F
 490:	52636e75 72757465 0a3a006e 41480000     uncReturn.:...HA
 4a0:	664e5f4c 74654763 65536543 0a62006c     L_NfcGetCeSel.b.
 4b0:	41480000 664e5f4c 74654763 50796850     ..HAL_NfcGetPhyP
 4c0:	0a8a0075 41480000 664e5f4c 61655263     u.....HAL_NfcRea
 4d0:	00644964 00000ab0 5f4c4148 6e616353     dId.....HAL_Scan
 4e0:	d2007550 4800000a 535f4c41 45447465     Pu.....HAL_SetDE
 4f0:	4359414c 544e554f 000b2200 4c414800     LAYCOUNT."...HAL
 500:	7465535f 454d454d 4441444e 4b005244     _SetMEMENDADDR.K
 510:	4800000b 535f4c41 454d7465 4154534d     ...HAL_SetMEMSTA
 520:	44415452 76005244 4800000b 545f4c41     RTADDR.v...HAL_T
 530:	49786172 61725473 63416563 65766974     raxIsTraceActive
 540:	000ba400 4c414800 6172545f 74654778     .....HAL_TraxGet
 550:	63617254 6d615265 657a6953 000bd400     TraceRamSize....
 560:	4c414800 6172545f 61745378 fa007472     .HAL_TraxStart..
 570:	4800000b 545f4c41 47786172 6f507465     ...HAL_TraxGetPo
 580:	69537473 2600657a 4800000c 545f4c41     stSize.&...HAL_T
 590:	53786172 6f507465 69537473 5200657a     raxSetPostSize.R
 5a0:	4800000c 545f4c41 53786172 4d537465     ...HAL_TraxSetSM
 5b0:	00524550 00000c7b 5f4c4148 78617254     PER.{...HAL_Trax
 5c0:	52746547 6f426d61 61646e75 aa007972     GetRamBoundary..
 5d0:	4800000c 545f4c41 53786172 61527465     ...HAL_TraxSetRa
 5e0:	756f426d 7261646e 0cd90079 41480000     mBoundary.....HA
 5f0:	72545f4c 6e497861 52457469 0d010049     L_TraxInitERI...
 600:	41480000 6f435f4c 54676966 65636172     ..HAL_CofigTrace
 610:	66667542 6974754d 0075634d 00000d32     BuffMutiMcu.2...
 620:	5f4c4148 5a6d654d 006f7265 00000d54     HAL_MemZero.T...
 630:	5f4c4148 61727453 63664e70 65707954     HAL_StrapNfcType
 640:	000da500 4c414800 63664e5f 65736552     .....HAL_NfcRese
 650:	00755074 00000dcc 5f4c4148 6d726f4e     tPu.....HAL_Norm
 660:	73446c61 696e4967 0e460074 42440000     alDsgInit.F...DB
 670:	65475f47 00686374 00000e65 5f4c4148     G_Getch.e...HAL_
 680:	45414d44 6e457349 41797274 6c696176     DMAEIsEntryAvail
 690:	656c6261 000e9400 4c414800 414d445f     able.....HAL_DMA
 6a0:	72615045 64416573 73657264 0ef30073     EParseAddress...
 6b0:	41480000 65445f4c 4379616c 656c6379     ..HAL_DelayCycle
 6c0:	000f6300 67626400 6972705f 0066746e     .c...dbg_printf.
 6d0:	00000f87 5f4c4148 436d654d a8007970     ....HAL_MemCpy..
 6e0:	4800000f 535f4c41 6d446970 61655261     ...HAL_SpiDmaRea
 6f0:	0fcf0064 41480000 6c465f4c 42687361     d.....HAL_FlashB
 700:	00746f6f 00000ff4 5f4c4148 6e497748     oot.....HAL_HwIn
 710:	16007469 6d000010 006e6961 00000000     it.....main.....

Disassembly of section .debug_info:

00000000 <.debug_info>:
       0:	00001033 00000002 01040000 535c3a44     3...........D:\S
      10:	6372756f 65525c65 5c736f70 2d445353     ource\Repos\SSD-
      20:	35335456 725c3431 565c6d6f 31353354     VT3514\rom\VT351
      30:	30435f34 4d4f525f 7269665c 7261776d     4_C0_ROM\firmwar
      40:	616d5c65 632e6e69 5c3a4400 72756f53     e\main.c.D:\Sour
      50:	525c6563 736f7065 4453535c 3354562d     ce\Repos\SSD-VT3
      60:	5c343135 5c6d6f72 35335456 435f3431     514\rom\VT3514_C
      70:	4f525f30 69665c4d 61776d72 78006572     0_ROM\firmware.x
      80:	63782d74 6f662063 31312072 312e302e     t-xcc for 11.0.1
      90:	504f2d20 70733a54 00656361 00000001      -OPT:space.....
      a0:	01020000 414803cc 61535f4c 6f436174     ......HAL_SataCo
      b0:	7274736e 41746375 6553646e 4950646e     nstructAndSendPI
      c0:	7465534f 49467075 01010053 01920301     OSetupFIS.......
      d0:	00910210 ffe01d68 ffe01e0c 01030110     ....h...........
      e0:	314c0379 7465475f 42515244 654c6b6c     y.L1_GetDRQBlkLe
      f0:	0101006e 00019203 0c009102 2dffe01e     n..............-
     100:	00ffe01e a0010201 4c414803 7461535f     .........HAL_Sat
     110:	6e655361 63755364 73736563 74617453     aSendSuccessStat
     120:	01007375 92030101 91021001 e01e3000     us...........0..
     130:	e01e98ff 040110ff 4148a501 72545f4c     ..........HAL_Tr
     140:	65676769 74615372 67734461 03010100     iggerSataDsg....
     150:	02000192 1e980091 1ecaffe0 0100ffe0     ................
     160:	486f0104 475f4c41 75437465 74615372     ..oHAL_GetCurSat
     170:	67734461 03010100 02100192 1ecc0091     aDsg............
     180:	1f3dffe0 0110ffe0 48340105 555f4c41     ..=.......4HAL_U
     190:	53646573 44617461 01004753 92030101     sedSataDSG......
     1a0:	91021001 e01f4000 e01ff5ff 040110ff     .....@..........
     1b0:	4148ce01 65475f4c 74615374 67734461     ..HAL_GetSataDsg
     1c0:	72646441 03010100 02100192 1ff80091     Addr............
     1d0:	2015ffe0 0110ffe0 014a0103 475f314c     ... ......J.L1_G
     1e0:	70537465 61696365 6165526c 47534464     etSpecialReadDSG
     1f0:	03010100 02100192 20180491 205dffe0     ........... ..] 
     200:	0110ffe0 01ed0102 545f314c 536b7361     ........L1_TaskS
     210:	49617461 0101004f 01920401 910300e0     ataIO...........
     220:	206000c8 2587ffe0 0160ffe0 014e0102     ..` ...%..`...N.
     230:	535f314c 74696c70 444d4348 01010100     L1_SplitHCMD....
     240:	10019203 880c9102 60ffe025 10ffe026     ........%..`&...
     250:	87010201 4c414803 7461535f 6e655361     .....HAL_SataSen
     260:	6f624164 74537472 73757461 01010100     dAbortStatus....
     270:	10019203 60009102 dbffe026 10ffe026     .......`&...&...
     280:	79010301 5f314c04 61746153 63656843     ...y.L1_SataChec
     290:	4f49506b 746c754d 656c7069 62616e45     kPIOMultipleEnab
     2a0:	0100656c 01920301 00910200 ffe026dc     le...........&..
     2b0:	ffe02701 01050100 5f314c93 6b736154     .'.......L1_Task
     2c0:	65686353 656c7564 656e6f4e 61746144     ScheduleNoneData
     2d0:	01010100 30019203 040c9102 06ffe027     .......0....'...
     2e0:	30ffe02f 09010301 5f314c01 74736f48     /..0.....L1_Host
     2f0:	53444d43 63656c65 01010074 00019203     CMDSelect.......
     300:	08009102 3cffe02f 00ffe02f 41010201     ..../..</......A
     310:	5f314c01 6b736154 6e657645 6e614874     .L1_TaskEventHan
     320:	00656c64 03010101 02300192 2f3c1891     dle.......0...</
     330:	307cffe0 0130ffe0 43570104 436d6d6f     ..|0..0...WCommC
     340:	6b636568 6e657645 01010074 00019203     heckEvent.......
     350:	7c009102 93ffe030 00ffe030 4f010501     ...|0...0......O
     360:	545f314c 536b7361 64656863 00656c75     L1_TaskSchedule.
     370:	03010101 02100192 30940091 3161ffe0     ...........0..a1
     380:	0110ffe0 42ec0106 55746f6f 01010070     .......BootUp...
     390:	10019203 64049102 ddffe031 10ffe031     .......d1...1...
     3a0:	38010201 4c414801 53704d5f 4d617461     ...8.HAL_MpSataM
     3b0:	006e6961 03010101 02100192 31e00091     ain............1
     3c0:	321dffe0 0110ffe0 02b90103 5f4c4148     ...2........HAL_
     3d0:	74726155 636f7250 57414d44 74614472     UartProcDMAWrDat
     3e0:	01010061 00019203 20009102 50ffe032     a.......... 2..P
     3f0:	00ffe032 ae010301 4c414802 7261555f     2........HAL_Uar
     400:	6f725074 414d4463 704f7257 03010100     tProcDMAWrOp....
     410:	02000192 32500091 326affe0 0100ffe0     ......P2..j2....
     420:	02a90103 5f4c4148 74726155 636f7250     ....HAL_UartProc
     430:	696e6946 01006873 01920301 00910200     Finish..........
     440:	ffe0326c ffe03276 01030100 41480294     l2..v2........HA
     450:	61555f4c 72507472 6552636f 6c637963     L_UartProcRecycl
     460:	01010065 10019203 78009102 a2ffe032     e..........x2...
     470:	10ffe032 75010301 4c414802 7261555f     2......u.HAL_Uar
     480:	6f725074 69725763 01006574 01920301     tProcWrite......
     490:	00910210 ffe032a4 ffe032ed 01030110     .....2...2......
     4a0:	41480256 61555f4c 72507472 6552636f     V.HAL_UartProcRe
     4b0:	01006461 01920301 00910210 ffe032f0     ad...........2..
     4c0:	ffe03330 01030110 4148023c 61555f4c     03......<.HAL_Ua
     4d0:	72507472 754a636f 0100706d 01920301     rtProcJump......
     4e0:	00910210 ffe03330 ffe0335f 01030110     ....03.._3......
     4f0:	4148021e 61555f4c 72507472 6f725065     ..HAL_UartPrePro
     500:	63615063 0101006b 10019203 60009102     cPack..........`
     510:	95ffe033 10ffe033 bb010201 4c414801     3...3........HAL
     520:	7261555f 6f725074 67695363 01010100     _UartProcSig....
     530:	10019203 98009102 b7ffe033 10ffe034     ........3...4...
     540:	a0010201 4c414801 7261555f 50785474     .....HAL_UartTxP
     550:	006b6361 03010101 02100192 34b80091     ack............4
     560:	3503ffe0 0110ffe0 016c0102 5f4c4148     ...5......l.HAL_
     570:	74726155 61507852 01006b63 92030101     UartRxPack......
     580:	91021001 e0350400 e035adff 030110ff     ......5...5.....
     590:	48015101 555f4c41 50747261 43636f72     .Q.HAL_UartProcC
     5a0:	7261656c 75427854 01010066 10019203     learTxBuf.......
     5b0:	b0009102 d1ffe035 10ffe035 3e010301     ....5...5......>
     5c0:	4c414801 7261555f 6f725074 72724563     .HAL_UartProcErr
     5d0:	0100726f 01920301 00910200 ffe035d4     or...........5..
     5e0:	ffe035e3 01070100 4c4148a9 6970535f     .5.......HAL_Spi
     5f0:	74697845 01004234 10019203 e4049102     Exit4B..........
     600:	1fffe035 10ffe036 95010701 5f4c4148     5...6.......HAL_
     610:	45697053 7265746e 01004234 10019203     SpiEnter4B......
     620:	20049102 62ffe036 10ffe036 7e010701     ... 6..b6......~
     630:	5f4c4148 45697053 7265746e 00495053     HAL_SpiEnterSPI.
     640:	01920301 00910210 ffe03664 ffe036ac     ........d6...6..
     650:	01070110 4c414868 6970535f 65746e45     ....hHAL_SpiEnte
     660:	49505172 92030100 91021001 e036ac00     rQPI..........6.
     670:	e036feff 030110ff 48012901 535f4c41     ..6......).HAL_S
     680:	70617274 52746547 50646165 00514352     trapGetReadPRCQ.
     690:	92030101 91020001 e0370000 e0372fff     ..........7../7.
     6a0:	080100ff 4803e801 435f4c41 6b636568     .......HAL_Check
     6b0:	6e676953 72757461 03010065 02100192     Signature.......
     6c0:	37300091 37b7ffe0 0110ffe0 48bc0104     ..07...7.......H
     6d0:	475f4c41 6f4e7465 6c616d72 41677344     AL_GetNormalDsgA
     6e0:	00726464 92030101 91021001 e037b800     ddr...........7.
     6f0:	e037daff 050110ff 41485601 65475f4c     ..7......VHAL_Ge
     700:	726f4e74 446c616d 01006773 92030101     tNormalDsg......
     710:	91020001 e037dc00 e03827ff 020100ff     ......7..'8.....
     720:	48040501 4e5f4c41 65526366 6f426461     ...HAL_NfcReadBo
     730:	6f6c746f 72656461 01010100 20019203     otloader....... 
     740:	28089102 c3ffe038 20ffe039 cd010501     ...(8...9.. ....
     750:	5f4c4148 74696e49 65746e49 70757272     HAL_InitInterrup
     760:	01010074 01920301 00910200 ffe039c4     t............9..
     770:	ffe03a22 01030100 414802d6 61555f4c     ":........HAL_Ua
     780:	42447472 01010047 10019203 24009102     rtDBG..........$
     790:	50ffe03a 10ffe03a 73010501 5f4c4148     :..P:......sHAL_
     7a0:	6350704d 614d6569 01006e69 92030101     MpPcieMain......
     7b0:	91022001 e03a5000 e03c16ff 040120ff     . ...P:...<.. ..
     7c0:	4148b001 6c465f4c 49687361 6e45746e     ..HAL_FlashIntEn
     7d0:	00797274 92030101 91020001 e03c1800     try...........<.
     7e0:	e03c1aff 030100ff 48032801 535f4c41     ..<......(.HAL_S
     7f0:	49617461 53494673 72656658 69617641     ataIsFISXferAvai
     800:	6c62616c 01010065 00019203 1c009102     lable...........
     810:	2effe03c 00ffe03c 7a010401 5f4c4148     <...<......zHAL_
     820:	61746153 74696e49 696c6169 0100657a     SataInitialize..
     830:	01920301 00910200 ffe03c30 ffe03cec     ........0<...<..
     840:	01020100 4148033e 61535f4c 65536174     ....>.HAL_SataSe
     850:	6f47646e 7453646f 73757461 01010100     ndGoodStatus....
     860:	10019203 ec009102 80ffe03c 10ffe03d     ........<...=...
     870:	23010301 4c414802 7461535f 65654661     ...#.HAL_SataFee
     880:	63616264 486f746b 01010057 00019203     dbacktoHW.......
     890:	80009102 c7ffe03d 00ffe03d dd010301     ....=...=.......
     8a0:	4c414801 7461535f 74655361 6e617254     .HAL_SataSetTran
     8b0:	72656673 61726150 0038346d 92030101     sferParam48.....
     8c0:	91020001 e03dc800 e03de8ff 030100ff     ......=...=.....
     8d0:	4801f801 535f4c41 53617461 72547465     ...HAL_SataSetTr
     8e0:	66736e61 61507265 326d6172 01010038     ansferParam28...
     8f0:	00019203 e8009102 53ffe03d 00ffe03e     ........=..S>...
     900:	9e010501 5f4c4148 41544153 45746e49     ....HAL_SATAIntE
     910:	7972746e 01010100 20019203 54049102     ntry....... ...T
     920:	ffffe03e 20ffe040 8f010401 5f4c4148     >...@.. ....HAL_
     930:	6954344c 4972656d 6e45746e 00797274     L4TimerIntEntry.
     940:	92030101 91020001 e0410000 e04102ff     ..........A...A.
     950:	050100ff 41485601 73555f4c 78457265     .....VHAL_UserEx
     960:	6e457063 00797274 03010101 02000192     cpEntry.........
     970:	41040091 4162ffe0 0100ffe0 54d70104     ...A..bA.......T
     980:	5f545345 636e7546 75746552 01006e72     EST_FuncReturn..
     990:	01920301 00910210 ffe04164 ffe04176     ........dA..vA..
     9a0:	01080110 614802b4 63664e6c 50746547     ......HalNfcGetP
     9b0:	72724575 92030100 91020001 e0417800     uErr.........xA.
     9c0:	e0418bff 090100ff 4802ce01 664e6c61     ..A........HalNf
     9d0:	6e695363 50656c67 61745375 00737574     cSinglePuStatus.
     9e0:	92030101 91021001 e0418c04 e041ebff     ..........A...A.
     9f0:	090110ff 48035701 65536c61 69725474     .....W.HalSetTri
     a00:	72656767 03010100 02100192 41ec0491     gger...........A
     a10:	424effe0 0110ffe0 03130109 536c6148     ..NB........HalS
     a20:	72507465 01007163 01920301 04910210     etPrcq..........
     a30:	ffe04250 ffe042ec 01020110 41480374     PB...B......t.HA
     a40:	664e5f4c 74654763 65536543 0101006c     L_NfcGetCeSel...
     a50:	01920301 00910200 ffe042ec ffe04300     .........B...C..
     a60:	01020100 41480368 664e5f4c 74654763     ....h.HAL_NfcGet
     a70:	50796850 01010075 01920301 00910200     PhyPu...........
     a80:	ffe04300 ffe04312 01020100 414803a6     .C...C........HA
     a90:	664e5f4c 61655263 00644964 03010101     L_NfcReadId.....
     aa0:	02200192 43140491 4430ffe0 0120ffe0     .. ....C..0D.. .
     ab0:	48b50105 535f4c41 506e6163 01010075     ...HAL_ScanPu...
     ac0:	01920301 08910230 ffe04430 ffe04571     ....0...0D..qE..
     ad0:	01030130 41480133 65535f4c 4c454474     0...3.HAL_SetDEL
     ae0:	4f435941 00544e55 92030101 91021001     AYCOUNT.........
     af0:	e0457400 e04598ff 090110ff 48057101     .tE...E......q.H
     b00:	65476c61 61725474 69536563 0100657a     alGetTraceSize..
     b10:	01920301 00910200 ffe04598 ffe045c6     .........E...E..
     b20:	01030100 414801a5 65535f4c 4d454d74     ......HAL_SetMEM
     b30:	41444e45 00524444 92030101 91021001     ENDADDR.........
     b40:	e045c800 e045f5ff 030110ff 48016901     ..E...E......i.H
     b50:	535f4c41 454d7465 4154534d 44415452     AL_SetMEMSTARTAD
     b60:	01005244 01920301 00910210 ffe045f8     DR...........E..
     b70:	ffe04625 01020110 414801c5 72545f4c     %F........HAL_Tr
     b80:	73497861 63617254 74634165 00657669     axIsTraceActive.
     b90:	03010101 02100192 46280891 463fffe0     ..........(F..?F
     ba0:	0110ffe0 02400102 5f4c4148 78617254     ......@.HAL_Trax
     bb0:	54746547 65636172 536d6152 00657a69     GetTraceRamSize.
     bc0:	03010101 02100192 46400891 465fffe0     ..........@F.._F
     bd0:	0110ffe0 04610102 5f4c4148 78617254     ......a.HAL_Trax
     be0:	72617453 01010074 01920301 08910210     Start...........
     bf0:	ffe04660 ffe046a1 01020110 414805e4     `F...F........HA
     c00:	72545f4c 65477861 736f5074 7a695374     L_TraxGetPostSiz
     c10:	01010065 01920301 08910210 ffe046a4     e............F..
     c20:	ffe046d8 01020110 41480594 72545f4c     .F........HAL_Tr
     c30:	65537861 736f5074 7a695374 01010065     axSetPostSize...
     c40:	01920301 08910220 ffe046d8 ffe04788     .... ....F...G..
     c50:	01020120 414803ae 72545f4c 65537861      .....HAL_TraxSe
     c60:	504d5374 01005245 92030101 91021001     tSMPER..........
     c70:	e0478808 e047d9ff 020110ff 4804ce01     ..G...G........H
     c80:	545f4c41 47786172 61527465 756f426d     AL_TraxGetRamBou
     c90:	7261646e 01010079 01920301 00910200     ndary...........
     ca0:	ffe047dc ffe047f6 01020100 4148048a     .G...G........HA
     cb0:	72545f4c 65537861 6d615274 6e756f42     L_TraxSetRamBoun
     cc0:	79726164 01010100 10019203 f8009102     dary............
     cd0:	8bffe047 10ffe048 db010201 4c414803     G...H........HAL
     ce0:	6172545f 696e4978 49524574 01010100     _TraxInitERI....
     cf0:	20019203 8c089102 e9ffe048 20ffe048     ... ....H...H.. 
     d00:	39010301 4c414807 666f435f 72546769     ...9.HAL_CofigTr
     d10:	42656361 4d666675 4d697475 01007563     aceBuffMutiMcu..
     d20:	01920301 00910200 ffe048ec ffe04903     .........H...I..
     d30:	01040100 4c414844 6d654d5f 6f72655a     ....DHAL_MemZero
     d40:	03010100 02000192 49040091 490fffe0     ...........I...I
     d50:	0100ffe0 01980102 5f4c4148 61727453     ........HAL_Stra
     d60:	63664e70 65707954 01010100 00019203     pNfcType........
     d70:	10009102 43ffe049 00ffe049 01010901     ....I..CI.......
     d80:	6c614802 5463664e 6e696d69 696e4967     .HalNfcTimingIni
     d90:	01010074 30019203 44249102 b9ffe049     t......0..$DI...
     da0:	30ffe04a 8a010201 4c414803 63664e5f     J..0.....HAL_Nfc
     db0:	65736552 00755074 03010101 02100192     ResetPu.........
     dc0:	4abc0091 4b27ffe0 0110ffe0 482e0105     ...J..'K.......H
     dd0:	4e5f4c41 616d726f 6773446c 74696e49     AL_NormalDsgInit
     de0:	01010100 00019203 28009102 54ffe04b     ...........(K..T
     df0:	00ffe04b 62010801 6c614802 73616c46     K......b.HalFlas
     e00:	45455168 74696e49 92030100 91020001     hQEEInit........
     e10:	e04b5400 e04b9cff 080100ff 48024301     .TK...K......C.H
     e20:	6c466c61 43687361 6154646d 49656c62     alFlashCmdTableI
     e30:	0074696e 01920301 00910200 ffe04b9c     nit..........K..
     e40:	ffe04be8 010a0100 4742442d 7465475f     .K......-DBG_Get
     e50:	01006863 00019203 e8009102 06ffe04b     ch..........K...
     e60:	00ffe04c f7010401 5f4c4148 45414d44     L.......HAL_DMAE
     e70:	6e457349 41797274 6c696176 656c6261     IsEntryAvailable
     e80:	03010100 02000192 4c080091 4c25ffe0     ...........L..%L
     e90:	0100ffe0 48a70104 445f4c41 5045414d     .......HAL_DMAEP
     ea0:	65737261 72646441 00737365 92030101     arseAddress.....
     eb0:	91020001 e04c2800 e04c64ff 090100ff     .....(L..dL.....
     ec0:	48018501 445f4c41 4345414d 4f79706f     ...HAL_DMAECopyO
     ed0:	6c42656e 4c6b636f 694c6e65 0074696d     neBlockLenLimit.
     ee0:	92030101 91023001 e04c6414 e04debff     .....0...dL...M.
     ef0:	030130ff 4801e001 445f4c41 79616c65     .0.....HAL_Delay
     f00:	6c637943 01010065 00019203 ec009102     Cycle...........
     f10:	f8ffe04d 00ffe04d 4d010701 5f4c4148     M...M......MHAL_
     f20:	53697053 43646e65 00646d43 01920301     SpiSendCCmd.....
     f30:	00910200 ffe04df8 ffe04e80 01090100     .....M...N......
     f40:	41480183 70535f4c 49574869 0074696e     ..HAL_SpiHWInit.
     f50:	92030101 91020001 e04e8000 e04ec0ff     ..........N...N.
     f60:	050100ff 6264ca01 72705f67 66746e69     ......dbg_printf
     f70:	01010100 d0019204 d0910300 e04ec000     ..............N.
     f80:	e05056ff 040150ff 41485801 654d5f4c     .VP..P...XHAL_Me
     f90:	7970436d 03010100 02000192 50580091     mCpy..........XP
     fa0:	5067ffe0 0100ffe0 01e00102 5f4c4148     ..gP........HAL_
     fb0:	44697053 6552616d 01006461 92030101     SpiDmaRead......
     fc0:	91022001 e0506800 e050abff 050120ff     . ...hP...P.. ..
     fd0:	4148ee01 6c465f4c 42687361 00746f6f     ..HAL_FlashBoot.
     fe0:	03010101 02300192 50ac0091 51b2ffe0     ......0....P...Q
     ff0:	0130ffe0 48c90105 485f4c41 696e4977     ..0....HAL_HwIni
    1000:	01010074 01920301 00910210 ffe051b4     t............Q..
    1010:	ffe0560f 010b0110 616d017c 01006e69     .V......|.main..
    1020:	92040101 0200c001 10289102 8fffe056     ..........(.V...
    1030:	40ffe05e d0000001 02000000 00013b00     ^..@.........;..
    1040:	f4010400 b000003f d7ffe05e 2fffe05e     ....?...^...^../
    1050:	6c697562 72742f64 522f6565 30322d46     build/tree/RF-20
    1060:	312e3431 6d756b5f 6f742f61 2f736c6f     14.1_kuma/tools/
    1070:	6f747773 2d736c6f 6957534d 2d32336e     swtools-MSWin32-
    1080:	2f363878 6e657478 652d6173 732f666c     x86/xtensa-elf/s
    1090:	782f6372 2f736f74 2d637865 63737973     rc/xtos/exc-sysc
    10a0:	2d6c6c61 646e6168 2e72656c 3a430053     all-handler.S.C:
    10b0:	6975625c 625c646c 646c6975 2d46525c     \build\build\RF-
    10c0:	34313032 745c312e 69466e65 5c646c65     2014.1\tenField\
    10d0:	676e6f74 66725c77 74616976 6f6c6569     tongw\rfviatielo
    10e0:	3631706f 3339315c 5c353939 69756278     op16\193995\xbui
    10f0:	4f5c646c 74785c53 4700736f 4120554e     ld\OS\xtos.GNU A
    1100:	2e322053 322e3332 c9800100 02000000     S 2.23.2........
    1110:	00014f00 d9010400 40000040 46ffe00a     .O......@..@...F
    1120:	2fffe00a 6c697562 72742f64 522f6565     .../build/tree/R
    1130:	30322d46 312e3431 6d756b5f 6f742f61     F-2014.1_kuma/to
    1140:	2f736c6f 6f747773 2d736c6f 6957534d     ols/swtools-MSWi
    1150:	2d32336e 2f363878 6e657478 652d6173     n32-x86/xtensa-e
    1160:	732f666c 782f6372 2f736f74 6c6c756e     lf/src/xtos/null
    1170:	6365762d 73726f74 4300532e 75625c3a     -vectors.S.C:\bu
    1180:	5c646c69 6c697562 46525c64 3130322d     ild\build\RF-201
    1190:	5c312e34 466e6574 646c6569 6e6f745c     4.1\tenField\ton
    11a0:	725c7767 61697666 6c656974 31706f6f     gw\rfviatieloop1
    11b0:	39315c36 35393933 7562785c 5c646c69     6\193995\xbuild\
    11c0:	785c534f 00736f74 20554e47 32205341     OS\xtos.GNU AS 2
    11d0:	2e33322e 80010032 000000c9 01630002     .23.2.........c.
    11e0:	01040000 00004168 ffe00a80 ffe00a8b     ....hA..........
    11f0:	6975622f 742f646c 2f656572 322d4652     /build/tree/RF-2
    1200:	2e343130 756b5f31 742f616d 736c6f6f     014.1_kuma/tools
    1210:	7477732f 736c6f6f 57534d2d 32336e69     /swtools-MSWin32
    1220:	3638782d 6574782f 2d61736e 2f666c65     -x86/xtensa-elf/
    1230:	2f637273 736f7478 6265642f 762d6775     src/xtos/debug-v
    1240:	6f746365 00532e72 625c3a43 646c6975     ector.S.C:\build
    1250:	6975625c 525c646c 30322d46 312e3431     \build\RF-2014.1
    1260:	6e65745c 6c656946 6f745c64 5c77676e     \tenField\tongw\
    1270:	69766672 65697461 706f6f6c 315c3631     rfviatieloop16\1
    1280:	39393339 62785c35 646c6975 5c534f5c     93995\xbuild\OS\
    1290:	736f7478 554e4700 20534120 33322e32     xtos.GNU AS 2.23
    12a0:	0100322e 0000ca80 77000200 04000001     .2.........w....
    12b0:	00420201 e00bd000 e00bd6ff 75622fff     ..B........../bu
    12c0:	2f646c69 65657274 2d46522f 34313032     ild/tree/RF-2014
    12d0:	6b5f312e 2f616d75 6c6f6f74 77732f73     .1_kuma/tools/sw
    12e0:	6c6f6f74 534d2d73 336e6957 38782d32     tools-MSWin32-x8
    12f0:	74782f36 61736e65 666c652d 6372732f     6/xtensa-elf/src
    1300:	6f74782f 6f642f73 656c6275 6365762d     /xtos/double-vec
    1310:	2e726f74 3a430053 6975625c 625c646c     tor.S.C:\build\b
    1320:	646c6975 2d46525c 34313032 745c312e     uild\RF-2014.1\t
    1330:	69466e65 5c646c65 676e6f74 66725c77     enField\tongw\rf
    1340:	74616976 6f6c6569 3631706f 3339315c     viatieloop16\193
    1350:	5c353939 69756278 4f5c646c 74785c53     995\xbuild\OS\xt
    1360:	4700736f 4120554e 2e322053 322e3332     os.GNU AS 2.23.2
    1370:	ca800100 02000000 00018b00 91010400     ................
    1380:	00000042 06ffe00b 2fffe00b 6c697562     B........../buil
    1390:	72742f64 522f6565 30322d46 312e3431     d/tree/RF-2014.1
    13a0:	6d756b5f 6f742f61 2f736c6f 6f747773     _kuma/tools/swto
    13b0:	2d736c6f 6957534d 2d32336e 2f363878     ols-MSWin32-x86/
    13c0:	6e657478 652d6173 732f666c 782f6372     xtensa-elf/src/x
    13d0:	2f736f74 6e72656b 762d6c65 6f746365     tos/kernel-vecto
    13e0:	00532e72 625c3a43 646c6975 6975625c     r.S.C:\build\bui
    13f0:	525c646c 30322d46 312e3431 6e65745c     ld\RF-2014.1\ten
    1400:	6c656946 6f745c64 5c77676e 69766672     Field\tongw\rfvi
    1410:	65697461 706f6f6c 315c3631 39393339     atieloop16\19399
    1420:	62785c35 646c6975 5c534f5c 736f7478     5\xbuild\OS\xtos
    1430:	554e4700 20534120 33322e32 0100322e     .GNU AS 2.23.2..
    1440:	0000c780 9f000200 04000001 00432001     ............. C.
    1450:	e00ac000 e00ac3ff 75622fff 2f646c69     ........./build/
    1460:	65657274 2d46522f 34313032 6b5f312e     tree/RF-2014.1_k
    1470:	2f616d75 6c6f6f74 77732f73 6c6f6f74     uma/tools/swtool
    1480:	534d2d73 336e6957 38782d32 74782f36     s-MSWin32-x86/xt
    1490:	61736e65 666c652d 6372732f 6f74782f     ensa-elf/src/xto
    14a0:	6d6e2f73 65762d69 726f7463 4300532e     s/nmi-vector.S.C
    14b0:	75625c3a 5c646c69 6c697562 46525c64     :\build\build\RF
    14c0:	3130322d 5c312e34 466e6574 646c6569     -2014.1\tenField
    14d0:	6e6f745c 725c7767 61697666 6c656974     \tongw\rfviatiel
    14e0:	31706f6f 39315c36 35393933 7562785c     oop16\193995\xbu
    14f0:	5c646c69 785c534f 00736f74 20554e47     ild\OS\xtos.GNU 
    1500:	32205341 2e33322e 80010032              AS 2.23.2...

Disassembly of section .debug_abbrev:

00000000 <.debug_abbrev>:
   0:	03011101 25081b08 420b1308 0006100b     .......%...B....
  10:	002e0200 053b0b3a 0c3f0803 408b0c27     ....:.;...?.'..@
  20:	2a0a400c 1201110a 0b7e8101 000b7e82     .@.*......~..~..
  30:	002e0300 053b0b3a 0c3f0803 0a400c27     ....:.;...?.'.@.
  40:	01110a2a 7e810112 0b7e820b 2e040000     *......~..~.....
  50:	3b0b3a00 3f08030b 400c270c 110a2a0a     .:.;...?.'.@.*..
  60:	81011201 7e820b7e 0500000b 0b3a002e     ....~..~......:.
  70:	08030b3b 0c270c3f 400c408b 110a2a0a     ;...?.'..@.@.*..
  80:	81011201 7e820b7e 0600000b 0b3a002e     ....~..~......:.
  90:	08030b3b 408b0c3f 2a0a400c 1201110a     ;...?..@.@.*....
  a0:	0b7e8101 000b7e82 002e0700 0b3b0b3a     ..~..~......:.;.
  b0:	0c270803 0a2a0a40 01120111 820b7e81     ..'.@.*......~..
  c0:	00000b7e 3a002e08 03053b0b 400c2708     ~......:.;...'.@
  d0:	110a2a0a 81011201 7e820b7e 0900000b     .*......~..~....
  e0:	0b3a002e 0803053b 408b0c27 2a0a400c     ..:.;...'..@.@.*
  f0:	1201110a 0b7e8101 000b7e82 002e0a00     ......~..~......
 100:	0b3b0b3a 0c3f0803 0a2a0a40 01120111     :.;...?.@.*.....
 110:	820b7e81 00000b7e 3a002e0b 03053b0b     .~..~......:.;..
 120:	270c3f08 0c408b0c 0b360a40 01110a2a     .?.'..@.@.6.*...
 130:	7e810112 0b7e820b 01000000 06100011     ...~..~.........
 140:	01120111 081b0803 05130825 01000000     ........%.......
 150:	06100011 01120111 081b0803 05130825     ............%...
 160:	01000000 06100011 01120111 081b0803     ................
 170:	05130825 01000000 06100011 01120111     %...............
 180:	081b0803 05130825 01000000 06100011     ....%...........
 190:	01120111 081b0803 05130825 01000000     ........%.......
 1a0:	06100011 01120111 081b0803 05130825     ............%...
 1b0:	03000000                                         ...

Disassembly of section .debug_line:

00000000 <.debug_line>:
       0:	00003ff0 05ad0002 01010000 000d0efb     .?..............
      10:	01010101 01000000 44010000 6f535c3a     ...........D:\So
      20:	65637275 7065525c 535c736f 562d4453     urce\Repos\SSD-V
      30:	31353354 6f725c34 54565c6d 34313533     T3514\rom\VT3514
      40:	5f30435f 5c4d4f52 6d726966 65726177     _C0_ROM\firmware
      50:	5c3a4400 72756f53 525c6563 736f7065     .D:\Source\Repos
      60:	4453535c 3354562d 5c343135 5c6d6f72     \SSD-VT3514\rom\
      70:	35335456 435f3431 4f525f30 69665c4d     VT3514_C0_ROM\fi
      80:	61776d72 435c6572 44004d4f 6f535c3a     rmware\COM.D:\So
      90:	65637275 7065525c 535c736f 562d4453     urce\Repos\SSD-V
      a0:	31353354 6f725c34 54565c6d 34313533     T3514\rom\VT3514
      b0:	5f30435f 5c4d4f52 6d726966 65726177     _C0_ROM\firmware
      c0:	4c41485c 414d445c 3a440045 756f535c     \HAL\DMAE.D:\Sou
      d0:	5c656372 6f706552 53535c73 54562d44     rce\Repos\SSD-VT
      e0:	34313533 6d6f725c 3354565c 5f343135     3514\rom\VT3514_
      f0:	525f3043 665c4d4f 776d7269 5c657261     C0_ROM\firmware\
     100:	5c4c4148 65746e49 70757272 3a440074     HAL\Interrupt.D:
     110:	756f535c 5c656372 6f706552 53535c73     \Source\Repos\SS
     120:	54562d44 34313533 6d6f725c 3354565c     D-VT3514\rom\VT3
     130:	5f343135 525f3043 665c4d4f 776d7269     514_C0_ROM\firmw
     140:	5c657261 5c4c4148 4400504d 6f535c3a     are\HAL\MP.D:\So
     150:	65637275 7065525c 535c736f 562d4453     urce\Repos\SSD-V
     160:	31353354 6f725c34 54565c6d 34313533     T3514\rom\VT3514
     170:	5f30435f 5c4d4f52 6d726966 65726177     _C0_ROM\firmware
     180:	4c41485c 43464e5c 5c3a4400 72756f53     \HAL\NFC.D:\Sour
     190:	525c6563 736f7065 4453535c 3354562d     ce\Repos\SSD-VT3
     1a0:	5c343135 5c6d6f72 35335456 435f3431     514\rom\VT3514_C
     1b0:	4f525f30 69665c4d 61776d72 485c6572     0_ROM\firmware\H
     1c0:	4e5c4c41 616d726f 6773446c 5c3a4400     AL\NormalDsg.D:\
     1d0:	72756f53 525c6563 736f7065 4453535c     Source\Repos\SSD
     1e0:	3354562d 5c343135 5c6d6f72 35335456     -VT3514\rom\VT35
     1f0:	435f3431 4f525f30 69665c4d 61776d72     14_C0_ROM\firmwa
     200:	485c6572 505c4c41 44006e69 6f535c3a     re\HAL\Pin.D:\So
     210:	65637275 7065525c 535c736f 562d4453     urce\Repos\SSD-V
     220:	31353354 6f725c34 54565c6d 34313533     T3514\rom\VT3514
     230:	5f30435f 5c4d4f52 6d726966 65726177     _C0_ROM\firmware
     240:	4c41485c 4950535c 5c3a4400 72756f53     \HAL\SPI.D:\Sour
     250:	525c6563 736f7065 4453535c 3354562d     ce\Repos\SSD-VT3
     260:	5c343135 5c6d6f72 35335456 435f3431     514\rom\VT3514_C
     270:	4f525f30 69665c4d 61776d72 485c6572     0_ROM\firmware\H
     280:	745c4c41 65636172 5c3a4400 72756f53     AL\trace.D:\Sour
     290:	525c6563 736f7065 4453535c 3354562d     ce\Repos\SSD-VT3
     2a0:	5c343135 5c6d6f72 35335456 435f3431     514\rom\VT3514_C
     2b0:	4f525f30 69665c4d 61776d72 485c6572     0_ROM\firmware\H
     2c0:	545c4c41 00786172 535c3a44 6372756f     AL\Trax.D:\Sourc
     2d0:	65525c65 5c736f70 2d445353 35335456     e\Repos\SSD-VT35
     2e0:	725c3431 565c6d6f 31353354 30435f34     14\rom\VT3514_C0
     2f0:	4d4f525f 7269665c 7261776d 41485c65     _ROM\firmware\HA
     300:	74585c4c 61736e65 5c3a4400 72756f53     L\Xtensa.D:\Sour
     310:	525c6563 736f7065 4453535c 3354562d     ce\Repos\SSD-VT3
     320:	5c343135 5c6d6f72 35335456 435f3431     514\rom\VT3514_C
     330:	4f525f30 69665c4d 61776d72 535c6572     0_ROM\firmware\S
     340:	00415441 69616d00 00632e6e 43000001     ATA..main.c....C
     350:	4d5f4d4f 726f6d65 00632e79 48000002     OM_Memory.c....H
     360:	445f4c41 2e65616d 00030063 4c414800     AL_Dmae.c....HAL
     370:	746e495f 75727265 632e7470 00000400     _Interrupt.c....
     380:	5f4c4148 632e504d 00000500 5f4c4148     HAL_MP.c....HAL_
     390:	2e43464e 00060063 4c414800 726f4e5f     NFC.c....HAL_Nor
     3a0:	446c616d 632e4753 00000700 5f4c4148     malDSG.c....HAL_
     3b0:	2e6e6950 00080063 4c414800 6970535f     Pin.c....HAL_Spi
     3c0:	746f6f42 0900632e 41480000 70535f4c     Boot.c....HAL_Sp
     3d0:	69724469 2e726576 00090063 72617500     iDriver.c....uar
     3e0:	00632e74 4800000a 545f4c41 2e786172     t.c....HAL_Trax.
     3f0:	000b0063 4c414800 6574585f 2e61736e     c....HAL_Xtensa.
     400:	000c0063 4d4f4300 6f6f425f 2e707574     c....COM_Bootup.
     410:	000d0063 4d4f4300 6576455f 632e746e     c....COM_Event.c
     420:	00000d00 5f4c4148 4d667542 632e7061     ....HAL_BufMap.c
     430:	00000d00 5f4c4148 66667542 632e7265     ....HAL_Buffer.c
     440:	00000d00 5f4c4148 68636143 00632e65     ....HAL_Cache.c.
     450:	4800000d 445f4c41 436c6175 2e65726f     ...HAL_DualCore.
     460:	000d0063 4c414800 696e495f 00632e74     c....HAL_Init.c.
     470:	4800000d 505f4c41 00632e4d 4800000d     ...HAL_PM.c....H
     480:	535f4c41 44617461 632e4753 00000d00     AL_SataDSG.c....
     490:	5f4c4148 61746153 632e4f49 00000d00     HAL_SataIO.c....
     4a0:	5f4c4148 61746153 2e525349 000d0063     HAL_SataISR.c...
     4b0:	5f314c00 66667542 632e7265 00000d00     .L1_Buffer.c....
     4c0:	435f314c 65686361 0d00632e 314c0000     L1_Cache.c....L1
     4d0:	4753445f 0d00632e 314c0000 6265445f     _DSG.c....L1_Deb
     4e0:	632e6775 00000d00 455f314c 726f7272     ug.c....L1_Error
     4f0:	646e6148 676e696c 0d00632e 314c0000     Handling.c....L1
     500:	736f485f 646d4374 2e4f5250 000d0063     _HostCmdPRO.c...
     510:	5f314c00 2e525349 000d0063 5f314c00     .L1_ISR.c....L1_
     520:	65746e49 63616672 00632e65 4c00000d     Interface.c....L
     530:	634e5f31 6e6f4e71 61746144 0d00632e     1_NcqNonData.c..
     540:	314c0000 7461535f 646d4361 0d00632e     ..L1_SataCmd.c..
     550:	314c0000 7461535f 616d5361 632e7472     ..L1_SataSmart.c
     560:	00000d00 535f314c 54617461 2e6d6972     ....L1_SataTrim.
     570:	000d0063 5f314c00 61746153 646e6556     c....L1_SataVend
     580:	65447265 656e6966 0d00632e 314c0000     erDefine.c....L1
     590:	6863535f 6c756465 00632e65 4c00000d     _Schedule.c....L
     5a0:	69565f32 61757472 6f74536c 65676172     2_VirtualStorage
     5b0:	0d00632e 04000000 02050017 ffe01d68     .c..........h...
     5c0:	0107cb03 00090203 7e030100 01000209     ...........~....
     5d0:	10090203 04030100 01000f09 08090103     ................
     5e0:	03030100 01000609 06090103 03030100     ................
     5f0:	01000909 03090203 02030100 01000809     ................
     600:	03090203 0a030100 01000b09 06090203     ................
     610:	02030100 01000309 09090503 8a030100     ................
     620:	0008097e 01fd0301 01000809 06090103     ~...............
     630:	02030100 01001509 07096703 22040100     .........g....."
     640:	097f9503 03010009 00000904 090c0301     ................
     650:	03010012 00090904 09770301 03010002     ..........w.....
     660:	00020909 03170401 00050913 09010301     ................
     670:	03010005 0002097f 09010301 03010006     ................
     680:	000f0901 09010301 03010008 00080901     ................
     690:	7ee80301 01001109 09019a03 03010009     ...~............
     6a0:	00060901 09020301 04010015 79fc0316     ...............y
     6b0:	01000709 0b091203 08030100 01001609     ................
     6c0:	02097c03 b4030100 0011097f 09050301     .|..............
     6d0:	03010010 000b0902 09010301 03010008     ................
     6e0:	0002097f 09010301 03010009 00030909     ................
     6f0:	09020301 03010003 000b0902 09010301     ................
     700:	03010008 0002097f 09010301 03010009     ................
     710:	0003090a 09020301 03010003 00090978     ............x...
     720:	09010301 03010003 00050971 09010301     ........q.......
     730:	04010003 7fb8031b 01000809 f2031604     ................
     740:	000b0901 09020301 03010006 00100902     ................
     750:	09020301 03010003 00130901 09010301     ................
     760:	04010016 7eab031b 01000c09 d5031604     .......~........
     770:	00020901 031b0401 02097e87 16040100     .........~......
     780:	0901f903 04010003 7ea3031b 01000809     ...........~....
     790:	03090603 7c030100 01000609 03090603     .......|........
     7a0:	16040100 0901d903 03010009 00130901     ................
     7b0:	09010301 03010016 12097f9a 02030100     ................
     7c0:	01000509 03090203 05030100 01000609     ................
     7d0:	f3031b04 00120900 09030301 0301000b     ................
     7e0:	00080902 09010301 03010005 00050902     ................
     7f0:	09020301 0301000b 00050901 09030301     ................
     800:	03010008 00060903 031e0401 0d090192     ................
     810:	05030100 01001709 03097b03 22040100     .........{....."
     820:	0903b803 03010004 00030906 01b80301     ................
     830:	01002109 06090103 1e040100 097b9703     .!............{.
     840:	04010003 7eba031b 01000309 cc031e04     .......~........
     850:	00080901 031b0401 03097eb4 e3030100     .........~......
     860:	0003097e 00ca0301 01000509 0b090203     ~...............
     870:	01030100 01000509 097fb303 0301000b     ................
     880:	00030902 09010301 03010007 000b090f     ................
     890:	09030301 03010003 0003090a 097b0301     ..............{.
     8a0:	03010006 00030905 09020301 03010003     ................
     8b0:	00070902 09020301 03010009 00050970     ............p...
     8c0:	09160301 03010005 0006090e 09010301     ................
     8d0:	03010003 0003097f 09010301 04010003     ................
     8e0:	02af031e 01000209 03091303 03030100     ................
     8f0:	01001709 03097d03 11040100 097c9f03     .....}........|.
     900:	0301000b 00070902 03170401 04090885     ................
     910:	6d030100 01000309 05091403 6c030100     ...m...........l
     920:	01000309 03090103 03030100 01000309     ................
     930:	05096e03 01030100 01000209 03097f03     .n..............
     940:	03030100 01000309 03097e03 01030100     .........~......
     950:	01000309 03090403 01030100 01000309     ................
     960:	03097c03 03030100 01000309 03097e03     .|...........~..
     970:	12030100 01000309 03091103 5e030100     ...............^
     980:	01000309 03091103 01030100 01000309     ................
     990:	02097903 0b030100 01000209 03090c03     .y..............
     9a0:	74030100 01000309 03090c03 69030100     ...t...........i
     9b0:	01000209 03090903 0e030100 01000309     ................
     9c0:	05090103 5e030100 01000209 08091103     .......^........
     9d0:	01030100 01000309 03096f03 10030100     .........o......
     9e0:	01000509 05091103 01030100 01000209     ................
     9f0:	04097f03 70030100 01000309 03090103     .......p........
     a00:	0f030100 01000209 04096003 11030100     .........`......
     a10:	01000209 03096f03 12030100 01000309     .....o..........
     a20:	03096f03 11030100 01000209 03096f03     .o...........o..
     a30:	17030100 01000509 03097b03 05030100     .........{......
     a40:	01000509 03090e03 07030100 01000d09     ................
     a50:	92031004 00080978 09060301 03010031     ....x.......1...
     a60:	0002097a 03170401 090907ee 10040100     z...............
     a70:	09789203 03010003 00080902 09040301     ..x.............
     a80:	0301000c 0003097c 09040301 03010002     ....|...........
     a90:	000e0901 03170401 0c0907e9 10040100     ................
     aa0:	09789703 04010003 07e90317 01000209     ..x.............
     ab0:	ed031004 00030977 03170401 1109089a     ....w...........
     ac0:	02030100 01000609 d6031b04 00090977     ............w...
     ad0:	03100401 0010097f 031e0401 120903f3     ................
     ae0:	01030100 01000609 03090403 0a030100     ................
     af0:	01000309 03097603 02030100 01000909     .....v..........
     b00:	03090103 07030100 01000509 03090203     ................
     b10:	02030100 01000309 06090103 49030100     ...............I
     b20:	01000309 02097d03 c6030100 00030900     .....}..........
     b30:	097f0301 03010002 0002097f 09010301     ................
     b40:	03010005 00030901 095a0301 04010014     ..........Z.....
     b50:	7c980311 01000309 08090203 17040100     ...|............
     b60:	0908ed03 03010004 00030901 095d0301     ..............].
     b70:	03010003 0010090f 09780301 03010002     ..........x.....
     b80:	00060908 09710301 03010003 0002090f     ......q.........
     b90:	09710301 03010003 00030910 09030301     ..q.............
     ba0:	03010003 0003096d 09050301 03010003     ....m...........
     bb0:	0003097f 090f0301 03010003 0002096f     ............o...
     bc0:	09060301 03010003 0003097b 090e0301     ........{.......
     bd0:	03010003 00020917 095c0301 03010003     ..........\.....
     be0:	00030901 090c0301 03010003 00030906     ................
     bf0:	09110301 03010006 0003095e 09030301     ........^.......
     c00:	03010003 0002090f 096f0301 03010005     ..........o.....
     c10:	00030921 09790301 03010002 00060978     !.....y.....x...
     c20:	09100301 03010003 0002095f 09200301     ........_..... .
     c30:	03010003 00050974 096c0301 03010003     ....t.....l.....
     c40:	00020910 09710301 03010003 00030921     ......q.....!...
     c50:	09720301 03010004 0003096e 090e0301     ..r.....n.......
     c60:	03010002 00020911 09700301 03010008     ..........p.....
     c70:	00030901 09700301 03010002 00050910     ......p.........
     c80:	090f0301 03010003 00040971 09010301     ........q.......
     c90:	03010003 00030901 09130301 03010005     ................
     ca0:	000e0902 03100401 0509778c 17040100     .........w......
     cb0:	0908fb03 03010011 00060902 031b0401     ................
     cc0:	0b0976f5 10040100 10097f03 1b040100     .v..............
     cd0:	09018f03 03010012 00060937 09030301     ........7.......
     ce0:	03010003 0003090a 097b0301 03010006     ..........{.....
     cf0:	00030905 09020301 03010003 00070902     ................
     d00:	09020301 03010006 00050970 03220401     ........p.....".
     d10:	050906af 03030100 01000609 03090403     ................
     d20:	03030100 01000609 02097d03 03030100     .........}......
     d30:	01000609 b7030d04 00060978 03220401     ........x.....".
     d40:	030907d9 09030100 01000309 03090203     ................
     d50:	08030100 01000509 03090503 01030100     ................
     d60:	01000309 03090403 02030100 01001209     ................
     d70:	ae031b04 00030979 090e0301 03010006     ....y...........
     d80:	00060901 096b0301 04010008 05bb0322     ......k....."...
     d90:	01000609 03090203 11030100 01000309     ................
     da0:	09090203 22030100 01000809 03090203     ......."........
     db0:	17040100 097df303 04010003 029b0322     ......}....."...
     dc0:	01000309 e5031704 0006097d 03220401     ........}.....".
     dd0:	0809029b 03030100 01000609 03090203     ................
     de0:	01030100 01000309 03090203 02030100     ................
     df0:	01000609 097f9d03 03010017 00030901     ................
     e00:	09010301 03010003 00050901 092a0301     ..............*.
     e10:	0301000e 0002097f 09060301 03010006     ................
     e20:	00150906 09080301 03010012 0003092b     ............+...
     e30:	031e0401 07097ab3 12030100 01000009     .....z..........
     e40:	02096e03 14030100 01000509 0900fd03     .n..............
     e50:	03010002 05097f87 09030100 01000a09     ................
     e60:	02097703 02030100 01000309 05097e03     .w...........~..
     e70:	03030100 01000809 03090203 04030100     ................
     e80:	01000909 04090603 05030100 01000209     ................
     e90:	02097b03 7c030100 01000609 05097e03     .{.....|.....~..
     ea0:	07030100 01000509 03090103 7e030100     ...............~
     eb0:	01000309 02090503 03030100 01000209     ................
     ec0:	03097d03 03030100 01000509 05090403     .}..............
     ed0:	04030100 01000609 05090303 07030100     ................
     ee0:	01000509 02097903 0d030100 01000309     .....y..........
     ef0:	02097303 07030100 01000309 03091103     .s..............
     f00:	7d030100 01000309 03097203 0e030100     ...}.....r......
     f10:	01000209 03097b03 08030100 01000409     .....{..........
     f20:	02097803 08030100 01000309 03090403     .x..............
     f30:	74030100 01000209 02090803 75030100     ...t...........u
     f40:	01000809 02090f03 02030100 01000609     ................
     f50:	03097e03 02030100 01000309 03090903     .~..............
     f60:	01030100 01000309 07090803 10030100     ................
     f70:	01000609 03091603 01030100 01000309     ................
     f80:	a8031704 000c0903 09010301 03010005     ................
     f90:	0002097f 09010301 03010006 000f0901     ................
     fa0:	09010301 03010008 00080901 7f810301     ................
     fb0:	01001109 09018103 03010009 00060901     ................
     fc0:	09010301 0301000b 00080901 09020301     ................
     fd0:	04010015 01e70322 01000809 00090203     ...."...........
     fe0:	02030100 01000309 16090703 09030100     ................
     ff0:	01000609 02097d03 03030100 01000209     .....}..........
    1000:	86032604 00050978 09030301 0301000a     .&..x...........
    1010:	0003097d 09030301 0301000d 2909018c     }..............)
    1020:	03030100 01000509 03090703 04030100     ................
    1030:	01001109 097ef503 03010014 060900fe     ......~.........
    1040:	7f030100 01000209 ad032204 00030902     ........."......
    1050:	09010301 03010003 0003097f 09010301     ................
    1060:	03010003 00060902 09090301 03010003     ................
    1070:	00070902 09070301 0301000c 00050977     ............w...
    1080:	7ea80301 01000509 1e090103 a5030100     ...~............
    1090:	00180901 09020301 03010006 00020903     ................
    10a0:	09020301 03010003 00060901 092a0301     ..............*.
    10b0:	03010006 00040910 09010301 03010006     ................
    10c0:	00060905 09010301 04010006 7cb00326     ............&..|
    10d0:	01000309 74032504 01000309 06090103     .....%.t........
    10e0:	01030100 01001109 1b091e03 01030100     ................
    10f0:	01000809 06090103 22040100 0902fd03     ..........."....
    1100:	03010006 00060901 03260401 03097ce8     ..........&..|..
    1110:	17040100 0905b303 03010003 00110901     ................
    1120:	09010301 03010008 00060901 09010301     ................
    1130:	03010006 00060901 09010301 03010006     ................
    1140:	00060901 09010301 03010006 11097fb3     ................
    1150:	cf030100 00090900 09010301 03010006     ................
    1160:	00060901 03220401 12097eae 55030100     ......"..~.....U
    1170:	01000b09 06097403 97030100 0008097e     .....t......~...
    1180:	7ed20301 01000b09 05097d03 b3030100     ...~.....}......
    1190:	00030901 7ece0301 01000309 03090203     .......~........
    11a0:	02030100 01000509 03097e03 02030100     .........~......
    11b0:	01000209 04090403 02030100 01000309     ................
    11c0:	03097e03 02030100 01000609 09090303     .~..............
    11d0:	02030100 01000909 03097e03 02030100     .........~......
    11e0:	01000209 02090303 02030100 01000509     ................
    11f0:	09090403 cf030100 00060903 7dcb0301     ...............}
    1200:	01000309 0902b503 03010005 00030902     ................
    1210:	09010301 03010006 00030903 09010301     ................
    1220:	03010005 00090902 09010301 03010006     ................
    1230:	00030903 09030301 03010007 00050915     ................
    1240:	09760301 03010002 0002097a 091d0301     ..v.....z.......
    1250:	03010015 00020963 09010301 03010012     ....c...........
    1260:	00100901 09010301 03010013 00130901     ................
    1270:	09010301 03010010 00130901 09010301     ................
    1280:	0301000d 00130901 09010301 03010008     ................
    1290:	00130905 09010301 03010013 00100901     ................
    12a0:	09020301 0301000d 00130901 09050301     ................
    12b0:	0301000c 00060901 09010301 0301000d     ................
    12c0:	00060901 09010301 03010013 000e0916     ................
    12d0:	096a0301 03010002 00050901 09050301     ..j.............
    12e0:	0301000d 00080901 09010301 03010006     ................
    12f0:	00060905 09010301 03010010 00050905     ................
    1300:	03100401 0b097afa 02030100 01000e09     .....z..........
    1310:	0b090403 01030100 01000b09 05095603     .............V..
    1320:	22040100 0905ac03 04010008 7ac6031b     ..."...........z
    1330:	01000309 7f031004 01000809 c0032204     ............."..
    1340:	000c0905 09010301 03010014 00060901     ................
    1350:	09010301 03010008 00080901 09010301     ................
    1360:	03010008 00060901 03170401 00080909     ................
    1370:	03220401 0008097a 09020301 04010006     ..".z...........
    1380:	09750317 04010015 09100322 04010008     ..u.....".......
    1390:	03ca0317 01000909 d2032604 000f0977     .........&..w...
    13a0:	03220401 030901ed 01030100 01000609     ..".............
    13b0:	0900db03 0301000e 0005096c 09010301     ........l.......
    13c0:	04010006 7cdd0325 01000a09 06090103     ....%..|........
    13d0:	01030100 01000609 06090103 02030100     ................
    13e0:	01000309 06097e03 02030100 01000309     .....~..........
    13f0:	0e090203 01030100 01000609 09090103     ................
    1400:	01030100 01000909 09090303 01030100     ................
    1410:	01000609 0900ea03 04010003 02e40322     ............"...
    1420:	01000309 0c090103 1a030100 01002309     .............#..
    1430:	cb032504 0005097c 09010301 03010006     .%..|...........
    1440:	00060901 09010301 03010006 00030902     ................
    1450:	097e0301 03010009 00030902 09020301     ..~.............
    1460:	03010011 00060901 09040301 03010003     ................
    1470:	00030936 7f9d0301 01000309 06090103     6...............
    1480:	01030100 01000609 06090103 04030100     ................
    1490:	01000609 06090103 01030100 01000609     ................
    14a0:	06090103 04030100 01000309 18097c03     .............|..
    14b0:	04030100 01000309 0e090303 01030100     ................
    14c0:	01000609 0900c803 04010003 01e90322     ............"...
    14d0:	01000309 06090203 01030100 01000809     ................
    14e0:	21093403 02030100 01000809 05091c03     .4.!............
    14f0:	01030100 01000c09 23091d03 88030100     ...........#....
    1500:	0005097f 09010301 04010006 7df60325     ............%..}
    1510:	01001209 06090103 01030100 01000909     ................
    1520:	09090103 01030100 01000909 09090103     ................
    1530:	03030100 01000909 06090103 28030100     ...............(
    1540:	01000309 8f032204 00030902 097f0301     ....."..........
    1550:	03010003 00030902 097e0301 03010005     ..........~.....
    1560:	00030902 097e0301 03010003 00030901     ......~.........
    1570:	097f0301 03010003 00030901 09010301     ................
    1580:	03010003 00060901 00d10301 01000509     ................
    1590:	03090103 05030100 01000f09 05097603     .............v..
    15a0:	7b030100 01000909 12091203 9d030100     ...{............
    15b0:	0012097f 09020301 03010006 000b092c     ............,...
    15c0:	09050301 03010006 00080910 09010301     ................
    15d0:	03010008 0002097f 09010301 03010006     ................
    15e0:	03097f9f 02030100 01000609 0900d203     ................
    15f0:	0301000b 00030901 7fb80301 01000809     ................
    1600:	06090203 ca030100 00090900 09040301     ................
    1610:	0301000a 03097fa5 11030100 01000509     ................
    1620:	03090103 7f030100 01000509 03090103     ................
    1630:	7f030100 01000309 03090103 02030100     ................
    1640:	01000609 d4031e04 0008097e 09290301     ........~.....).
    1650:	03010003 00020963 091d0301 03010006     ....c...........
    1660:	00030963 09060301 03010003 0002091d     c...............
    1670:	097a0301 03010002 00050974 090c0301     ..z.....t.......
    1680:	03010009 00030906 03260401 000e0909     ..........&.....
    1690:	090c0301 03010010 0002097e 09050301     ........~.......
    16a0:	04010003 7eb2031e 01000a09 ce032604     .......~.....&..
    16b0:	00050901 031e0401 05097e93 01030100     .........~......
    16c0:	01000309 03090303 01030100 01000309     ................
    16d0:	03090103 0f040100 03097c03 26040100     .........|.....&
    16e0:	0901f203 03010005 0006097f 031e0401     ................
    16f0:	09097eae 7e030100 01000609 05090203     .~.....~........
    1700:	01030100 01000309 1a032204 01000609     ........."......
    1710:	03090203 02030100 01000309 03090103     ................
    1720:	01030100 01000309 03090103 01030100     ................
    1730:	01000309 03090603 7f030100 01000609     ................
    1740:	06090103 26040100 0903a203 03010003     .......&........
    1750:	00030901 09010301 03010003 00030978     ............x...
    1760:	090a0301 03010003 00030901 03140401     ................
    1770:	03097bee 16040100 03095903 14040100     .{.......Y......
    1780:	03092803 16040100 09095803 01030100     .(.......X......
    1790:	01000609 09090303 14040100 11091103     ................
    17a0:	01030100 01001209 0f090103 0f040100     ................
    17b0:	12091c03 26040100 09028f03 03010005     .......&........
    17c0:	00020901 097f0301 04010006 7df1030f     ...............}
    17d0:	01000209 74031304 01000609 0e030f04     .......t........
    17e0:	01000809 a3032604 00050902 090f0301     .....&..........
    17f0:	03010008 000b0963 09060301 03010008     ....c...........
    1800:	00030904 097c0301 04010003 7dec030f     ......|........}
    1810:	01000509 00090103 02030100 01000809     ................
    1820:	04097e03 06030100 01000309 02090203     .~..............
    1830:	26040100 07096f03 01030100 01000709     ...&.o..........
    1840:	0c090303 02030100 01000509 0a090303     ................
    1850:	02030100 01000309 03090303 7e030100     ...............~
    1860:	01000309 11090203 02030100 01000309     ................
    1870:	e9031704 00060908 03260401 0309779a     ..........&..w..
    1880:	17040100 0908e603 04010003 779c0326     ............&..w
    1890:	01001a09 05090303 02030100 01000509     ................
    18a0:	06090103 06030100 01000609 05090103     ................
    18b0:	01030100 01000709 03090303 03030100     ................
    18c0:	01000509 06090203 7e030100 01000309     ...........~....
    18d0:	03090203 09030100 01000d09 03090303     ................
    18e0:	02030100 01000609 0b090203 47030100     ...............G
    18f0:	01000509 03093d03 0e040100 0900de03     .....=..........
    1900:	0401000c 7eb5030f 01000009 cb030e04     .......~........
    1910:	00090901 030f0401 0b097eb3 06030100     .........~......
    1920:	01000309 02097e03 02030100 01000609     .....~..........
    1930:	03097c03 06030100 01000809 02097e03     .|...........~..
    1940:	02030100 01000209 06097e03 7c030100     .........~.....|
    1950:	01000709 fe030e04 00030900 030f0401     ................
    1960:	02097f99 0e040100 03091403 7f030100     ................
    1970:	01000309 03097f03 01030100 01000509     ................
    1980:	02090103 0f040100 02096c03 06030100     .........l......
    1990:	01000309 04031304 01000609 13030e04     ................
    19a0:	01000809 08090203 a6030100 00050901     ................
    19b0:	093b0301 0301000c 00030902 09010301     ..;.............
    19c0:	0301000c 0006094d 030d0401 05097ec6     ....M........~..
    19d0:	0e040100 0901c503 04010003 7ed4030d     ...............~
    19e0:	01000809 ad030e04 00030901 09060301     ................
    19f0:	03010003 00030903 090e0301 04010006     ................
    1a00:	02960326 01000309 ec030e04 0003097d     &...........}...
    1a10:	030b0401 0609038c 02030100 01000309     ................
    1a20:	03090203 03030100 01000f09 08097d03     .............}..
    1a30:	05030100 01000709 05090203 01030100     ................
    1a40:	01000509 02096903 07030100 01000309     .....i..........
    1a50:	02097b03 05030100 01000309 05097e03     .{...........~..
    1a60:	7f030100 01000209 06090103 03030100     ................
    1a70:	01000309 04097303 01030100 01000009     .....s..........
    1a80:	08090103 69030100 01000409 00090103     .......i........
    1a90:	7f030100 01000309 05090103 01030100     ................
    1aa0:	01000309 08090103 01030100 01000809     ................
    1ab0:	05090103 7f030100 01000509 03090103     ................
    1ac0:	5c030100 01000409 00090303 7d030100     ...\...........}
    1ad0:	01000309 0c090203 01030100 01000309     ................
    1ae0:	03090203 08030100 01000309 04097a03     .............z..
    1af0:	04030100 01000309 04097c03 02030100     .........|......
    1b00:	01000609 03097e03 02030100 01000209     .....~..........
    1b10:	02097e03 02030100 01000309 02097e03     .~...........~..
    1b20:	04030100 01000309 03090303 7f030100     ................
    1b30:	01000209 03090103 53030100 01000c09     ...........S....
    1b40:	00090303 7d030100 01000309 0c090203     .......}........
    1b50:	01030100 01000309 03090103 08030100     ................
    1b60:	01000309 04097a03 02030100 01000809     .....z..........
    1b70:	07097e03 04030100 01000209 05090303     .~..............
    1b80:	7f030100 01000209 03090103 59030100     ...............Y
    1b90:	01000909 00090103 7f030100 01000309     ................
    1ba0:	05090103 01030100 01000309 08090203     ................
    1bb0:	01030100 01000409 03097f03 01030100     ................
    1bc0:	01000309 06090203 01030100 01000509     ................
    1bd0:	08095a03 01030100 01000009 03097f03     .Z..............
    1be0:	01030100 01000509 03090203 07030100     ................
    1bf0:	01000609 03097903 02030100 01000309     .....y..........
    1c00:	09090103 06030100 01000509 07097e03     .............~..
    1c10:	93030100 000c097f 09040301 0301000c     ................
    1c20:	0003097c 09040301 03010002 00180922     |..........."...
    1c30:	09030301 03010006 0005097f 09010301     ................
    1c40:	03010003 00060910 09130301 03010003     ................
    1c50:	00030904 09020301 03010005 0005097e     ............~...
    1c60:	09020301 03010003 0002095b 09050301     ........[.......
    1c70:	03010006 00080904 097e0301 03010003     ..........~.....
    1c80:	00030901 09010301 03010005 00060951     ............Q...
    1c90:	09030301 03010006 0005097f 09010301     ................
    1ca0:	03010003 00060904 090a0301 03010006     ................
    1cb0:	00060904 097f0301 03010003 0004097f     ................
    1cc0:	09010301 03010003 00030901 09050301     ................
    1cd0:	03010006 0006091a 09010301 03010006     ................
    1ce0:	11097ccd b5030100 00060903 7ccb0301     .|.............|
    1cf0:	01000309 11090103 b5030100 00100903     ................
    1d00:	09010301 03010008 00090901 09010301     ................
    1d10:	03010006 00060901 09500301 0301000b     ..........P.....
    1d20:	00030901 09010301 03010006 00040950     ............P...
    1d30:	09030301 03010000 0003097d 09030301     ........}.......
    1d40:	03010005 03097eeb 02030100 01000f09     .....~..........
    1d50:	06097e03 02030100 01000309 09019503     .~..............
    1d60:	03010003 0003097f 09010301 03010005     ................
    1d70:	00060902 097e0301 03010009 00020906     ......~.........
    1d80:	097f0301 03010002 00050901 09410301     ..............A.
    1d90:	03010006 000a0902 090f0301 03010003     ................
    1da0:	00030971 7fb80301 01000309 0b090203     q...............
    1db0:	7e030100 01000609 03090203 c8030100     ...~............
    1dc0:	00060900 09070301 03010007 00060901     ................
    1dd0:	09050301 03010005 00060910 09700301     ..............p.
    1de0:	03010002 00030902 09010301 03010006     ................
    1df0:	00030907 097b0301 03010005 00060901     ......{.........
    1e00:	097f0301 03010002 00060901 096f0301     ..............o.
    1e10:	03010006 00060901 091a0301 03010008     ................
    1e20:	00030903 09770301 03010009 00140902     ......w.........
    1e30:	09480301 03010012 00000901 097f0301     ..H.............
    1e40:	03010005 00050901 09020301 03010003     ................
    1e50:	0002097f 09010301 03010008 00030901     ................
    1e60:	09690301 0301000a 00000902 097e0301     ..i...........~.
    1e70:	03010002 00030901 09010301 03010005     ................
    1e80:	00030901 030a0401 03097ee8 01030100     .........~......
    1e90:	01000509 1d090303 02030100 01001209     ................
    1ea0:	08096603 01030100 01000509 1e090303     .f..............
    1eb0:	02030100 01001809 09096303 01030100     .........c......
    1ec0:	01000809 0c090303 01030100 01001709     ................
    1ed0:	0e090103 7f030100 01000309 02090103     ................
    1ee0:	02030100 01000309 07096203 01030100     .........b......
    1ef0:	01000809 0a090303 01030100 01001b09     ................
    1f00:	16090103 02030100 01000809 b9030804     ................
    1f10:	00090901 09020301 03010000 00100902     ................
    1f20:	09060301 03010008 0002097a 09060301     ........z.......
    1f30:	03010003 00030978 09080301 03010002     ....x...........
    1f40:	00060978 090b0301 04010003 05b20306     x...............
    1f50:	01000509 00090103 7f030100 01000309     ................
    1f60:	0c090103 7f030100 01000309 03090103     ................
    1f70:	0b030100 01000909 03097503 03030100     .........u......
    1f80:	01000309 06090103 01030100 01000c09     ................
    1f90:	0c090103 01030100 01000909 09090103     ................
    1fa0:	01030100 01000909 02097c03 06030100     .........|......
    1fb0:	01000309 06090103 01030100 01000909     ................
    1fc0:	09090103 07040100 0979c503 0301000e     ..........y.....
    1fd0:	00050901 09020301 03010006 00030901     ................
    1fe0:	097f0301 03010002 00030905 7f920301     ................
    1ff0:	01001109 03093003 02030100 01000509     .....0..........
    2000:	03097e03 08030100 01000209 02097803     .~...........x..
    2010:	02030100 01000309 15090503 4e030100     ...............N
    2020:	01000609 0900cb03 03010002 1a097fb5     ................
    2030:	06040100 0907aa03 03010003 000f0903     ................
    2040:	09010301 03010005 00050902 097e0301     ..............~.
    2050:	03010005 00020902 09010301 03010018     ................
    2060:	09097deb f3030100 0003097d 04a80301     .}......}.......
    2070:	01000209 03090503 7b030100 01000309     ...........{....
    2080:	097de503 03010004 0309029a e6030100     ..}.............
    2090:	0003097d 029a0301 01000309 04090103     }...............
    20a0:	7f030100 01000309 097bd903 03010005     ..........{.....
    20b0:	00050902 097e0301 03010002 020904ad     ......~.........
    20c0:	04030100 01000d09 10090203 01030100     ................
    20d0:	01000609 09090103 01030100 01000609     ................
    20e0:	12090103 05030100 01000609 10090103     ................
    20f0:	02040100 09789203 04010008 07ef0306     ......x.........
    2100:	01000409 05090103 01030100 01000d09     ................
    2110:	85030d04 0016097a 03060401 030905fd     ....z...........
    2120:	07040100 0979bd03 03010010 00170901     ......y.........
    2130:	09010301 04010011 00c4030d 01001409     ................
    2140:	82030604 00030906 09010301 04010008     ................
    2150:	79fd030d 01000d09 86030604 00030906     ...y............
    2160:	09020301 0301000a 00090901 097d0301     ..............}.
    2170:	03010002 00030908 097f0301 03010002     ................
    2180:	00090901 03040401 13097990 0d040100     .........y......
    2190:	097ee903 03010000 00030918 03040401     ..~.............
    21a0:	080901a4 02030100 01000309 15090203     ................
    21b0:	02030100 01000309 15090203 02030100     ................
    21c0:	01000309 9f030d04 0012097f 09020301     ................
    21d0:	03010003 0006094a 03040401 030900ee     ....J...........
    21e0:	0b040100 09048103 03010004 000f0903     ................
    21f0:	09010301 0301000c 00060902 03050401     ................
    2200:	0b097b97 02030100 01000b09 03097e03     .{...........~..
    2210:	02030100 01000309 06096b03 6e030100     .........k.....n
    2220:	01001309 08090103 01030100 01000809     ................
    2230:	15090103 01030100 01001009 03090103     ................
    2240:	7f030100 01000609 02090103 05030100     ................
    2250:	01000309 07090103 01030100 01001209     ................
    2260:	05090103 62030100 01001909 12090203     .......b........
    2270:	01030100 01000f09 0f090203 01030100     ................
    2280:	01000f09 11090203 01030100 01000f09     ................
    2290:	0f090203 2f030100 01001209 06090203     ......./........
    22a0:	03030100 01000c09 06090103 02030100     ................
    22b0:	01000609 03090203 04030100 01000909     ................
    22c0:	06090303 7f030100 01000209 06090403     ................
    22d0:	02030100 01000809 097efe03 03010007     ..........~.....
    22e0:	000a0901 090e0301 0301000e 00080901     ................
    22f0:	097a0301 03010005 000f0901 097a0301     ..z...........z.
    2300:	03010003 000f0912 00ef0301 01000f09     ................
    2310:	03090103 04040100 05091e03 01030100     ................
    2320:	01000009 f7031704 00040904 09010301     ................
    2330:	03010000 00060906 097a0301 03010002     ..........z.....
    2340:	00030902 097e0301 03010002 00030906     ......~.........
    2350:	7acb0301 01000409 00090003 05030100     ...z............
    2360:	01001109 0f090103 06030100 01001209     ................
    2370:	0c090303 04030100 01000f09 0b090803     ................
    2380:	05030100 01000809 12090c03 09030100     ................
    2390:	01001209 12090a03 03030100 01001209     ................
    23a0:	12090203 80030100 00020905 09010301     ................
    23b0:	03010000 0002097f 09010301 0301000f     ................
    23c0:	000f0901 09010301 03010008 00060901     ................
    23d0:	09010301 03010006 00060901 09010301     ................
    23e0:	03010006 00060901 09010301 03010006     ................
    23f0:	00120945 093d0301 03010009 00060901     E.....=.........
    2400:	09010301 0301000b 00150901 7dd70301     ...............}
    2410:	01000709 00090203 7e030100 01000609     ...........~....
    2420:	05090403 04030100 01001209 11090303     ................
    2430:	02030100 01000309 02097e03 02030100     .........~......
    2440:	01000309 0f090303 aa030100 0003097f     ................
    2450:	09030301 03010000 00060906 097a0301     ..............z.
    2460:	03010003 00030906 09010301 03010003     ................
    2470:	0003097f 09010301 03010005 00050901     ................
    2480:	09020301 03010002 0002090e 09060301     ................
    2490:	03010003 00060902 097e0301 03010003     ..........~.....
    24a0:	00020907 09010301 03010009 00060901     ................
    24b0:	09010301 03010009 0003097f 09010301     ................
    24c0:	03010003 0003097f 09010301 03010003     ................
    24d0:	0003097f 09010301 03010002 00120978     ............x...
    24e0:	090b0301 03010006 00140902 09010301     ................
    24f0:	03010002 00020901 09020301 04010002     ................
    2500:	7d8d0304 01000309 dc031804 00130900     ...}............
    2510:	09120301 03010006 00030902 09080301     ................
    2520:	03010011 000b0902 7e990301 01000909     ...........~....
    2530:	b8031704 00030904 03180401 05097daf     .............}..
    2540:	17040100 0902ad03 03010005 00060924     ............$...
    2550:	09010301 03010003 00030901 09020301     ................
    2560:	03010003 00210919 097f0301 03010003     ......!.........
    2570:	00030902 09010301 03010003 00050901     ................
    2580:	09640301 03010003 1c0900c9 7d030100     ..d............}
    2590:	01000209 03090203 7f030100 01000309     ................
    25a0:	05090203 01030100 01000309 09092103     .............!..
    25b0:	01030100 01000309 05090103 04030100     ................
    25c0:	01000509 d7031804 0005097a 031e0401     ........z.......
    25d0:	0b0901a1 1c030100 01001809 03097e03     .............~..
    25e0:	18040100 06093303 03030100 01000909     .....3..........
    25f0:	09090403 ad030100 0003097e 09020301     ........~.......
    2600:	03010003 060901d2 02030100 01000609     ................
    2610:	097ec003 03010003 00060902 09010301     ..~.............
    2620:	03010008 030901c2 c9030100 0003097e     ............~...
    2630:	09020301 03010003 00090902 01b50301     ................
    2640:	01000609 03090303 9b030100 0003097f     ................
    2650:	09100301 03010006 00020970 09070301     ........p.......
    2660:	03010003 00060909 09020301 03010018     ................
    2670:	0002097e 09020301 03010003 0c0900d9     ~...............
    2680:	04030100 01000809 097ed503 03010003     ..........~.....
    2690:	00030901 09010301 04010003 090a0304     ................
    26a0:	04010006 03cb0317 01000f09 14092003     ............. ..
    26b0:	7f030100 01000309 03090203 01030100     ................
    26c0:	01000309 05090103 5d030100 01000309     ...........]....
    26d0:	11090a03 02030100 01000309 03097f03     ................
    26e0:	cb030100 0003097e 09060301 03010006     ....~...........
    26f0:	00090901 09010301 0301000b 030901b0     ................
    2700:	2b030100 01000909 02097d03 02030100     ...+.....}......
    2710:	01000309 03097f03 02030100 01000509     ................
    2720:	03090103 49030100 01000909 03090203     .......I........
    2730:	7f030100 01000309 097ed203 03010003     ..........~.....
    2740:	00060906 01a40301 01000909 09091403     ................
    2750:	7e030100 01000209 03097f03 02030100     ...~............
    2760:	01000309 03090103 01030100 01000309     ................
    2770:	09091203 7f030100 01000309 03090203     ................
    2780:	01030100 01000309 05090103 17030100     ................
    2790:	01000309 02097d03 02030100 01000309     .....}..........
    27a0:	03097f03 02030100 01000509 03090103     ................
    27b0:	be030100 0003097f 09310301 03010009     ..........1.....
    27c0:	0002097d 09020301 03010003 0003097f     }...............
    27d0:	09020301 03010005 00030901 03040401     ................
    27e0:	04097bf0 01030100 01000009 04094603     .{...........F..
    27f0:	0d040100 09019b03 04010000 7eea0304     ...............~
    2800:	01000309 b4030d04 00030901 09000301     ................
    2810:	04010003 7eda0304 01000a09 44030504     .......~.......D
    2820:	01000209 08090203 01030100 01000509     ................
    2830:	39030404 01000809 ee030d04 00020900     ...9............
    2840:	03040401 03097fa6 02030100 01000309     ................
    2850:	a9030504 0008097f 09030301 03010005     ................
    2860:	0003097d 09020301 03010003 00080901     }...............
    2870:	03040401 000f093e 03010401 040900ee     ....>...........
    2880:	01030100 01000009 03097f03 01030100     ................
    2890:	01000509 03090103 06040100 0903db03     ................
    28a0:	03010009 00000901 09190301 03010014     ................
    28b0:	00130901 7e850301 01000909 08090203     .......~........
    28c0:	7f030100 01000209 09028003 03010005     ................
    28d0:	06097e87 fc030100 00200901 097d0301     .~........ ...}.
    28e0:	03010002 00030907 00fb0301 01000a09     ................
    28f0:	10090803 78030100 01000309 03090403     .......x........
    2900:	7f030100 01000309 02090703 7a030100     ...............z
    2910:	01000209 03097f03 7d030100 01000309     ...........}....
    2920:	03090803 7c030100 01000309 03090403     .......|........
    2930:	7c030100 01000309 03090403 7c030100     ...|...........|
    2940:	01000909 0c090603 01030100 01000c09     ................
    2950:	02097f03 01030100 01000309 03090103     ................
    2960:	b0030100 0009097f 09020301 03010003     ................
    2970:	0003097e 09020301 03010005 00040970     ~...........p...
    2980:	09140301 03010008 0002096c 09120301     ........l.......
    2990:	03010003 0002096e 09120301 03010003     ....n...........
    29a0:	00080902 09050301 0301000d 00050902     ................
    29b0:	09020301 0301000a 0009097e 090e0301     ........~.......
    29c0:	03010008 00160902 097e0301 03010009     ..........~.....
    29d0:	00040905 096d0301 03010007 00020905     ......m.........
    29e0:	09020301 0301000a 0009097e 00cf0301     ........~.......
    29f0:	01000709 00090103 02030100 01000809     ................
    2a00:	03097e03 06030100 01000309 06096d03     .~...........m..
    2a10:	01030100 01000009 0b090203 04030100     ................
    2a20:	01000309 06093703 04030100 01000f09     .....7..........
    2a30:	05090103 02030100 01001209 14090503     ................
    2a40:	03030100 01000309 02090203 7e030100     ...............~
    2a50:	01000209 08090103 01030100 01000509     ................
    2a60:	10090103 7f030100 01000209 097ec003     ..............~.
    2a70:	03010003 0a097df3 8d030100 00020902     .....}..........
    2a80:	7df30301 01000309 0c090203 7e030100     ...}...........~
    2a90:	01000209 0903d203 03010002 00090902     ................
    2aa0:	09060301 03010008 00020903 09790301     ..............y.
    2ab0:	03010002 00030907 030d0401 03097ae8     .............z..
    2ac0:	06040100 09059b03 03010003 00070901     ................
    2ad0:	09020301 0301000d 00090905 09060301     ................
    2ae0:	03010008 00030902 097e0301 03010002     ..........~.....
    2af0:	0002097c 09040301 03010003 000e0901     |...............
    2b00:	09010301 0301000b 00120901 09060301     ................
    2b10:	04010011 79d40301 01001109 0e090203     .......y........
    2b20:	7e030100 01000309 02090203 02030100     ...~............
    2b30:	01001009 f1030604 000a0905 09010301     ................
    2b40:	03010007 000d0902 09050301 03010009     ................
    2b50:	000b0903 09020301 03010002 0002097e     ............~...
    2b60:	09010301 03010008 00050901 7ec00301     ...............~
    2b70:	01001309 097df303 0301000a 0209028d     ......}.........
    2b80:	f3030100 0003097d 09020301 0301000c     ....}...........
    2b90:	0002097e 03d20301 01000209 07090203     ~...............
    2ba0:	02030100 01000a09 06090403 03030100     ................
    2bb0:	01000509 e8030d04 0005097a 03060401     ........z.......
    2bc0:	0309059b 01030100 01000709 0f090203     ................
    2bd0:	05030100 01000909 0b090603 02030100     ................
    2be0:	01000209 02097e03 01030100 01000e09     .....~..........
    2bf0:	0b090103 01030100 01001209 dc030104     ................
    2c00:	000e0979 09050301 0401000f 00f7030c     y...............
    2c10:	01001209 07090203 7e030100 01000309     ...........~....
    2c20:	02090203 02030100 01000309 06090203     ................
    2c30:	01030100 01000309 02097f03 01030100     ................
    2c40:	01000309 0908b703 03010007 000977e1     .............w..
    2c50:	3c030100 01000309 03094403 3c030100     ...<.....D.....<
    2c60:	01000309 0907eb03 03010003 000c0901     ................
    2c70:	09020301 03010003 00090905 78a40301     ...............x
    2c80:	01000c09 07090303 7d030100 01000309     ...........}....
    2c90:	02090303 02030100 01000309 06090603     ................
    2ca0:	7e030100 01000309 03090403 7e030100     ...~...........~
    2cb0:	01000209 06090203 7e030100 01000209     ...........~....
    2cc0:	03090203 b7030100 0008097f 09030301     ................
    2cd0:	03010007 0003097d 09030301 03010002     ....}...........
    2ce0:	00030902 09060301 03010006 0003097e     ............~...
    2cf0:	09040301 03010003 0002097e 09020301     ........~.......
    2d00:	03010006 0002097e 09020301 03010003     ....~...........
    2d10:	080900cf cf030100 0003097d 02b40301     ........}.......
    2d20:	01000309 097dcc03 03010002 030902b4     ......}.........
    2d30:	01030100 01000209 0900f703 0301000b     ................
    2d40:	00000909 09770301 03010002 03097cd4     ......w......|..
    2d50:	b1030100 00030903 7ccf0301 01000209     ...........|....
    2d60:	0903b103 03010003 00020904 04980301     ................
    2d70:	01001109 05090303 02030100 01000509     ................
    2d80:	09788203 03010005 030907fe 01030100     ..x.............
    2d90:	01000209 09789703 03010007 030907e9     ......x.........
    2da0:	81030100 00020978 08820301 01000309     ....x...........
    2db0:	09789403 03010002 0a0907e6 0c030100     ..x.............
    2dc0:	01000309 06090103 f3030100 000c0902     ................
    2dd0:	75840301 01000009 090afc03 03010003     ...u............
    2de0:	030976ba cb030100 00030909 76b50301     .v.............v
    2df0:	01000209 097eca03 03010003 03090b81     ......~.........
    2e00:	02030100 01000209 0974fd03 03010002     ..........t.....
    2e10:	02090b83 05030100 01000509 07090203     ................
    2e20:	08030100 01000509 05097c03 9e030100     .........|......
    2e30:	0007097f 75d40301 01000e09 090ab303     .......u........
    2e40:	03010003 00040901 75cc0301 01000209     ...........u....
    2e50:	090ab403 03010005 00060929 09040301     ........).......
    2e60:	03010003 00030902 09040301 0301000d     ................
    2e70:	020975af d2030100 0006090a 097f0301     .u..............
    2e80:	03010004 00030901 09510301 03010007     ..........Q.....
    2e90:	0003097f 09010301 03010003 00030902     ................
    2ea0:	09010301 03010006 00080912 09010301     ................
    2eb0:	03010003 00050902 097e0301 0301000c     ..........~.....
    2ec0:	00020902 09020301 03010006 00060901     ................
    2ed0:	09040301 03010005 000c0901 096a0301     ..............j.
    2ee0:	03010003 00030901 097f0301 03010003     ................
    2ef0:	00030901 09020301 03010003 00060901     ................
    2f00:	7bff0301 01000609 00090403 7c030100     ...{...........|
    2f10:	01000309 06090203 b8030100 00020979     ............y...
    2f20:	06c80301 01000309 02090203 02030100     ................
    2f30:	01000b09 03091403 6c030100 01000309     ...........l....
    2f40:	0979ca03 03010003 030906ca 6c030100     ..y............l
    2f50:	01000209 03090203 02030100 01000b09     ................
    2f60:	03090203 02030100 01000309 06090203     ................
    2f70:	02030100 01000309 09028e03 0301000e     ................
    2f80:	00097984 3c030100 01000609 0906c103     .y.....<........
    2f90:	03010003 030979bf c1030100 00030906     .....y..........
    2fa0:	09010301 03010003 00060902 7fb80301     ................
    2fb0:	01000409 0f090403 7c030100 01000209     ...........|....
    2fc0:	02090403 03030100 01000b09 06090103     ................
    2fd0:	03030100 01000309 06090103 02030100     ................
    2fe0:	01000309 09090503 02030100 01000b09     ................
    2ff0:	06090103 03030100 01000309 03091603     ................
    3000:	6c030100 01000409 05090103 04030100     ...l............
    3010:	01000809 0979a803 03010006 0003093c     ......y.....<...
    3020:	09440301 03010003 0003093c 06a50301     ..D.....<.......
    3030:	01000309 0c090203 01030100 01000309     ................
    3040:	06090303 a2030100 000c097e 78f50301     ........~......x
    3050:	01000009 09078b03 03010003 090978f5     .............x..
    3060:	8b030100 00030907 09040301 03010002     ................
    3070:	00040902 09020301 03010007 00030903     ................
    3080:	09010301 0301000f 00050902 09020301     ................
    3090:	03010009 00030901 090d0301 03010006     ................
    30a0:	00020976 09080301 03010002 0002097c     v...........|...
    30b0:	097e0301 03010002 00040902 09060301     ..~.............
    30c0:	03010003 0c0906c0 04030100 01000009     ................
    30d0:	03097c03 04030100 01000309 0f090703     .|..............
    30e0:	11040100 09728003 03010003 00000903     ......r.........
    30f0:	09020301 03010005 00040902 03080401     ................
    3100:	030902cd 00030100 01000009 12090403     ................
    3110:	01030100 01000809 05090103 7f030100     ................
    3120:	01000609 03090103 06040100 0900e303     ................
    3130:	0301000c 00000901 097f0301 03010002     ................
    3140:	000a0902 097f0301 03010002 00030901     ................
    3150:	09030301 03010003 00070902 09010301     ................
    3160:	03010006 00200901 09010301 03010011     ...... .........
    3170:	00090904 09010301 03010012 00080902     ................
    3180:	09010301 03010014 000b0901 09010301     ................
    3190:	0301000b 000b0901 09010301 0301000b     ................
    31a0:	000b0901 09010301 0301000b 000b0902     ................
    31b0:	09010301 0301000c 000e0901 09010301     ................
    31c0:	0301000e 000e0901 09010301 0301000e     ................
    31d0:	000e0901 09010301 03010010 00110901     ................
    31e0:	09020301 03010009 00090965 09010301     ........e.......
    31f0:	03010009 140902ff 02030100 01000b09     ................
    3200:	05090103 02030100 01001209 097ee803     ..............~.
    3210:	03010009 03097df3 8d030100 00040902     .....}..........
    3220:	7df30301 01000309 09028d03 03010002     ...}............
    3230:	03097df3 02030100 01000a09 02097e03     .}...........~..
    3240:	0d040100 097ec503 04010002 04e90306     ......~.........
    3250:	01000309 07090103 01030100 01000909     ................
    3260:	94030704 00110979 030d0401 00000908     ....y...........
    3270:	03070401 00060979 09010301 03010002     ....y...........
    3280:	00030903 090e0301 03010008 00020977     ............w...
    3290:	09060301 03010003 00080903 09790301     ..............y.
    32a0:	03010002 00080907 03060401 020904a1     ................
    32b0:	03030100 01000009 08097d03 03030100     .........}......
    32c0:	01000309 0d090203 01030100 01000909     ................
    32d0:	06097d03 03030100 01000409 03097d03     .}...........}..
    32e0:	06030100 01000409 07090203 7e030100     ...............~
    32f0:	01000909 04090403 54030100 01000209     ...........T....
    3300:	00090703 05030100 01000809 0d097d03     .............}..
    3310:	7e030100 01000c09 05090503 02030100     ...~............
    3320:	01000709 06090303 7d030100 01000309     ...........}....
    3330:	03090203 01030100 01000709 05097b03     .............{..
    3340:	08030100 01000509 d6030e04 0002097b     ............{...
    3350:	09030301 03010003 00110904 09010301     ................
    3360:	04010008 01c20303 01000409 00090503     ................
    3370:	02030100 01001009 05090503 7d030100     ...............}
    3380:	01000409 02090303 a4030100 0005097f     ................
    3390:	09010301 03010000 00030904 097c0301     ..............|.
    33a0:	03010003 00030902 091b0301 03010002     ................
    33b0:	00020967 09020301 03010003 00020901     g...............
    33c0:	09160301 03010005 0004096c 09050301     ........l.......
    33d0:	03010003 0003097b 09020301 03010003     ....{...........
    33e0:	00020901 09020301 03010005 00030902     ................
    33f0:	09010301 03010002 00050904 09010301     ................
    3400:	03010002 050901c7 0d040100 097db103     ..............}.
    3410:	04010011 01ed0303 01000509 11091903     ................
    3420:	02030100 01000209 09097e03 67030100     .........~.....g
    3430:	01000e09 0900eb03 03010003 00090907     ................
    3440:	09030301 03010018 00030903 097d0301     ..............}.
    3450:	03010003 00030903 09020301 03010011     ................
    3460:	00120901 09010301 03010008 00120901     ................
    3470:	7ebc0301 01000809 05090203 01030100     ...~............
    3480:	01000609 0901c203 04010003 7d95030d     ...............}
    3490:	01001409 25030304 01000309 0f090f03     .......%........
    34a0:	01030100 01000609 03090103 a4030100     ................
    34b0:	00030902 097e0301 03010002 03097dd0     ......~......}..
    34c0:	17030100 01000209 0902af03 03010014     ................
    34d0:	18097fbf 02030100 01000309 02097e03     .............~..
    34e0:	02030100 01000309 02097e03 02030100     .........~......
    34f0:	01000309 0900c503 03010006 00030904     ................
    3500:	7db80301 01000f09 02090103 bf030100     ...}............
    3510:	00030901 09020301 03010002 000b097e     ............~...
    3520:	090b0301 0301000b 00020902 097e0301     ..............~.
    3530:	0301000b 0e097eb1 01030100 01000209     .....~..........
    3540:	fd030d04 00040902 09040301 03010003     ................
    3550:	0002097d 09070301 04010005 7ce5030a     }..............|
    3560:	01000209 03090103 7f030100 01000309     ................
    3570:	02090103 01030100 01000809 10090103     ................
    3580:	01030100 01001009 10090103 01030100     ................
    3590:	01001309 10090403 01030100 01001309     ................
    35a0:	10090103 aa030100 00020902 03020401     ................
    35b0:	00097db4 0a040100 0902ce03 03010002     .}..............
    35c0:	0003097f 09010301 03010003 0003097f     ................
    35d0:	03020401 02097db3 0a040100 0902cd03     .....}..........
    35e0:	04010002 7db50302 01000509 cc030a04     .......}........
    35f0:	00040902 09010301 03010010 000e0901     ................
    3600:	097f0301 03010003 00020901 09010301     ................
    3610:	04010003 7ec2030b 01000209 0f090103     .......~........
    3620:	06030100 01001509 02090103 7f030100     ................
    3630:	01000309 03090103 01030100 01001409     ................
    3640:	03090103 71030100 01000209 06091003     .......q........
    3650:	02030100 01000309 1c091a03 04030100     ................
    3660:	01000609 06095d03 2b030100 01000609     .....].....+....
    3670:	05096303 b3030100 001a097f 09010301     .c..............
    3680:	03010002 0002097f 09010301 03010008     ................
    3690:	0006090b 09790301 03010002 00030904     ......y.........
    36a0:	097e0301 03010003 000a0902 09030301     ..~.............
    36b0:	03010006 00030904 09030301 03010007     ................
    36c0:	0002097f 09010301 03010003 0003097f     ................
    36d0:	09010301 03010005 00030979 090c0301     ........y.......
    36e0:	03010008 000e0937 09020301 03010006     ....7...........
    36f0:	0009097e 09770301 0301000b 00160901     ~.....w.........
    3700:	09020301 03010006 0006097e 090e0301     ........~.......
    3710:	0301000d 000e094f 09310301 03010002     ....O.....1.....
    3720:	00030955 097a0301 03010003 00030931     U.....z.....1...
    3730:	09520301 03010009 0006097d 09030301     ..R.....}.......
    3740:	03010003 000d0903 092d0301 03010003     ..........-.....
    3750:	00030953 092d0301 03010003 00030901     S.....-.........
    3760:	097f0301 04010009 7eee0311 01000f09     ...........~....
    3770:	03090503 02030100 01000809 81030a04     ................
    3780:	00030903 03030401 0015096f 09090301     ........o.......
    3790:	03010006 000c0905 09010301 03010002     ................
    37a0:	0002097e 09730301 03010003 0003097e     ~.....s.....~...
    37b0:	030a0401 00030915 03010401 10097e8c     .............~..
    37c0:	03030100 01000e09 03097d03 03030100     .........}......
    37d0:	01000209 0f090203 02030100 01000c09     ................
    37e0:	06090103 7f030100 01000209 03090103     ................
    37f0:	01030100 01000909 02097c03 0b030100     .........|......
    3800:	01000e09 03097303 16030100 01001709     .....s..........
    3810:	0f097203 01030100 01001509 03090603     .r..............
    3820:	01030100 01000609 03097f03 08040100     ................
    3830:	03090d03 01040100 03097303 08040100     .........s......
    3840:	03090d03 01040100 02097403 08040100     .........t......
    3850:	02090c03 02030100 01000309 16090203     ................
    3860:	02030100 01000b09 18090403 01040100     ................
    3870:	15096c03 01030100 01000909 05094503     .l...........E..
    3880:	08040100 097ef903 04010000 01870301     ......~.........
    3890:	01000209 84030804 000b097f 03010401     ................
    38a0:	030900fc 08040100 097f8403 03010003     ................
    38b0:	000f0907 09010301 03010012 00090902     ................
    38c0:	09590301 03010005 00060901 09020301     ..Y.............
    38d0:	0301000c 0005097e 09020301 03010003     ....~...........
    38e0:	00030926 09090301 04010008 03d00306     &...............
    38f0:	01000209 03090403 7f030100 01000309     ................
    3900:	03097e03 7e030100 01000309 05090203     .~.....~........
    3910:	02030100 01000209 02090103 7c030100     ...............|
    3920:	01000209 0900d003 03010002 00030901     ................
    3930:	09010301 03010003 00030902 09030301     ................
    3940:	03010019 00050901 097f0301 03010002     ................
    3950:	00030901 09020301 0301000a 0006097e     ............~...
    3960:	09040301 04010005 7cbe0301 01000609     ...........|....
    3970:	c5030604 00040903 03010401 03097cbb     .............|..
    3980:	08040100 097f9303 03010007 00050902     ................
    3990:	00d00301 01001109 15090203 02030100     ................
    39a0:	01000509 02097e03 02030100 01000309     .....~..........
    39b0:	06090103 02030100 01000809 1e090403     ................
    39c0:	01030100 01001509 15090103 01030100     ................
    39d0:	01001509 15090103 01030100 01001509     ................
    39e0:	15090203 01030100 01001b09 1b090103     ................
    39f0:	01030100 01001809 1b090103 01030100     ................
    3a00:	01001b09 1b090103 02030100 01001509     ................
    3a10:	15090103 01030100 01001509 15090103     ................
    3a20:	01030100 01001509 15090103 01030100     ................
    3a30:	01001509 15090203 02030100 01000809     ................
    3a40:	08090203 04030100 01001209 18090403     ................
    3a50:	01030100 01001809 18090103 01030100     ................
    3a60:	01001809 18090203 01030100 01001209     ................
    3a70:	17090403 7c030100 01000809 03090403     .......|........
    3a80:	02030100 01000609 0c090203 02030100     ................
    3a90:	01000f09 1a090403 01030100 01001709     ................
    3aa0:	17097503 11030100 01000209 0c090203     .u..............
    3ab0:	01040100 09018003 0301001a 0d097e9b     .............~..
    3ac0:	e5030100 00020901 7e9b0301 01000609     ...........~....
    3ad0:	6d030804 01000609 06090103 02030100     ...m............
    3ae0:	01000609 0d090103 01030100 01001009     ................
    3af0:	10090103 01030100 01001009 10090103     ................
    3b00:	01030100 01001009 10090103 02030100     ................
    3b10:	01001009 10090103 0b040100 0e095203     .............R..
    3b20:	08040100 05092e03 0b040100 02095203     .............R..
    3b30:	01030100 01000309 08090103 6a030100     ...............j
    3b40:	01001009 06090b03 6a030100 01000909     ...........j....
    3b50:	18090103 05030100 01001609 d9030104     ................
    3b60:	00120900 09010301 04010006 0ddc030c     ................
    3b70:	01000609 02090103 03030100 01000309     ................
    3b80:	03090303 57030100 01000509 03092f03     .......W...../..
    3b90:	7a030100 01000409 03095803 2e030100     ...z.....X......
    3ba0:	01000309 03090303 7e030100 01000609     ...........~....
    3bb0:	06090103 01030100 01000309 03090103     ................
    3bc0:	02030100 01000c09 06090203 01030100     ................
    3bd0:	01000a09 04090203 7f030100 01000209     ................
    3be0:	06090103 01030100 01000309 0b090203     ................
    3bf0:	01040100 0971cb03 03010003 000b0902     ......q.........
    3c00:	09010301 0301000f 00090901 09010301     ................
    3c10:	03010009 00090902 09020301 03010009     ................
    3c20:	00060901 09010301 03010006 00090902     ................
    3c30:	09010301 03010006 00060901 09020301     ................
    3c40:	03010009 00060901 09010301 03010009     ................
    3c50:	00090902 09010301 03010009 00090901     ................
    3c60:	092d0301 03010009 170900ed 04030100     ..-.............
    3c70:	01000a09 097ea503 03010009 00080902     ......~.........
    3c80:	097e0301 03010003 0209019e d1030100     ..~.............
    3c90:	00030900 03090401 0b097dd9 01040100     .........}......
    3ca0:	0902a903 04010003 7dd70309 01000609     ...........}....
    3cb0:	c4030a04 00030903 097f0301 03010003     ................
    3cc0:	0003097f 097f0301 03010003 0003097f     ................
    3cd0:	03090401 03097cc0 0a040100 0903c003     .....|..........
    3ce0:	03010003 00020901 097f0301 03010003     ................
    3cf0:	00050901 09010301 03010008 00050901     ................
    3d00:	09010301 03010003 0003097f 09010301     ................
    3d10:	04010002 7dc00303 01000209 11090103     .......}........
    3d20:	0a040100 0902c203 0301000c 00030901     ................
    3d30:	09490301 0301000c 0006091a 7f8f0301     ..I.............
    3d40:	01000309 0f090103 01030100 01000c09     ................
    3d50:	10090103 01030100 01001309 0e096703     .............g..
    3d60:	19030100 01000c09 02096703 01030100     .........g......
    3d70:	01000309 0c090103 01030100 01000e09     ................
    3d80:	13090103 01030100 01001009 d9030904     ................
    3d90:	0009097d 09010301 0301000b 000b0902     }...............
    3da0:	09050301 0301000b 001a0901 09010301     ................
    3db0:	03010006 000c0901 03010401 090902aa     ................
    3dc0:	02030100 01000b09 18030804 01000509     ................
    3dd0:	7a030104 01001709 097f8a03 04010003     ...z............
    3de0:	7ee40308 01000309 02090b03 07030100     ...~............
    3df0:	01000f09 12090103 02030100 01000909     ................
    3e00:	05095903 01030100 01000609 0c090203     .Y..............
    3e10:	7e030100 01000509 03090203 26030100     ...~...........&
    3e20:	01000309 08090903 06040100 0903cf03     ................
    3e30:	03010002 00030905 097f0301 03010003     ................
    3e40:	0003097e 097f0301 03010003 00050901     ~...............
    3e50:	09020301 03010002 00020901 097b0301     ..............{.
    3e60:	03010002 020900d1 01030100 01000309     ................
    3e70:	03090103 02030100 01000309 19090303     ................
    3e80:	01030100 01000509 02097f03 01030100     ................
    3e90:	01000309 0a090203 7e030100 01000609     ...........~....
    3ea0:	05090403 03030100 01000609 f8030104     ................
    3eb0:	0003097d 7ed50301 01000309 0901ae03     }......~........
    3ec0:	03010005 11097fba 08040100 097e9903     ..............~.
    3ed0:	03010006 000b0902 00d00301 01000d09     ................
    3ee0:	15090203 02030100 01000809 08090103     ................
    3ef0:	02030100 01000809 1b090403 01030100     ................
    3f00:	01001509 15090103 01030100 01001509     ................
    3f10:	15090103 01030100 01001509 15090203     ................
    3f20:	01030100 01001b09 1b090103 01030100     ................
    3f30:	01001809 1b090103 01030100 01001b09     ................
    3f40:	1b090103 02030100 01001509 15090103     ................
    3f50:	01030100 01001509 15090103 01030100     ................
    3f60:	01001509 15090103 01030100 01001509     ................
    3f70:	15090203 02030100 01000809 08090203     ................
    3f80:	04030100 01001209 15090403 01030100     ................
    3f90:	01001809 18090103 01030100 01001809     ................
    3fa0:	18090203 01030100 01001509 17090403     ................
    3fb0:	7c030100 01000609 05090403 02030100     ...|............
    3fc0:	01000609 0c090203 02030100 01000f09     ................
    3fd0:	1a090403 01030100 01001709 17097503     .............u..
    3fe0:	11030100 01000209 0f090203 17090100     ................
    3ff0:	01010000 000000e1 00750002 01010000     ..........u.....
    4000:	000d0efb 01010101 01000000 2f010000     .............../
    4010:	6c697562 72742f64 522f6565 30322d46     build/tree/RF-20
    4020:	312e3431 6d756b5f 6f742f61 2f736c6f     14.1_kuma/tools/
    4030:	6f747773 2d736c6f 6957534d 2d32336e     swtools-MSWin32-
    4040:	2f363878 6e657478 652d6173 732f666c     x86/xtensa-elf/s
    4050:	782f6372 00736f74 63786500 7379732d     rc/xtos..exc-sys
    4060:	6c6c6163 6e61682d 72656c64 0100532e     call-handler.S..
    4070:	00000000 5eb00205 d703ffe0 06030100     .......^........
    4080:	01000309 03090103 01030100 01000209     ................
    4090:	03090103 01030100 01000309 02090103     ................
    40a0:	01030100 01000209 03090103 01030100     ................
    40b0:	01000309 02090603 01030100 01000309     ................
    40c0:	0900cb03 03010002 00020901 09010301     ................
    40d0:	09010003 01000003 00008b01 6e000200     ...............n
    40e0:	01000000 0d0efb01 01010100 00000001     ................
    40f0:	01000001 6975622f 742f646c 2f656572     ..../build/tree/
    4100:	322d4652 2e343130 756b5f31 742f616d     RF-2014.1_kuma/t
    4110:	736c6f6f 7477732f 736c6f6f 57534d2d     ools/swtools-MSW
    4120:	32336e69 3638782d 6574782f 2d61736e     in32-x86/xtensa-
    4130:	2f666c65 2f637273 736f7478 756e0000     elf/src/xtos..nu
    4140:	762d6c6c 6f746365 532e7372 00000100     ll-vectors.S....
    4150:	02050000 ffe00a40 01019303 03090603     ....@...........
    4160:	03090100 01010000 00000096 006e0002     ..............n.
    4170:	01010000 000d0efb 01010101 01000000     ................
    4180:	2f010000 6c697562 72742f64 522f6565     .../build/tree/R
    4190:	30322d46 312e3431 6d756b5f 6f742f61     F-2014.1_kuma/to
    41a0:	2f736c6f 6f747773 2d736c6f 6957534d     ols/swtools-MSWi
    41b0:	2d32336e 2f363878 6e657478 652d6173     n32-x86/xtensa-e
    41c0:	732f666c 782f6372 00736f74 62656400     lf/src/xtos..deb
    41d0:	762d6775 6f746365 00532e72 00000001     ug-vector.S.....
    41e0:	80020500 03ffe00a 0103012c 01000309     ........,.......
    41f0:	02090103 0c030100 01000309 00000309     ................
    4200:	008b0101 00020000 0000006f 0efb0101     ........o.......
    4210:	0101000d 00000101 00000100 75622f01     ............./bu
    4220:	2f646c69 65657274 2d46522f 34313032     ild/tree/RF-2014
    4230:	6b5f312e 2f616d75 6c6f6f74 77732f73     .1_kuma/tools/sw
    4240:	6c6f6f74 534d2d73 336e6957 38782d32     tools-MSWin32-x8
    4250:	74782f36 61736e65 666c652d 6372732f     6/xtensa-elf/src
    4260:	6f74782f 64000073 6c62756f 65762d65     /xtos..double-ve
    4270:	726f7463 0100532e 00000000 0bd00205     ctor.S..........
    4280:	3e03ffe0 09080301 09010003 01000003     ...>............
    4290:	00008b01 6f000200 01000000 0d0efb01     .......o........
    42a0:	01010100 00000001 01000001 6975622f     ............/bui
    42b0:	742f646c 2f656572 322d4652 2e343130     ld/tree/RF-2014.
    42c0:	756b5f31 742f616d 736c6f6f 7477732f     1_kuma/tools/swt
    42d0:	736c6f6f 57534d2d 32336e69 3638782d     ools-MSWin32-x86
    42e0:	6574782f 2d61736e 2f666c65 2f637273     /xtensa-elf/src/
    42f0:	736f7478 656b0000 6c656e72 6365762d     xtos..kernel-vec
    4300:	2e726f74 00010053 05000000 e00b0002     tor.S...........
    4310:	013f03ff 03090803 03090100 01010000     ..?.............
    4320:	00000082 006c0002 01010000 000d0efb     ......l.........
    4330:	01010101 01000000 2f010000 6c697562     .........../buil
    4340:	72742f64 522f6565 30322d46 312e3431     d/tree/RF-2014.1
    4350:	6d756b5f 6f742f61 2f736c6f 6f747773     _kuma/tools/swto
    4360:	2d736c6f 6957534d 2d32336e 2f363878     ols-MSWin32-x86/
    4370:	6e657478 652d6173 732f666c 782f6372     xtensa-elf/src/x
    4380:	00736f74 696d6e00 6365762d 2e726f74     tos..nmi-vector.
    4390:	00010053 05000000 e00ac002 013703ff     S.............7.
    43a0:	00000309 00000101                                ......

Disassembly of section .xt.prop:

00000000 <.xt.prop>:
       0:	ffe0197c 000003e8 00000001 ffe01d68     |...........h...
      10:	00000057 00000082 ffe01dbf 00000000     W...............
      20:	00000008 ffe01dbf 00000012 000000a2     ................
      30:	ffe01dd1 00000000 00000008 ffe01dd1     ................
      40:	00000008 000000a2 ffe01dd9 00000008     ................
      50:	000000a2 ffe01de1 00000022 000000a2     ........".......
      60:	ffe01e03 00000000 00000008 ffe01e03     ................
      70:	00000009 000000a2 ffe01e0c 00000000     ................
      80:	00002808 ffe01e0c 0000001d 00000082     .(..............
      90:	ffe01e29 00000000 00000008 ffe01e29     )...........)...
      a0:	00000004 00000082 ffe01e2d 00000000     ........-.......
      b0:	00002808 ffe01e30 00000046 00000082     .(..0...F.......
      c0:	ffe01e76 00000022 000000a2 ffe01e98     v..."...........
      d0:	00000000 00002808 ffe01e98 00000017     .....(..........
      e0:	00000082 ffe01eaf 0000000c 000000a2     ................
      f0:	ffe01ebb 00000000 00000008 ffe01ebb     ................
     100:	0000000f 000000a2 ffe01eca 00000000     ................
     110:	00002808 ffe01ecc 00000031 00000082     .(......1.......
     120:	ffe01efd 00000000 00000008 ffe01efd     ................
     130:	00000024 000000a2 ffe01f21 00000000     $.......!.......
     140:	00000008 ffe01f21 00000003 000000a2     ....!...........
     150:	ffe01f24 00000009 000000a2 ffe01f2d     $...........-...
     160:	00000000 00000008 ffe01f2d 00000008     ........-.......
     170:	000000a2 ffe01f35 00000000 00000008     ....5...........
     180:	ffe01f35 00000008 000000a2 ffe01f3d     5...........=...
     190:	00000000 00002808 ffe01f40 00000014     .....(..@.......
     1a0:	00000082 ffe01f54 00000045 000000a2     ....T...E.......
     1b0:	ffe01f99 00000018 000000a2 ffe01fb1     ................
     1c0:	00000000 00000008 ffe01fb1 00000003     ................
     1d0:	000000a2 ffe01fb4 00000009 000000a2     ................
     1e0:	ffe01fbd 00000000 00000008 ffe01fbd     ................
     1f0:	00000038 000000a2 ffe01ff5 00000000     8...............
     200:	00002808 ffe01ff8 0000000e 00000082     .(..............
     210:	ffe02006 00000000 00000008 ffe02006     . ........... ..
     220:	00000008 000000a2 ffe0200e 00000007     ......... ......
     230:	000000a2 ffe02015 00000000 00002808     ..... .......(..
     240:	ffe02018 00000035 00000082 ffe0204d     . ..5.......M ..
     250:	00000006 000000a2 ffe02053 0000000a     ........S ......
     260:	000000a2 ffe0205d 00000000 00002808     ....] .......(..
     270:	ffe02060 0000004b 00000082 ffe020ab     ` ..K........ ..
     280:	00000031 000000a2 ffe020dc 00000000     1........ ......
     290:	00000008 ffe020dc 00000015 000000a2     ..... ..........
     2a0:	ffe020f1 00000000 00000008 ffe020f1     . ........... ..
     2b0:	00000003 000000a2 ffe020f4 00000024     ......... ..$...
     2c0:	000000a2 ffe02118 00000005 000000a2     .....!..........
     2d0:	ffe0211d 00000000 00000008 ffe0211d     .!...........!..
     2e0:	00000006 000000a2 ffe02123 0000000b     ........#!......
     2f0:	000000a2 ffe0212e 00000033 000000a2     .....!..3.......
     300:	ffe02161 00000148 00000092 ffe022a9     a!..H........"..
     310:	00000031 000000a2 ffe022da 00000000     1........"......
     320:	00000008 ffe022da 00000009 000000a2     ....."..........
     330:	ffe022e3 00000026 000000a2 ffe02309     ."..&........#..
     340:	00000005 000000a2 ffe0230e 00000000     .........#......
     350:	00000008 ffe0230e 0000000c 000000a2     .....#..........
     360:	ffe0231a 00000014 000000a2 ffe0232e     .#...........#..
     370:	00000000 00000008 ffe0232e 0000000f     .........#......
     380:	000000a2 ffe0233d 000000da 00000092     ....=#..........
     390:	ffe02417 00000033 000000a2 ffe0244a     .$..3.......J$..
     3a0:	00000000 00000008 ffe0244a 00000006     ........J$......
     3b0:	000000a2 ffe02450 00000000 00000008     ....P$..........
     3c0:	ffe02450 00000003 000000a2 ffe02453     P$..........S$..
     3d0:	00000021 000000a2 ffe02474 00000005     !.......t$......
     3e0:	000000a2 ffe02479 00000000 00000008     ....y$..........
     3f0:	ffe02479 0000001d 000000a2 ffe02496     y$...........$..
     400:	00000006 000000a2 ffe0249c 00000000     .........$......
     410:	00000008 ffe0249c 00000026 000000a2     .....$..&.......
     420:	ffe024c2 00000000 00000008 ffe024c2     .$...........$..
     430:	00000006 000000a2 ffe024c8 0000000e     .........$......
     440:	000000a2 ffe024d6 00000000 00000008     .....$..........
     450:	ffe024d6 00000006 000000a2 ffe024dc     .$...........$..
     460:	00000000 00000008 ffe024dc 00000017     .........$......
     470:	000000a2 ffe024f3 00000000 00000008     .....$..........
     480:	ffe024f3 00000026 000000a2 ffe02519     .$..&........%..
     490:	0000001d 000000a2 ffe02536 00000000     ........6%......
     4a0:	00000008 ffe02536 00000019 000000a2     ....6%..........
     4b0:	ffe0254f 00000000 00000008 ffe0254f     O%..........O%..
     4c0:	00000008 000000a2 ffe02557 00000024     ........W%..$...
     4d0:	000000a2 ffe0257b 00000006 000000a2     ....{%..........
     4e0:	ffe02581 00000000 00000008 ffe02581     .%...........%..
     4f0:	00000006 000000a2 ffe02587 00000000     .........%......
     500:	00002808 ffe02588 0000000e 00000082     .(...%..........
     510:	ffe02596 00000000 00000008 ffe02596     .%...........%..
     520:	00000025 000000a2 ffe025bb 00000000     %........%......
     530:	00000008 ffe025bb 00000003 000000a2     .....%..........
     540:	ffe025be 00000018 000000a2 ffe025d6     .%...........%..
     550:	00000027 00000092 ffe025fd 00000051     '........%..Q...
     560:	000000a2 ffe0264e 00000000 00000008     ....N&..........
     570:	ffe0264e 00000003 000000a2 ffe02651     N&..........Q&..
     580:	0000000a 000000a2 ffe0265b 00000000     ........[&......
     590:	00000008 ffe0265b 00000005 000000a2     ....[&..........
     5a0:	ffe02660 00000000 00002808 ffe02660     `&.......(..`&..
     5b0:	00000046 00000082 ffe026a6 00000035     F........&..5...
     5c0:	000000a2 ffe026db 00000000 00002808     .....&.......(..
     5d0:	ffe026dc 00000021 00000082 ffe026fd     .&..!........&..
     5e0:	00000000 00000008 ffe026fd 00000004     .........&......
     5f0:	000000a2 ffe02701 00000000 00002808     .....'.......(..
     600:	ffe02704 0000004b 00000082 ffe0274f     .'..K.......O'..
     610:	00000013 000000a2 ffe02762 0000000f     ........b'......
     620:	000000a2 ffe02771 00000000 00000008     ....q'..........
     630:	ffe02771 00000009 000000a2 ffe0277a     q'..........z'..
     640:	00000005 000000a2 ffe0277f 00000000     .........'......
     650:	00000008 ffe0277f 0000002a 000000a2     .....'..*.......
     660:	ffe027a9 00000005 00000092 ffe027ae     .'...........'..
     670:	00000000 00000008 ffe027ae 0000003e     .........'..>...
     680:	000000a2 ffe027ec 00000003 000000a2     .....'..........
     690:	ffe027ef 0000000c 000000a2 ffe027fb     .'...........'..
     6a0:	00000000 00000008 ffe027fb 00000002     .........'......
     6b0:	000000a2 ffe027fd 00000002 000000a2     .....'..........
     6c0:	ffe027ff 0000000c 000000a2 ffe0280b     .'...........(..
     6d0:	00000000 00000008 ffe0280b 0000000c     .........(......
     6e0:	000000a2 ffe02817 00000000 00000008     .....(..........
     6f0:	ffe02817 0000003a 000000a2 ffe02851     .(..:.......Q(..
     700:	0000000c 000000a2 ffe0285d 00000000     ........](......
     710:	00000008 ffe0285d 0000000c 000000a2     ....](..........
     720:	ffe02869 00000000 00000008 ffe02869     i(..........i(..
     730:	00000057 000000a2 ffe028c0 00000027     W........(..'...
     740:	000000a2 ffe028e7 00000000 00000008     .....(..........
     750:	ffe028e7 00000008 000000a2 ffe028ef     .(...........(..
     760:	00000008 000000a2 ffe028f7 00000000     .........(......
     770:	00000008 ffe028f7 00000025 000000a2     .....(..%.......
     780:	ffe0291c 00000027 00000092 ffe02943     .)..'.......C)..
     790:	0000000e 00000092 ffe02951 00000000     ........Q)......
     7a0:	00000008 ffe02951 00000006 000000a2     ....Q)..........
     7b0:	ffe02957 00000014 000000a2 ffe0296b     W)..........k)..
     7c0:	00000017 000000a2 ffe02982 0000022e     .........)......
     7d0:	000000a2 ffe02bb0 00000023 000000a2     .....+..#.......
     7e0:	ffe02bd3 0000001b 000000a2 ffe02bee     .+...........+..
     7f0:	00000000 00000008 ffe02bee 00000014     .........+......
     800:	000000a2 ffe02c02 00000005 000000a2     .....,..........
     810:	ffe02c07 00000000 00000008 ffe02c07     .,...........,..
     820:	00000010 000000a2 ffe02c17 00000000     .........,......
     830:	00000008 ffe02c17 0000004d 000000a2     .....,..M.......
     840:	ffe02c64 0000000c 000000a2 ffe02c70     d,..........p,..
     850:	00000000 00000008 ffe02c70 00000034     ........p,..4...
     860:	000000a2 ffe02ca4 00000000 00000008     .....,..........
     870:	ffe02ca4 00000032 000000a2 ffe02cd6     .,..2........,..
     880:	0000000f 000000a2 ffe02ce5 00000000     .........,......
     890:	00000008 ffe02ce5 00000056 000000a2     .....,..V.......
     8a0:	ffe02d3b 0000000c 000000a2 ffe02d47     ;-..........G-..
     8b0:	00000000 00000008 ffe02d47 00000037     ........G-..7...
     8c0:	000000a2 ffe02d7e 00000005 000000a2     ....~-..........
     8d0:	ffe02d83 00000000 00000008 ffe02d83     .-...........-..
     8e0:	00000034 000000a2 ffe02db7 00000000     4........-......
     8f0:	00000008 ffe02db7 00000018 000000a2     .....-..........
     900:	ffe02dcf 00000000 00000008 ffe02dcf     .-...........-..
     910:	00000033 000000a2 ffe02e02 0000000c     3...............
     920:	000000a2 ffe02e0e 00000000 00000008     ................
     930:	ffe02e0e 00000020 000000a2 ffe02e2e     .... ...........
     940:	00000003 000000a2 ffe02e31 00000005     ........1.......
     950:	000000a2 ffe02e36 00000000 00000008     ....6...........
     960:	ffe02e36 00000009 000000a2 ffe02e3f     6...........?...
     970:	00000009 000000a2 ffe02e48 00000005     ........H.......
     980:	000000a2 ffe02e4d 00000000 00000008     ....M...........
     990:	ffe02e4d 00000009 000000a2 ffe02e56     M...........V...
     9a0:	00000000 00000008 ffe02e56 00000012     ........V.......
     9b0:	000000a2 ffe02e68 00000000 00000008     ....h...........
     9c0:	ffe02e68 00000012 000000a2 ffe02e7a     h...........z...
     9d0:	00000000 00000008 ffe02e7a 0000000f     ........z.......
     9e0:	000000a2 ffe02e89 00000000 00000008     ................
     9f0:	ffe02e89 00000008 000000a2 ffe02e91     ................
     a00:	00000000 00000008 ffe02e91 00000008     ................
     a10:	000000a2 ffe02e99 00000000 00000008     ................
     a20:	ffe02e99 00000005 000000a2 ffe02e9e     ................
     a30:	0000000e 000000a2 ffe02eac 00000000     ................
     a40:	00000008 ffe02eac 00000011 000000a2     ................
     a50:	ffe02ebd 00000000 00000008 ffe02ebd     ................
     a60:	0000000b 000000a2 ffe02ec8 00000000     ................
     a70:	00000008 ffe02ec8 0000000f 000000a2     ................
     a80:	ffe02ed7 00000000 00000008 ffe02ed7     ................
     a90:	0000000d 000000a2 ffe02ee4 00000000     ................
     aa0:	00000008 ffe02ee4 00000005 000000a2     ................
     ab0:	ffe02ee9 00000000 00000008 ffe02ee9     ................
     ac0:	0000001d 000000a2 ffe02f06 00000000     ........./......
     ad0:	00002808 ffe02f08 00000015 00000082     .(.../..........
     ae0:	ffe02f1d 00000000 00000008 ffe02f1d     ./.........../..
     af0:	0000001f 000000a2 ffe02f3c 00000000     ........</......
     b00:	00002808 ffe02f3c 00000015 00000082     .(..</..........
     b10:	ffe02f51 00000000 00000008 ffe02f51     Q/..........Q/..
     b20:	0000004b 000000a2 ffe02f9c 000000ba     K......../......
     b30:	00000092 ffe03056 00000000 00000008     ....V0..........
     b40:	ffe03056 00000008 000000a2 ffe0305e     V0..........^0..
     b50:	0000000b 000000a2 ffe03069 00000000     ........i0......
     b60:	00000008 ffe03069 00000008 000000a2     ....i0..........
     b70:	ffe03071 00000000 00000008 ffe03071     q0..........q0..
     b80:	00000006 000000a2 ffe03077 00000005     ........w0......
     b90:	000000a2 ffe0307c 00000000 00002808     ....|0.......(..
     ba0:	ffe0307c 0000000f 00000082 ffe0308b     |0...........0..
     bb0:	00000000 00000008 ffe0308b 00000004     .........0......
     bc0:	000000a2 ffe0308f 00000004 000000a2     .....0..........
     bd0:	ffe03093 00000000 00002808 ffe03094     .0.......(...0..
     be0:	0000001e 00000082 ffe030b2 0000004c     .........0..L...
     bf0:	000000a2 ffe030fe 00000011 000000a2     .....0..........
     c00:	ffe0310f 00000000 00000008 ffe0310f     .1...........1..
     c10:	0000000f 000000a2 ffe0311e 0000001e     .........1......
     c20:	000000a2 ffe0313c 00000000 00000008     ....<1..........
     c30:	ffe0313c 00000003 000000a2 ffe0313f     <1..........?1..
     c40:	00000016 000000a2 ffe03155 0000000c     ........U1......
     c50:	000000a2 ffe03161 00000000 00002808     ....a1.......(..
     c60:	ffe03164 00000019 00000082 ffe0317d     d1..........}1..
     c70:	0000001e 000000a2 ffe0319b 0000002c     .........1..,...
     c80:	00000092 ffe031c7 00000016 000000a2     .....1..........
     c90:	ffe031dd 00000000 00002808 ffe031e0     .1.......(...1..
     ca0:	0000002b 00000082 ffe0320b 00000000     +........2......
     cb0:	00000008 ffe0320b 00000003 000000a2     .....2..........
     cc0:	ffe0320e 00000006 000000a2 ffe03214     .2...........2..
     cd0:	00000009 000000a2 ffe0321d 00000000     .........2......
     ce0:	00002808 ffe03220 00000021 00000082     .(.. 2..!.......
     cf0:	ffe03241 00000003 00000092 ffe03244     A2..........D2..
     d00:	00000005 000000a2 ffe03249 00000007     ........I2......
     d10:	000000a2 ffe03250 00000000 00002808     ....P2.......(..
     d20:	ffe03250 00000018 00000082 ffe03268     P2..........h2..
     d30:	00000002 000000a2 ffe0326a 00000000     ........j2......
     d40:	00002808 ffe0326c 0000000a 00000082     .(..l2..........
     d50:	ffe03276 00000000 00002808 ffe03278     v2.......(..x2..
     d60:	0000002a 00000082 ffe032a2 00000000     *........2......
     d70:	00002808 ffe032a4 00000027 00000082     .(...2..'.......
     d80:	ffe032cb 00000011 000000a2 ffe032dc     .2...........2..
     d90:	00000003 000000a2 ffe032df 0000000e     .........2......
     da0:	000000a2 ffe032ed 00000000 00002808     .....2.......(..
     db0:	ffe032f0 0000002d 00000082 ffe0331d     .2..-........3..
     dc0:	00000005 00000092 ffe03322 0000000e     ........"3......
     dd0:	000000a2 ffe03330 00000000 00002808     ....03.......(..
     de0:	ffe03330 00000023 00000082 ffe03353     03..#.......S3..
     df0:	0000000c 000000a2 ffe0335f 00000000     ........_3......
     e00:	00002808 ffe03360 00000022 00000082     .(..`3..".......
     e10:	ffe03382 0000000a 000000a2 ffe0338c     .3...........3..
     e20:	00000000 00000008 ffe0338c 00000009     .........3......
     e30:	000000a2 ffe03395 00000000 00002808     .....3.......(..
     e40:	ffe03398 0000003d 00000082 ffe033d5     .3..=........3..
     e50:	00000000 00000008 ffe033d5 00000003     .........3......
     e60:	000000a2 ffe033d8 00000003 000000a2     .....3..........
     e70:	ffe033db 0000000f 000000a2 ffe033ea     .3...........3..
     e80:	00000000 00000008 ffe033ea 00000006     .........3......
     e90:	000000a2 ffe033f0 00000000 00000008     .....3..........
     ea0:	ffe033f0 00000019 000000a2 ffe03409     .3...........4..
     eb0:	00000000 00000008 ffe03409 00000014     .........4......
     ec0:	000000a2 ffe0341d 00000000 00000008     .....4..........
     ed0:	ffe0341d 00000006 000000a2 ffe03423     .4..........#4..
     ee0:	00000000 00000008 ffe03423 00000019     ........#4......
     ef0:	000000a2 ffe0343c 00000000 00000008     ....<4..........
     f00:	ffe0343c 00000006 000000a2 ffe03442     <4..........B4..
     f10:	00000000 00000008 ffe03442 00000067     ........B4..g...
     f20:	000000a2 ffe034a9 00000000 00000008     .....4..........
     f30:	ffe034a9 0000000e 000000a2 ffe034b7     .4...........4..
     f40:	00000000 00002808 ffe034b8 00000026     .....(...4..&...
     f50:	00000082 ffe034de 00000019 00000092     .....4..........
     f60:	ffe034f7 0000000c 00000092 ffe03503     .4...........5..
     f70:	00000000 00002808 ffe03504 0000002d     .....(...5..-...
     f80:	00000082 ffe03531 00000012 00000092     ....15..........
     f90:	ffe03543 00000000 00000008 ffe03543     C5..........C5..
     fa0:	0000002d 000000a2 ffe03570 00000000     -.......p5......
     fb0:	00000008 ffe03570 00000008 000000a2     ....p5..........
     fc0:	ffe03578 00000006 000000a2 ffe0357e     x5..........~5..
     fd0:	00000000 00000008 ffe0357e 00000003     ........~5......
     fe0:	000000a2 ffe03581 00000009 000000a2     .....5..........
     ff0:	ffe0358a 00000000 00000008 ffe0358a     .5...........5..
    1000:	00000014 000000a2 ffe0359e 0000000f     .........5......
    1010:	000000a2 ffe035ad 00000000 00002808     .....5.......(..
    1020:	ffe035b0 00000021 00000082 ffe035d1     .5..!........5..
    1030:	00000000 00002808 ffe035d4 0000000f     .....(...5......
    1040:	00000082 ffe035e3 00000000 00002808     .....5.......(..
    1050:	ffe035e4 00000034 00000082 ffe03618     .5..4........6..
    1060:	00000007 000000a2 ffe0361f 00000000     .........6......
    1070:	00002808 ffe03620 0000003b 00000082     .(.. 6..;.......
    1080:	ffe0365b 00000007 000000a2 ffe03662     [6..........b6..
    1090:	00000000 00002808 ffe03664 00000041     .....(..d6..A...
    10a0:	00000082 ffe036a5 00000007 000000a2     .....6..........
    10b0:	ffe036ac 00000000 00002808 ffe036ac     .6.......(...6..
    10c0:	0000004b 00000082 ffe036f7 00000007     K........6......
    10d0:	000000a2 ffe036fe 00000000 00002808     .....6.......(..
    10e0:	ffe03700 0000002b 00000082 ffe0372b     .7..+.......+7..
    10f0:	00000004 000000b2 ffe0372f 00000000     ......../7......
    1100:	00002808 ffe03730 00000024 00000082     .(..07..$.......
    1110:	ffe03754 0000003e 000000a2 ffe03792     T7..>........7..
    1120:	00000000 00000008 ffe03792 0000001a     .........7......
    1130:	000000a2 ffe037ac 0000000b 000000a2     .....7..........
    1140:	ffe037b7 00000000 00002808 ffe037b8     .7.......(...7..
    1150:	00000013 00000082 ffe037cb 00000000     .........7......
    1160:	00000008 ffe037cb 00000008 000000a2     .....7..........
    1170:	ffe037d3 00000007 000000a2 ffe037da     .7...........7..
    1180:	00000000 00002808 ffe037dc 00000027     .....(...7..'...
    1190:	00000082 ffe03803 00000000 00000008     .....8..........
    11a0:	ffe03803 00000006 000000a2 ffe03809     .8...........8..
    11b0:	0000001e 000000a2 ffe03827 00000000     ........'8......
    11c0:	00002808 ffe03828 00000038 00000082     .(..(8..8.......
    11d0:	ffe03860 00000036 000000a2 ffe03896     `8..6........8..
    11e0:	00000042 00000092 ffe038d8 00000024     B........8..$...
    11f0:	000000a2 ffe038fc 000000aa 00000092     .....8..........
    1200:	ffe039a6 00000000 00000008 ffe039a6     .9...........9..
    1210:	0000000e 000000a2 ffe039b4 0000000f     .........9......
    1220:	000000a2 ffe039c3 00000000 00002808     .....9.......(..
    1230:	ffe039c4 00000023 00000082 ffe039e7     .9..#........9..
    1240:	00000000 00000008 ffe039e7 00000018     .........9......
    1250:	000000a2 ffe039ff 00000000 00000008     .....9..........
    1260:	ffe039ff 00000023 000000a2 ffe03a22     .9..#.......":..
    1270:	00000000 00002808 ffe03a24 0000000f     .....(..$:......
    1280:	00000082 ffe03a33 0000001d 000000a2     ....3:..........
    1290:	ffe03a50 00000000 00002808 ffe03a50     P:.......(..P:..
    12a0:	00000136 00000082 ffe03b86 00000018     6........;......
    12b0:	000000a2 ffe03b9e 00000000 00000008     .....;..........
    12c0:	ffe03b9e 00000006 000000a2 ffe03ba4     .;...........;..
    12d0:	00000008 000000a2 ffe03bac 00000034     .........;..4...
    12e0:	000000a2 ffe03be0 00000000 00000008     .....;..........
    12f0:	ffe03be0 00000012 000000a2 ffe03bf2     .;...........;..
    1300:	00000000 00000008 ffe03bf2 0000000f     .........;......
    1310:	000000a2 ffe03c01 0000000f 000000a2     .....<..........
    1320:	ffe03c10 00000006 000000a2 ffe03c16     .<...........<..
    1330:	00000000 00002808 ffe03c18 00000002     .....(...<......
    1340:	00000082 ffe03c1a 00000000 00002808     .....<.......(..
    1350:	ffe03c1c 00000012 00000082 ffe03c2e     .<...........<..
    1360:	00000000 00002808 ffe03c30 000000bc     .....(..0<......
    1370:	00000082 ffe03cec 00000000 00002808     .....<.......(..
    1380:	ffe03cec 00000067 00000082 ffe03d53     .<..g.......S=..
    1390:	0000002d 000000a2 ffe03d80 00000000     -........=......
    13a0:	00002808 ffe03d80 0000001d 00000082     .(...=..........
    13b0:	ffe03d9d 00000028 000000a2 ffe03dc5     .=..(........=..
    13c0:	00000002 000000a2 ffe03dc7 00000000     .........=......
    13d0:	00002808 ffe03dc8 00000020 00000082     .(...=.. .......
    13e0:	ffe03de8 00000000 00002808 ffe03de8     .=.......(...=..
    13f0:	00000049 00000082 ffe03e31 00000000     I.......1>......
    1400:	00000008 ffe03e31 00000006 000000a2     ....1>..........
    1410:	ffe03e37 0000000e 000000a2 ffe03e45     7>..........E>..
    1420:	00000000 00000008 ffe03e45 00000006     ........E>......
    1430:	000000a2 ffe03e4b 00000008 000000a2     ....K>..........
    1440:	ffe03e53 00000000 00002808 ffe03e54     S>.......(..T>..
    1450:	00000022 00000082 ffe03e76 00000027     ".......v>..'...
    1460:	000000a2 ffe03e9d 00000046 000000a2     .....>..F.......
    1470:	ffe03ee3 00000000 00000008 ffe03ee3     .>...........>..
    1480:	0000001c 000000a2 ffe03eff 00000013     .........>......
    1490:	000000a2 ffe03f12 00000000 00000008     .....?..........
    14a0:	ffe03f12 00000006 000000a2 ffe03f18     .?...........?..
    14b0:	0000000d 000000a2 ffe03f25 00000040     ........%?..@...
    14c0:	000000a2 ffe03f65 0000000f 000000a2     ....e?..........
    14d0:	ffe03f74 0000001a 000000a2 ffe03f8e     t?...........?..
    14e0:	00000015 000000a2 ffe03fa3 00000040     .........?..@...
    14f0:	000000a2 ffe03fe3 00000006 000000a2     .....?..........
    1500:	ffe03fe9 00000011 000000a2 ffe03ffa     .?...........?..
    1510:	0000000f 000000a2 ffe04009 00000000     .........@......
    1520:	00000008 ffe04009 00000025 000000a2     .....@..%.......
    1530:	ffe0402e 00000000 00000008 ffe0402e     .@...........@..
    1540:	00000026 000000a2 ffe04054 00000014     &.......T@......
    1550:	000000a2 ffe04068 00000000 00000008     ....h@..........
    1560:	ffe04068 00000006 000000a2 ffe0406e     h@..........n@..
    1570:	00000013 000000a2 ffe04081 00000000     .........@......
    1580:	00000008 ffe04081 0000001e 000000a2     .....@..........
    1590:	ffe0409f 00000000 00000008 ffe0409f     .@...........@..
    15a0:	0000001a 000000a2 ffe040b9 00000000     .........@......
    15b0:	00000008 ffe040b9 00000017 000000a2     .....@..........
    15c0:	ffe040d0 00000000 00000008 ffe040d0     .@...........@..
    15d0:	00000013 000000a2 ffe040e3 00000000     .........@......
    15e0:	00000008 ffe040e3 00000009 000000a2     .....@..........
    15f0:	ffe040ec 00000013 000000a2 ffe040ff     .@...........@..
    1600:	00000000 00002808 ffe04100 00000002     .....(...A......
    1610:	00000082 ffe04102 00000000 00002808     .....A.......(..
    1620:	ffe04104 00000015 00000082 ffe04119     .A...........A..
    1630:	00000000 00000008 ffe04119 00000015     .........A......
    1640:	000000a2 ffe0412e 00000002 000000a2     .....A..........
    1650:	ffe04130 00000000 00000008 ffe04130     0A..........0A..
    1660:	00000032 000000a2 ffe04162 00000000     2.......bA......
    1670:	00002808 ffe04164 00000012 00000082     .(..dA..........
    1680:	ffe04176 00000000 00002808 ffe04178     vA.......(..xA..
    1690:	00000013 00000082 ffe0418b 00000000     .........A......
    16a0:	00002808 ffe0418c 00000013 00000082     .(...A..........
    16b0:	ffe0419f 00000011 000000a2 ffe041b0     .A...........A..
    16c0:	00000000 00000008 ffe041b0 00000002     .........A......
    16d0:	000000a2 ffe041b2 00000030 000000a2     .....A..0.......
    16e0:	ffe041e2 00000000 00000008 ffe041e2     .A...........A..
    16f0:	00000002 000000a2 ffe041e4 00000007     .........A......
    1700:	000000a2 ffe041eb 00000000 00002808     .....A.......(..
    1710:	ffe041ec 00000062 00000082 ffe0424e     .A..b.......NB..
    1720:	00000000 00002808 ffe04250 00000052     .....(..PB..R...
    1730:	00000082 ffe042a2 00000003 00000092     .....B..........
    1740:	ffe042a5 00000001 00000008 ffe042a6     .B...........B..
    1750:	00000023 00000082 ffe042c9 00000007     #........B......
    1760:	000000a2 ffe042d0 00000000 00000008     .....B..........
    1770:	ffe042d0 00000002 000000a2 ffe042d2     .B...........B..
    1780:	00000017 000000a2 ffe042e9 00000003     .........B......
    1790:	00000092 ffe042ec 00000000 00002808     .....B.......(..
    17a0:	ffe042ec 00000010 00000082 ffe042fc     .B...........B..
    17b0:	00000000 00000008 ffe042fc 00000004     .........B......
    17c0:	000000a2 ffe04300 00000000 00002808     .....C.......(..
    17d0:	ffe04300 00000010 00000082 ffe04310     .C...........C..
    17e0:	00000000 00000008 ffe04310 00000002     .........C......
    17f0:	000000a2 ffe04312 00000000 00002808     .....C.......(..
    1800:	ffe04314 00000026 00000082 ffe0433a     .C..&.......:C..
    1810:	00000038 000000a2 ffe04372 00000005     8.......rC......
    1820:	000000a2 ffe04377 00000000 00000008     ....wC..........
    1830:	ffe04377 0000001f 000000a2 ffe04396     wC...........C..
    1840:	00000013 00000092 ffe043a9 0000001f     .........C......
    1850:	000000a2 ffe043c8 00000059 000000a2     .....C..Y.......
    1860:	ffe04421 0000000f 000000a2 ffe04430     !D..........0D..
    1870:	00000000 00002808 ffe04430 00000023     .....(..0D..#...
    1880:	00000082 ffe04453 0000001e 000000a2     ....SD..........
    1890:	ffe04471 00000038 000000a2 ffe044a9     qD..8........D..
    18a0:	00000000 00000008 ffe044a9 0000001f     .........D......
    18b0:	000000a2 ffe044c8 00000017 00000092     .....D..........
    18c0:	ffe044df 00000000 00000008 ffe044df     .D...........D..
    18d0:	00000005 000000a2 ffe044e4 0000001e     .........D......
    18e0:	000000a2 ffe04502 00000060 000000a2     .....E..`.......
    18f0:	ffe04562 0000000f 000000a2 ffe04571     bE..........qE..
    1900:	00000000 00002808 ffe04574 00000015     .....(..tE......
    1910:	00000082 ffe04589 0000000f 000000a2     .....E..........
    1920:	ffe04598 00000000 00002808 ffe04598     .E.......(...E..
    1930:	00000024 00000082 ffe045bc 0000000a     $........E......
    1940:	000000a2 ffe045c6 00000000 00002808     .....E.......(..
    1950:	ffe045c8 00000012 00000082 ffe045da     .E...........E..
    1960:	0000001b 000000a2 ffe045f5 00000000     .........E......
    1970:	00002808 ffe045f8 00000012 00000082     .(...E..........
    1980:	ffe0460a 0000001b 000000a2 ffe04625     .F..........%F..
    1990:	00000000 00002808 ffe04628 00000017     .....(..(F......
    19a0:	00000082 ffe0463f 00000000 00002808     ....?F.......(..
    19b0:	ffe04640 0000001f 00000082 ffe0465f     @F.........._F..
    19c0:	00000000 00002808 ffe04660 00000032     .....(..`F..2...
    19d0:	00000082 ffe04692 00000000 00000008     .....F..........
    19e0:	ffe04692 00000008 000000a2 ffe0469a     .F...........F..
    19f0:	00000007 000000a2 ffe046a1 00000000     .........F......
    1a00:	00002808 ffe046a4 00000023 00000082     .(...F..#.......
    1a10:	ffe046c7 00000002 000000a2 ffe046c9     .F...........F..
    1a20:	00000008 000000a2 ffe046d1 00000000     .........F......
    1a30:	00000008 ffe046d1 00000007 000000a2     .....F..........
    1a40:	ffe046d8 00000000 00002808 ffe046d8     .F.......(...F..
    1a50:	00000025 00000082 ffe046fd 0000000c     %........F......
    1a60:	000000a2 ffe04709 00000000 00000008     .....G..........
    1a70:	ffe04709 00000002 000000a2 ffe0470b     .G...........G..
    1a80:	00000002 000000a2 ffe0470d 00000016     .........G......
    1a90:	000000a2 ffe04723 00000000 00000008     ....#G..........
    1aa0:	ffe04723 00000012 000000a2 ffe04735     #G..........5G..
    1ab0:	00000005 000000a2 ffe0473a 00000000     ........:G......
    1ac0:	00000008 ffe0473a 00000027 000000a2     ....:G..'.......
    1ad0:	ffe04761 00000009 000000a2 ffe0476a     aG..........jG..
    1ae0:	00000006 000000a2 ffe04770 00000000     ........pG......
    1af0:	00000008 ffe04770 00000018 000000a2     ....pG..........
    1b00:	ffe04788 00000000 00002808 ffe04788     .G.......(...G..
    1b10:	0000001e 00000082 ffe047a6 0000000b     .........G......
    1b20:	000000a2 ffe047b1 00000000 00000008     .....G..........
    1b30:	ffe047b1 0000000e 000000a2 ffe047bf     .G...........G..
    1b40:	00000000 00000008 ffe047bf 0000000c     .........G......
    1b50:	000000a2 ffe047cb 00000000 00000008     .....G..........
    1b60:	ffe047cb 00000009 000000a2 ffe047d4     .G...........G..
    1b70:	00000000 00000008 ffe047d4 00000005     .........G......
    1b80:	000000a2 ffe047d9 00000000 00002808     .....G.......(..
    1b90:	ffe047dc 0000001a 00000082 ffe047f6     .G...........G..
    1ba0:	00000000 00002808 ffe047f8 0000001e     .....(...G......
    1bb0:	00000082 ffe04816 00000009 000000a2     .....H..........
    1bc0:	ffe0481f 00000012 000000a2 ffe04831     .H..........1H..
    1bd0:	00000014 000000a2 ffe04845 00000014     ........EH......
    1be0:	000000a2 ffe04859 00000000 00000008     ....YH..........
    1bf0:	ffe04859 00000006 000000a2 ffe0485f     YH.........._H..
    1c00:	00000018 000000a2 ffe04877 00000009     ........wH......
    1c10:	000000a2 ffe04880 0000000b 000000a2     .....H..........
    1c20:	ffe0488b 00000000 00002808 ffe0488c     .H.......(...H..
    1c30:	0000001c 00000082 ffe048a8 00000003     .........H......
    1c40:	000000a2 ffe048ab 0000001d 000000a2     .....H..........
    1c50:	ffe048c8 00000009 000000a2 ffe048d1     .H...........H..
    1c60:	00000018 000000a2 ffe048e9 00000000     .........H......
    1c70:	00002808 ffe048ec 00000017 00000082     .(...H..........
    1c80:	ffe04903 00000000 00002808 ffe04904     .I.......(...I..
    1c90:	00000009 00000082 ffe0490d 00000002     .........I......
    1ca0:	00000092 ffe0490f 00000000 00002808     .....I.......(..
    1cb0:	ffe04910 00000033 00000082 ffe04943     .I..3.......CI..
    1cc0:	00000000 00002808 ffe04944 00000052     .....(..DI..R...
    1cd0:	00000082 ffe04996 00000000 00000008     .....I..........
    1ce0:	ffe04996 00000003 000000a2 ffe04999     .I...........I..
    1cf0:	000000fd 000000a2 ffe04a96 00000009     .........J......
    1d00:	000000a2 ffe04a9f 00000000 00000008     .....J..........
    1d10:	ffe04a9f 00000003 000000a2 ffe04aa2     .J...........J..
    1d20:	00000017 000000a2 ffe04ab9 00000000     .........J......
    1d30:	00002808 ffe04abc 00000022 00000082     .(...J..".......
    1d40:	ffe04ade 00000026 000000a2 ffe04b04     .J..&........K..
    1d50:	00000023 00000092 ffe04b27 00000000     #.......'K......
    1d60:	00002808 ffe04b28 00000015 00000082     .(..(K..........
    1d70:	ffe04b3d 00000000 00000008 ffe04b3d     =K..........=K..
    1d80:	0000000d 000000a2 ffe04b4a 00000000     ........JK......
    1d90:	00000008 ffe04b4a 0000000a 000000a2     ....JK..........
    1da0:	ffe04b54 00000000 00002808 ffe04b54     TK.......(..TK..
    1db0:	00000032 00000082 ffe04b86 00000014     2........K......
    1dc0:	00000092 ffe04b9a 00000002 00000092     .....K..........
    1dd0:	ffe04b9c 00000000 00002808 ffe04b9c     .K.......(...K..
    1de0:	00000026 00000082 ffe04bc2 0000001f     &........K......
    1df0:	00000092 ffe04be1 00000005 000000a2     .....K..........
    1e00:	ffe04be6 00000002 00000092 ffe04be8     .K...........K..
    1e10:	00000000 00002808 ffe04be8 0000000b     .....(...K......
    1e20:	00000082 ffe04bf3 00000009 000000a2     .....K..........
    1e30:	ffe04bfc 0000000a 000000a2 ffe04c06     .K...........L..
    1e40:	00000000 00002808 ffe04c08 00000019     .....(...L......
    1e50:	00000082 ffe04c21 00000000 00000008     ....!L..........
    1e60:	ffe04c21 00000004 000000a2 ffe04c25     !L..........%L..
    1e70:	00000000 00002808 ffe04c28 0000000d     .....(..(L......
    1e80:	00000082 ffe04c35 00000000 00000008     ....5L..........
    1e90:	ffe04c35 00000007 000000a2 ffe04c3c     5L..........<L..
    1ea0:	00000007 000000a2 ffe04c43 00000000     ........CL......
    1eb0:	00000008 ffe04c43 00000010 000000a2     ....CL..........
    1ec0:	ffe04c53 00000000 00000008 ffe04c53     SL..........SL..
    1ed0:	0000000a 000000a2 ffe04c5d 00000000     ........]L......
    1ee0:	00000008 ffe04c5d 00000007 000000a2     ....]L..........
    1ef0:	ffe04c64 00000000 00002808 ffe04c64     dL.......(..dL..
    1f00:	00000029 00000082 ffe04c8d 00000017     )........L......
    1f10:	000000a2 ffe04ca4 00000000 00000008     .....L..........
    1f20:	ffe04ca4 00000003 000000a2 ffe04ca7     .L...........L..
    1f30:	0000007d 000000a2 ffe04d24 00000032     }.......$M..2...
    1f40:	000000a2 ffe04d56 00000000 00000008     ....VM..........
    1f50:	ffe04d56 00000005 000000a2 ffe04d5b     VM..........[M..
    1f60:	00000000 00000008 ffe04d5b 00000002     ........[M......
    1f70:	000000a2 ffe04d5d 0000002c 000000a2     ....]M..,.......
    1f80:	ffe04d89 00000018 000000a2 ffe04da1     .M...........M..
    1f90:	0000000d 000000a2 ffe04dae 00000000     .........M......
    1fa0:	00000008 ffe04dae 00000005 000000a2     .....M..........
    1fb0:	ffe04db3 00000000 00000008 ffe04db3     .M...........M..
    1fc0:	00000002 000000a2 ffe04db5 00000016     .........M......
    1fd0:	000000a2 ffe04dcb 00000000 00000008     .....M..........
    1fe0:	ffe04dcb 00000002 000000a2 ffe04dcd     .M...........M..
    1ff0:	00000019 000000a2 ffe04de6 00000000     .........M......
    2000:	00000008 ffe04de6 00000005 000000a2     .....M..........
    2010:	ffe04deb 00000000 00002808 ffe04dec     .M.......(...M..
    2020:	00000003 00000082 ffe04def 00000000     .........M......
    2030:	00000008 ffe04def 00000002 000000a2     .....M..........
    2040:	ffe04df1 00000007 000000a2 ffe04df8     .M...........M..
    2050:	00000000 00002808 ffe04df8 0000005b     .....(...M..[...
    2060:	00000082 ffe04e53 00000008 000000a2     ....SN..........
    2070:	ffe04e5b 00000025 000000a2 ffe04e80     [N..%........N..
    2080:	00000000 00002808 ffe04e80 00000018     .....(...N......
    2090:	00000082 ffe04e98 00000028 00000092     .....N..(.......
    20a0:	ffe04ec0 00000000 00002808 ffe04ec0     .N.......(...N..
    20b0:	00000040 00000082 ffe04f00 0000000e     @........O......
    20c0:	000000a2 ffe04f0e 00000000 00000008     .....O..........
    20d0:	ffe04f0e 00000022 000000a2 ffe04f30     .O..".......0O..
    20e0:	00000006 000000a2 ffe04f36 0000000b     ........6O......
    20f0:	000000a2 ffe04f41 00000000 00000008     ....AO..........
    2100:	ffe04f41 0000000c 000000a2 ffe04f4d     AO..........MO..
    2110:	00000002 000000a2 ffe04f4f 0000001e     ........OO......
    2120:	000000a2 ffe04f6d 00000000 00000008     ....mO..........
    2130:	ffe04f6d 00000015 000000a2 ffe04f82     mO...........O..
    2140:	00000000 00000008 ffe04f82 00000003     .........O......
    2150:	000000a2 ffe04f85 00000003 000000a2     .....O..........
    2160:	ffe04f88 00000007 000000a2 ffe04f8f     .O...........O..
    2170:	00000010 000000a2 ffe04f9f 00000016     .........O......
    2180:	000000a2 ffe04fb5 00000006 000000a2     .....O..........
    2190:	ffe04fbb 00000014 000000a2 ffe04fcf     .O...........O..
    21a0:	00000000 00000008 ffe04fcf 0000000c     .........O......
    21b0:	000000a2 ffe04fdb 00000002 000000a2     .....O..........
    21c0:	ffe04fdd 0000000e 000000a2 ffe04feb     .O...........O..
    21d0:	00000011 000000a2 ffe04ffc 00000000     .........O......
    21e0:	00000008 ffe04ffc 0000000e 000000a2     .....O..........
    21f0:	ffe0500a 00000002 000000a2 ffe0500c     .P...........P..
    2200:	0000002a 000000a2 ffe05036 0000000c     *.......6P......
    2210:	00000092 ffe05042 00000014 000000a2     ....BP..........
    2220:	ffe05056 00000000 00002808 ffe05058     VP.......(..XP..
    2230:	0000000d 00000082 ffe05065 00000002     ........eP......
    2240:	00000092 ffe05067 00000000 00002808     ....gP.......(..
    2250:	ffe05068 00000018 00000082 ffe05080     hP...........P..
    2260:	00000003 000000a2 ffe05083 00000019     .........P......
    2270:	000000a2 ffe0509c 0000000f 000000a2     .....P..........
    2280:	ffe050ab 00000000 00002808 ffe050ac     .P.......(...P..
    2290:	00000022 00000082 ffe050ce 0000000c     "........P......
    22a0:	000000a2 ffe050da 00000024 000000a2     .....P..$.......
    22b0:	ffe050fe 0000001a 000000a2 ffe05118     .P...........Q..
    22c0:	0000000f 000000a2 ffe05127 00000000     ........'Q......
    22d0:	00000008 ffe05127 00000018 000000a2     ....'Q..........
    22e0:	ffe0513f 00000000 00000008 ffe0513f     ?Q..........?Q..
    22f0:	00000052 000000a2 ffe05191 00000000     R........Q......
    2300:	00000008 ffe05191 00000021 000000a2     .....Q..!.......
    2310:	ffe051b2 00000000 00002808 ffe051b4     .Q.......(...Q..
    2320:	00000022 00000082 ffe051d6 0000003d     "........Q..=...
    2330:	000000a2 ffe05213 00000003 00000092     .....R..........
    2340:	ffe05216 00000005 000000a2 ffe0521b     .R...........R..
    2350:	00000000 00000008 ffe0521b 00000002     .........R......
    2360:	000000a2 ffe0521d 0000004f 000000a2     .....R..O.......
    2370:	ffe0526c 0000000b 000000a2 ffe05277     lR..........wR..
    2380:	00000014 000000a2 ffe0528b 00000000     .........R......
    2390:	00000008 ffe0528b 00000248 000000a2     .....R..H.......
    23a0:	ffe054d3 00000000 00000008 ffe054d3     .T...........T..
    23b0:	000000e7 000000a2 ffe055ba 00000000     .........U......
    23c0:	00000008 ffe055ba 00000030 000000a2     .....U..0.......
    23d0:	ffe055ea 00000025 00000092 ffe0560f     .U..%........V..
    23e0:	00000000 00002808 ffe05610 00000242     .....(...V..B...
    23f0:	00000082 ffe05852 00000037 000000a2     ....RX..7.......
    2400:	ffe05889 00000003 00000092 ffe0588c     .X...........X..
    2410:	00000186 000000a2 ffe05a12 00000017     .........Z......
    2420:	000000a2 ffe05a29 00000000 00000008     ....)Z..........
    2430:	ffe05a29 00000002 00000082 ffe05a2b     )Z..........+Z..
    2440:	00000006 000000a2 ffe05a31 00000011     ........1Z......
    2450:	000000a2 ffe05a42 0000003d 000000a2     ....BZ..=.......
    2460:	ffe05a7f 00000003 00000092 ffe05a82     .Z...........Z..
    2470:	00000005 000000a2 ffe05a87 00000000     .........Z......
    2480:	00000008 ffe05a87 00000002 000000a2     .....Z..........
    2490:	ffe05a89 0000004f 000000a2 ffe05ad8     .Z..O........Z..
    24a0:	0000000b 000000a2 ffe05ae3 00000022     .........Z.."...
    24b0:	000000a2 ffe05b05 00000000 00000008     .....[..........
    24c0:	ffe05b05 00000006 000000a2 ffe05b0b     .[...........[..
    24d0:	00000000 00000008 ffe05b0b 00000247     .........[..G...
    24e0:	000000a2 ffe05d52 00000000 00000008     ....R]..........
    24f0:	ffe05d52 000000e7 000000a2 ffe05e39     R]..........9^..
    2500:	00000000 00000008 ffe05e39 00000030     ........9^..0...
    2510:	000000a2 ffe05e69 00000026 00000092     ....i^..&.......
    2520:	ffe05e8f 00000000 00000008 ffe00c10     .^..............
    2530:	00000004 00002904 ffe00c14 00000004     .....)..........
    2540:	00003904 ffe00c18 00000004 00002904     .9...........)..
    2550:	ffe00c1c 00000004 00004904 ffe00c20     .........I.. ...
    2560:	00000004 00000104 ffe00c30 00000000     ........0.......
    2570:	00004904 ffe00c30 0000000c 00000104     .I..0...........
    2580:	ffe00c40 00000000 00004904 ffe00c40     @........I..@...
    2590:	00000009 00000104 ffe00c50 00000008     ........P.......
    25a0:	00000104 ffe00c60 0000000b 00000104     ....`...........
    25b0:	ffe00c70 00000140 00004904 ffe00db0     p...@....I......
    25c0:	00000014 00000104 ffe00dd0 00000040     ............@...
    25d0:	00004904 ffe00e10 00000004 00000104     .I..............
    25e0:	ffe00e18 00000000 00003904 ffe00e18     .........9......
    25f0:	00000008 00004904 ffe00e20 00000003     .....I.. .......
    2600:	00000104 ffe00e24 00000003 00000104     ....$...........
    2610:	ffe00e28 00000003 00000104 ffe00e40     (...........@...
    2620:	00000000 00004904 ffe00e40 00000008     .....I..@.......
    2630:	00000104 ffe00e50 00000000 00004904     ....P........I..
    2640:	ffe00e50 00000002 00000104 ffe00e54     P...........T...
    2650:	00000002 00000104 ffe00e60 00000000     ........`.......
    2660:	00004904 ffe00e60 00000011 00000104     .I..`...........
    2670:	ffe00e80 00000000 00004904 ffe00e80     .........I......
    2680:	0000001c 00000104 ffe00ea0 00000000     ................
    2690:	00004904 ffe00ea0 00000034 00000104     .I......4.......
    26a0:	ffe00ee0 00000000 00004904 ffe00ee0     .........I......
    26b0:	00000048 00000104 ffe00f30 00000000     H.......0.......
    26c0:	00004804 ffe00000 00000003 00000082     .H..............
    26d0:	ffe00003 00000000 00002808 ffe00004     .........(......
    26e0:	00000010 00002801 ffe00014 00000014     .....(..........
    26f0:	000000a2 ffe00028 0000001c 000000a2     ....(...........
    2700:	ffe01d64 00000004 00000001 ffe05e90     d............^..
    2710:	00000010 00000082 ffe05ea0 00000006     .........^......
    2720:	000000a2 ffe05ea6 00000000 00002808     .....^.......(..
    2730:	ffe05ea8 00000005 00000082 ffe05ead     .^...........^..
    2740:	00000000 00000008 ffe00b78 00000004     ........x.......
    2750:	00000001 ffe00978 00000004 00000001     ....x...........
    2760:	ffe009b8 00000004 00000001 ffe009f8     ................
    2770:	00000004 00000001 ffe00b38 00000004     ........8.......
    2780:	00000001 ffe00800 00000003 00000082     ................
    2790:	ffe00bc0 0000000d 00000082 ffe00980     ................
    27a0:	0000001d 00000082 ffe0099d 00000000     ................
    27b0:	00000008 ffe009c0 0000001d 00000082     ................
    27c0:	ffe009dd 00000000 00000008 ffe00a00     ................
    27d0:	0000001d 00000082 ffe00a1d 00000000     ................
    27e0:	00000008 ffe00b40 0000001d 00000082     ....@...........
    27f0:	ffe00b5d 00000000 00000008 ffe05eb0     ]............^..
    2800:	00000018 00000082 ffe05ec8 0000000f     .........^......
    2810:	000000a2 ffe05ed7 00000000 00000008     .....^..........
    2820:	ffe00a40 00000003 00000082 ffe00a43     @...........C...
    2830:	00000003 000000a2 ffe00a46 00000000     ........F.......
    2840:	00000008 ffe00a80 00000008 00000082     ................
    2850:	ffe00a88 00000003 000000a2 ffe00a8b     ................
    2860:	00000000 00000008 ffe00bd0 00000006     ................
    2870:	000000a2 ffe00bd6 00000000 00000008     ................
    2880:	ffe00b00 00000006 000000a2 ffe00b06     ................
    2890:	00000000 00000008 ffe00ac0 00000003     ................
    28a0:	00000082 ffe00ac3 00000000 00000008     ................

Disassembly of section .xt.lit:

00000000 <.xt.lit>:
   0:	ffe0197c 000003e8 ffe00004 00000010     |...............
  10:	ffe01d64 00000004 ffe00b78 00000004     d.......x.......
  20:	ffe00978 00000004 ffe009b8 00000004     x...............
  30:	ffe009f8 00000004 ffe00b38 00000004     ........8.......

Disassembly of section .comment:

00000000 <.comment>:
   0:	65745823 2061736e 706d6f43 72656c69     #Xtensa Compiler
  10:	72655620 6e6f6973 2e313120 20312e30      Version 11.0.1 
  20:	3120203a 63204d2e 69706d6f 2064656c     :  1.M compiled 
  30:	68746977 2d203a20 2d20324f 692d3367     with : -O2 -g3-i
  40:	00206170                                pa .

Disassembly of section .xtensa.info:

00000000 <.xtensa.info>:
   0:	0000000c 000001cc 00000001 6e657458     ............Xten
  10:	495f6173 006f666e 435f5748 49464e4f     sa_Info.HW_CONFI
  20:	30444947 6378303d 66336432 0a656662     GID0=0xc2d3fbfe.
  30:	435f5748 49464e4f 31444947 3178303d     HW_CONFIGID1=0x1
  40:	31353463 0a396637 4c495542 4e555f44     c4517f9.BUILD_UN
  50:	45555149 3d44495f 30307830 37313530     IQUE_ID=0x000517
  60:	410a3966 313d4942 4553550a 5342415f     f9.ABI=1.USE_ABS
  70:	54554c4f 494c5f45 41524554 303d534c     OLUTE_LITERALS=0
  80:	5f57480a 53524556 3d4e4f49 36584c22     .HW_VERSION="LX6
  90:	312e302e 57480a22 4e494d5f 5245565f     .0.1".HW_MIN_VER
  a0:	4e4f4953 4a414d5f 323d524f 0a303036     SION_MAJOR=2600.
  b0:	4d5f5748 565f4e49 49535245 4d5f4e4f     HW_MIN_VERSION_M
  c0:	524f4e49 480a313d 414d5f57 45565f58     INOR=1.HW_MAX_VE
  d0:	4f495352 414d5f4e 3d524f4a 30303632     RSION_MAJOR=2600
  e0:	5f57480a 5f58414d 53524556 5f4e4f49     .HW_MAX_VERSION_
  f0:	4f4e494d 0a313d52 454c4552 5f455341     MINOR=1.RELEASE_
 100:	454d414e 4652223d 3130322d 22312e34     NAME="RF-2014.1"
 110:	4c45520a 45534145 5245565f 4e4f4953     .RELEASE_VERSION
 120:	3131223d 312e302e 45520a22 5341454c     ="11.0.1".RELEAS
 130:	414d5f45 3d524f4a 30307830 61323030     E_MAJOR=0x00002a
 140:	520a3866 41454c45 4d5f4553 524f4e49     f8.RELEASE_MINOR
 150:	430a313d 5f45524f 454d414e 6672223d     =1.CORE_NAME="rf
 160:	74616976 6f6c6569 3631706f 49540a22     viatieloop16".TI
 170:	48435f45 534b4345 305f4d55 6478303d     E_CHECKSUM_0=0xd
 180:	64613035 0a396136 5f454954 43454843     50ad6a9.TIE_CHEC
 190:	4d55534b 303d315f 38323278 38323732     KSUM_1=0x2282728
 1a0:	49540a33 48435f45 534b4345 325f4d55     3.TIE_CHECKSUM_2
 1b0:	6378303d 62393239 0a373931 5f454954     =0xc929b197.TIE_
 1c0:	43454843 4d55534b 303d335f 66656178     CHECKSUM_3=0xaef
 1d0:	37623763 44540a37 41505f4b 223d4854     c7b77.TDK_PATH="
 1e0:	00000a22                                "...
